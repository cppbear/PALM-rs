{
  "name": "regex_syntax::hir::literal::hir::literal::Literals::union_prefixes",
  "name_with_impl": "regex_syntax::hir::literal::{impl#0}::union_prefixes",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:27:1:27:17"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/literal/mod.rs:326:5:330:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: lits.is_empty() is true\n",
        "// expected return value/type: !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n"
      ],
      "input_infer": "limit_size: 1-100, limit_class: 0-50, c: 'A'-'Z', b: 0-255, expr.kind: HirKind::Literal(hir::Literal::Unicode(c)) | HirKind::Literal(hir::Literal::Byte(b)) | HirKind::Class(hir::Class::Unicode(_)) | HirKind::Class(hir::Class::Bytes(_)) | HirKind::Group(_) | HirKind::Repetition(_) | HirKind::Concat(_) | HirKind::Alternation(_), lit.length: 0-10, num_bytes: 0-100\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(10);",
                "    literals.set_limit_class(5);",
                "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result == true);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 10);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 5);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals().len() > 0);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.contains_empty() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.contains_empty() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(10);",
                "    literals.set_limit_class(5);",
                "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(result, true);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(literals.limit_size(), 10);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(literals.limit_class(), 5);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(result, true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(literals.limit_size(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(literals.limit_class(), 5);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:80\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:80\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Unicode('B')), info: HirInfo::default() };\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(10);",
                "    literals.set_limit_class(5);",
                "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(literals.limit_size() == 10);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(literals.limit_class() == 5);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr) == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(literals.limit_size() == 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(literals.limit_class() == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(10);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr) == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:76\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:76\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:76\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:76\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:76\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:76\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:76\n     |\n1562 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:76\n     |\n1567 |     let expr = Hir { kind: HirKind::Literal(hir::Literal::Byte(10)), info: HirInfo::default() };\n     |                                                                            ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(20);",
                "    literals.set_limit_class(5);",
                "    let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided",
                "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() <= 20);"
                ],
                [
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() <= 5);"
                ],
                [
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.any_complete());"
                ],
                [
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() <= 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() <= 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let unicode_class = hir::ClassUnicode::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:86\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:86\n     |\n1568 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:44\n     |\n1562 |     let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:44\n     |\n1567 |     let unicode_class = hir::ClassUnicode::default();\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:86\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:86\n     |\n1568 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:44\n     |\n1562 |     let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:44\n     |\n1567 |     let unicode_class = hir::ClassUnicode::default();\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:86\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:86\n     |\n1568 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:44\n     |\n1562 |     let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:44\n     |\n1567 |     let unicode_class = hir::ClassUnicode::default();\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:86\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:86\n     |\n1568 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:44\n     |\n1562 |     let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:44\n     |\n1567 |     let unicode_class = hir::ClassUnicode::default();\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:86\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:86\n     |\n1568 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(unicode_class)), info: HirInfo::default() };\n     |                                                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:44\n     |\n1562 |     let unicode_class = hir::ClassUnicode::default(); // Assuming default implementation is provided\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:44\n     |\n1567 |     let unicode_class = hir::ClassUnicode::default();\n     |                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(20);",
                "    literals.set_limit_class(5);",
                "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result == false);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.is_empty() == true);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 20);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 5);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals().len() == 0);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.contains_empty() == false);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.any_complete() == false);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.all_complete() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.is_empty() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals().len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.contains_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.any_complete() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let bytes_class = hir::ClassBytes::default();",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.all_complete() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:82\n     |\n1569 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(bytes_class)), info: HirInfo::default() };\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1562:40\n     |\n1562 |     let bytes_class = hir::ClassBytes::default(); // Assuming default implementation is provided\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:40\n     |\n1568 |     let bytes_class = hir::ClassBytes::default();\n     |                                        ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(20);",
                "    literals.set_limit_class(5);",
                "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_size(), 20);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_class(), 5);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(literals.literals().len() > 0);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(!literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(literals.min_len().is_some());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_size(), 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_class(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(literals.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };",
                  "    assert!(literals.min_len().is_some());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:123\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:176\n     |\n1562 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:123\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:176\n     |\n1567 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:45\n     |\n1562 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1562 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1567 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0559.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:123\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:176\n     |\n1562 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:123\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:176\n     |\n1567 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:45\n     |\n1562 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1562 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1567 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0559.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:123\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:176\n     |\n1562 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:123\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:176\n     |\n1567 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:45\n     |\n1562 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1562 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1567 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0559.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:123\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:176\n     |\n1562 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:123\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:176\n     |\n1567 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:45\n     |\n1562 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1562 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1567 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0559.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:123\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:176\n     |\n1562 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:123\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:176\n     |\n1567 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:45\n     |\n1562 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1562 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1567 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0559.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:123\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:176\n     |\n1562 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:123\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('C')), info: HirInfo::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:176\n     |\n1567 | ...o::default() }), ..Default::default() }, info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:45\n     |\n1562 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1562 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nerror[E0559]: variant `hir::HirKind::Group` has no field named `hir`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let expr = Hir { kind: HirKind::Group { hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('C')), info: HirInfo::defaul...\n     |                                             ^^^ field does not exist\n     |\n    ::: regex-syntax/src/hir/mod.rs:188:5\n     |\n188  |     Group(Group),\n     |     ----- `hir::HirKind::Group` defined here\n     |\nhelp: `hir::HirKind::Group` is a tuple variant, use the appropriate syntax\n     |\n1567 |     let expr = Hir { kind: HirKind::Group(/* hir::Group */), info: HirInfo::default() };\n     |                                          ~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0559.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(20);",
                "    literals.set_limit_class(5);",
                "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let repetition = hir::Repetition { kind: hir::RepetitionKind::OneOrMore, hir: Box::new(Hir { kind: HirKind::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };",
                  "    let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:156\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:67\n     |\n1563 |     let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n     |                                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:156\n     |\n1568 | ...nd::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:67\n     |\n1569 |     let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n     |                                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:156\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:67\n     |\n1563 |     let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n     |                                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:156\n     |\n1568 | ...nd::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:67\n     |\n1569 |     let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n     |                                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:156\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:67\n     |\n1563 |     let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n     |                                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:156\n     |\n1568 | ...nd::Literal(hir::Literal::Unicode('D')), info: HirInfo::default() }), greedy: true };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1569:67\n     |\n1569 |     let expr = Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() };\n     |                                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(20);",
                "    literals.set_limit_class(5);",
                "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result == true);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 20);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 5);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals().len() == 1);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals()[0] == Literal::Unicode('E'));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.any_complete());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.all_complete());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.is_empty() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(result == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.literals()[0] == Literal::Unicode('E'));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.is_empty() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:48\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     assert!(literals.literals()[0] == Literal::Unicode('E'));\n     |                                                ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:113\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:143\n     |\n1562 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:113\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:143\n     |\n1567 | ...ode('E')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(20);",
                "    literals.set_limit_class(5);",
                "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr) == true);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_size() == 20);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_class() == 5);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.literals().is_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.contains_empty() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr) == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_size() == 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_class() == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.literals().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(20);",
                  "    literals.set_limit_class(5);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.contains_empty() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:118\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:148\n     |\n1562 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:118\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:148\n     |\n1567 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:118\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:148\n     |\n1562 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:118\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:148\n     |\n1567 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:118\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:148\n     |\n1562 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:118\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:148\n     |\n1567 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:118\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:148\n     |\n1562 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:118\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:148\n     |\n1567 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:118\n     |\n1562 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1562:148\n     |\n1562 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:118\n     |\n1567 | ...nd::Literal(hir::Literal::Unicode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:148\n     |\n1567 | ...ode('F')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: lits.is_empty() is false\n",
        "// constraint: lits.contains_empty() is true\n",
        "// expected return value/type: !lits.is_empty() && !lits.contains_empty() && self.union(lits)\n"
      ],
      "input_infer": "lits.size: 1-100, lits.contains_empty: true, self.limit_size: 1-100, self.num_bytes: 0-99\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![Literal::Unicode('a')],",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                "        info: HirInfo::default(),",
                "    };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.lits.len() > 0);"
                ],
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size == 10);"
                ],
                [
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class == 5);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('a')],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.lits.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('a')],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('a')],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size == 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('a')],",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals {",
                  "    lits: vec![Literal::Unicode('a')],",
                  "    limit_size: 10,",
                  "    limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('b')),",
                  "    info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class == 5);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:11\n     |\n1576 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('a')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:25\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     lits: vec![Literal::Unicode('a')],\n     |                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:11\n     |\n1576 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('a')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:25\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     lits: vec![Literal::Unicode('a')],\n     |                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:11\n     |\n1576 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('a')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:25\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     lits: vec![Literal::Unicode('a')],\n     |                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1576:11\n     |\n1576 |     info: HirInfo::default(),\n     |           ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('a')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1570:25\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1570 |     lits: vec![Literal::Unicode('a')],\n     |                         ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![Literal::empty()], // Contains empty literal",
                "        limit_size: 10,",
                "        limit_class: 5,",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Hir {",
                "                kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                "                info: HirInfo::default(),",
                "            }",
                "        ]),",
                "        info: HirInfo::default(),",
                "    };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert_eq!(literals.union_prefixes(&expr), false);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.lits.len() == 1);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.lits[0].is_empty());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_size == 10);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_class == 5);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::empty()], // Contains empty literal",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert_eq!(literals.union_prefixes(&expr), false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::empty()], // Contains empty literal",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.lits.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::empty()], // Contains empty literal",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.lits[0].is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::empty()], // Contains empty literal",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_size == 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::empty()], // Contains empty literal",
                  "        limit_size: 10,",
                  "        limit_class: 5,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::empty()], limit_size: 10, limit_class: 5 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    assert!(literals.limit_class == 5);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('c')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![Literal::Unicode('x')],",
                "        limit_size: 1, // Limit is set low to trigger size check",
                "        limit_class: 2,",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Hir {",
                "                kind: HirKind::Literal(hir::Literal::Unicode('y')),",
                "                info: HirInfo::default(),",
                "            }",
                "        ]),",
                "        info: HirInfo::default(),",
                "    };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.lits.len() == 1);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 1);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('x')],",
                  "        limit_size: 1, // Limit is set low to trigger size check",
                  "        limit_class: 2,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('y')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('x')],",
                  "        limit_size: 1, // Limit is set low to trigger size check",
                  "        limit_class: 2,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('y')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.lits.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('x')],",
                  "        limit_size: 1, // Limit is set low to trigger size check",
                  "        limit_class: 2,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('y')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('x')],",
                  "        limit_size: 1, // Limit is set low to trigger size check",
                  "        limit_class: 2,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('y')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_size() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('x')],",
                  "        limit_size: 1, // Limit is set low to trigger size check",
                  "        limit_class: 2,",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir {",
                  "                kind: HirKind::Literal(hir::Literal::Unicode('y')),",
                  "                info: HirInfo::default(),",
                  "            }",
                  "        ]),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };",
                  "    let expr = Hir { kind: HirKind::Concat(vec![Hir { kind: HirKind::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };",
                  "    let result = literals.union_prefixes(&expr);",
                  "    assert!(literals.limit_class() == 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('x')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1574 |     let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('x')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1574 |     let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('x')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1574 |     let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('x')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1574 |     let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1568:23\n     |\n1568 |                 info: HirInfo::default(),\n     |                       ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:113\n     |\n1575 | ...nd::Literal(hir::Literal::Unicode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1575:143\n     |\n1575 | ...ode('y')), info: HirInfo::default() }]), info: HirInfo::default() };\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('x')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1574 |     let mut literals = Literals { lits: vec![Literal::Unicode('x')], limit_size: 1, limit_class: 2 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals {",
                "        lits: vec![Literal::Unicode('z')],",
                "        limit_size: 100,",
                "        limit_class: 0, // Set to zero to trigger class limit check",
                "    };",
                "    let expr = Hir {",
                "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                "        info: HirInfo::default(),",
                "    };",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_size(), 100);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_class(), 0);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr) == false);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.literals().is_empty());"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.any_complete() == false);"
                ],
                [
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.all_complete() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_size(), 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert_eq!(literals.limit_class(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.union_prefixes(&expr) == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.literals().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.any_complete() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals {",
                  "        lits: vec![Literal::Unicode('z')],",
                  "        limit_size: 100,",
                  "        limit_class: 0, // Set to zero to trigger class limit check",
                  "    };",
                  "    let expr = Hir {",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),",
                  "        info: HirInfo::default(),",
                  "    };",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };",
                  "    assert!(literals.all_complete() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:15\n     |\n1566 |         info: HirInfo::default(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:97\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                                                                 ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:29\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1560 |         lits: vec![Literal::Unicode('z')],\n     |                             ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:50\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())),\n     |                                                  ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1565 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))),\n     |                                                                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:55\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1569 |     let mut literals = Literals { lits: vec![Literal::Unicode('z')], limit_size: 100, limit_class: 0 };\n     |                                                       ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:63\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new())), info: HirInfo::default() };\n     |                                                               ^^^^^^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n1570 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode::new(/* ranges */))), info: HirInfo::default() };\n     |                                                                                     ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: lits.is_empty() is false\n",
        "// constraint: lits.contains_empty() is false\n"
      ],
      "input_infer": "1 <= limit_size <= 1000, 1 <= limit_class <= 100, 1 <= num_bytes <= limit_size, 1 <= expr_prefix_length <= 100, expr_prefix_length != 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(500);",
                "    literals.set_limit_class(50);",
                "    ",
                "    let unicode_literal = Literal::Unicode('a');",
                "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                "    ",
                "    literals.add(unicode_literal);",
                "    literals.add(byte_literal);",
                "    ",
                "    let expr = Hir { ",
                "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                "        info: HirInfo { /* initialization fields */ }",
                "    };",
                "    ",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.union_prefixes(&expr));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.limit_size() == 500);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.limit_class() == 50);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.literals().len() > 0);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.any_complete());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(!literals.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                  "    ",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                  "    ",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.limit_size() == 500);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                  "    ",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.limit_class() == 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                  "    ",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                  "    ",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                  "    ",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(literals.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000); // byte representation of '('",
                  "    ",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(500);",
                  "    literals.set_limit_class(50);",
                  "    let unicode_literal = Literal::Unicode('a');",
                  "    let byte_literal = Literal::Byte(0b00101000);",
                  "    literals.add(unicode_literal);",
                  "    literals.add(byte_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:122\n     |\n1582 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let byte_literal = Literal::Byte(0b00101000); // byte representation of '('\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), \n     |                                                  ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1579 |     let byte_literal = Literal::Byte(0b00101000);\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:63\n     |\n1582 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* ini...\n     |                                                               ^^^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:122\n     |\n1582 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let byte_literal = Literal::Byte(0b00101000); // byte representation of '('\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), \n     |                                                  ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1579 |     let byte_literal = Literal::Byte(0b00101000);\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:63\n     |\n1582 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* ini...\n     |                                                               ^^^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:122\n     |\n1582 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let byte_literal = Literal::Byte(0b00101000); // byte representation of '('\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), \n     |                                                  ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1579 |     let byte_literal = Literal::Byte(0b00101000);\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:63\n     |\n1582 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* ini...\n     |                                                               ^^^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:122\n     |\n1582 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let byte_literal = Literal::Byte(0b00101000); // byte representation of '('\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), \n     |                                                  ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1579 |     let byte_literal = Literal::Byte(0b00101000);\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:63\n     |\n1582 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* ini...\n     |                                                               ^^^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:122\n     |\n1582 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let byte_literal = Literal::Byte(0b00101000); // byte representation of '('\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), \n     |                                                  ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1579 |     let byte_literal = Literal::Byte(0b00101000);\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:63\n     |\n1582 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* ini...\n     |                                                               ^^^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:122\n     |\n1582 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let byte_literal = Literal::Byte(0b00101000); // byte representation of '('\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), \n     |                                                  ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1579 |     let byte_literal = Literal::Byte(0b00101000);\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:63\n     |\n1582 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* ini...\n     |                                                               ^^^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:15\n     |\n1571 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:122\n     |\n1582 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ } };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1564 |     let byte_literal = Literal::Byte(0b00101000); // byte representation of '('\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:50\n     |\n1570 |         kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), \n     |                                                  ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     let unicode_literal = Literal::Unicode('a');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Byte` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:33\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Byte` not found for this struct\n...\n1579 |     let byte_literal = Literal::Byte(0b00101000);\n     |                                 ^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:63\n     |\n1582 |     let expr = Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* ini...\n     |                                                               ^^^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(800);",
                "    literals.set_limit_class(100);",
                "    ",
                "    let unicode_literal_a = Literal::Unicode('a');",
                "    let unicode_literal_b = Literal::Unicode('b');",
                "    ",
                "    literals.add(unicode_literal_a);",
                "    literals.add(unicode_literal_b);",
                "    ",
                "    let expr = Hir { ",
                "        kind: HirKind::Concat(vec![",
                "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                "        ]), ",
                "        info: HirInfo { /* initialization fields */ }",
                "    };",
                "    ",
                "    literals.union_prefixes(&expr);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.union_prefixes(&expr));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.limit_size(), 800);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.limit_class(), 100);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.literals().len(), 2);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.literals()[0], unicode_literal_a);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.literals()[1], unicode_literal_b);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    ",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    ",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.limit_size(), 800);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    ",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.limit_class(), 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    ",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.literals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    ",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.literals()[0], unicode_literal_a);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    ",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Concat(vec![",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    literals.union_prefixes(&expr);",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(800);",
                  "    literals.set_limit_class(100);",
                  "    let unicode_literal_a = Literal::Unicode('a');",
                  "    let unicode_literal_b = Literal::Unicode('b');",
                  "    literals.add(unicode_literal_a);",
                  "    literals.add(unicode_literal_b);",
                  "    let expr = Hir { kind: HirKind::Concat(vec![",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},",
                  "    Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}",
                  "    ]), info: HirInfo { /* initialization fields */ }};",
                  "    assert_eq!(literals.literals()[1], unicode_literal_b);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:77\n     |\n1571 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:77\n     |\n1572 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1586:69\n     |\n1586 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1587:69\n     |\n1587 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:15\n     |\n1588 |     ]), info: HirInfo { /* initialization fields */ }};\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1581 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:77\n     |\n1571 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:77\n     |\n1572 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1586:69\n     |\n1586 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1587:69\n     |\n1587 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:15\n     |\n1588 |     ]), info: HirInfo { /* initialization fields */ }};\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1581 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:77\n     |\n1571 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:77\n     |\n1572 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1586:69\n     |\n1586 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1587:69\n     |\n1587 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:15\n     |\n1588 |     ]), info: HirInfo { /* initialization fields */ }};\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1581 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:77\n     |\n1571 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:77\n     |\n1572 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1586:69\n     |\n1586 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1587:69\n     |\n1587 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:15\n     |\n1588 |     ]), info: HirInfo { /* initialization fields */ }};\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1581 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:77\n     |\n1571 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:77\n     |\n1572 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1586:69\n     |\n1586 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1587:69\n     |\n1587 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:15\n     |\n1588 |     ]), info: HirInfo { /* initialization fields */ }};\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1581 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:77\n     |\n1571 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1572:77\n     |\n1572 |             Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:15\n     |\n1574 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1586:69\n     |\n1586 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('a')), info: HirInfo { /* initialization fields */ }},\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1587:69\n     |\n1587 |     Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo { /* initialization fields */ }}\n     |                                                                     ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:15\n     |\n1588 |     ]), info: HirInfo { /* initialization fields */ }};\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1564 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1581:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1581 |     let unicode_literal_a = Literal::Unicode('a');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:38\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal_b = Literal::Unicode('b');\n     |                                      ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(700);",
                "    literals.set_limit_class(80);",
                "    ",
                "    let empty_literal = Literal::Unicode('\\0'); // null character",
                "    literals.add(empty_literal);",
                "    ",
                "    let expr = Hir { ",
                "        kind: HirKind::Literal(hir::Literal::Unicode('c')), ",
                "        info: HirInfo { /* initialization fields */ },",
                "    };",
                "    ",
                "    assert!(!literals.union_prefixes(&expr)); // this should return false due to contains_empty",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    let empty_literal = Literal::Unicode('\\0');",
                  "    literals.add(empty_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(!literals.union_prefixes(&expr));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    let empty_literal = Literal::Unicode('\\0');",
                  "    literals.add(empty_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert_eq!(literals.is_empty(), false);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    let empty_literal = Literal::Unicode('\\0');",
                  "    literals.add(empty_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    ",
                  "    let empty_literal = Literal::Unicode('\\0'); // null character",
                  "    literals.add(empty_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Literal(hir::Literal::Unicode('c')), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to contains_empty",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    let empty_literal = Literal::Unicode('\\0');",
                  "    literals.add(empty_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(!literals.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    ",
                  "    let empty_literal = Literal::Unicode('\\0'); // null character",
                  "    literals.add(empty_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Literal(hir::Literal::Unicode('c')), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to contains_empty",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    let empty_literal = Literal::Unicode('\\0');",
                  "    literals.add(empty_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert_eq!(literals.is_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    ",
                  "    let empty_literal = Literal::Unicode('\\0'); // null character",
                  "    literals.add(empty_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Literal(hir::Literal::Unicode('c')), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to contains_empty",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(700);",
                  "    literals.set_limit_class(80);",
                  "    let empty_literal = Literal::Unicode('\\0');",
                  "    literals.add(empty_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Unicode('c')),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:34\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let empty_literal = Literal::Unicode('\\0'); // null character\n     |                                  ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:34\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let empty_literal = Literal::Unicode('\\0');\n     |                                  ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:34\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let empty_literal = Literal::Unicode('\\0'); // null character\n     |                                  ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:34\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let empty_literal = Literal::Unicode('\\0');\n     |                                  ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:11\n     |\n1579 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:34\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let empty_literal = Literal::Unicode('\\0'); // null character\n     |                                  ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:34\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let empty_literal = Literal::Unicode('\\0');\n     |                                  ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(100);",
                "    literals.set_limit_class(10);",
                "    ",
                "    let unicode_literal = Literal::Unicode('x');",
                "    literals.add(unicode_literal);",
                "    ",
                "    let expr = Hir { ",
                "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                "        info: HirInfo { /* initialization fields */ },",
                "    };",
                "    ",
                "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(!literals.union_prefixes(&expr));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.limit_size() == 100);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.limit_class() == 10);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.literals().len() == 1);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert_eq!(literals.literals()[0], Literal::Unicode('x'));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.any_complete());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(!literals.all_complete());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(!literals.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.limit_size() == 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.limit_class() == 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.literals().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert_eq!(literals.literals()[0], Literal::Unicode('x'));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(literals.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(!literals.union_prefixes(&expr)); // this should return false due to limit size",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(100);",
                  "    literals.set_limit_class(10);",
                  "    let unicode_literal = Literal::Unicode('x');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };",
                  "    assert!(!literals.all_complete());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1578:49\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1578 |     assert_eq!(literals.literals()[0], Literal::Unicode('x'));\n     |                                                 ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1577:118\n     |\n1577 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }, };\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:48\n     |\n1567 |         kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), \n     |                                                ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1575 |     let unicode_literal = Literal::Unicode('x');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1577:61\n     |\n1577 |     let expr = Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initial...\n     |                                                             ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(600);",
                "    literals.set_limit_class(60);",
                "    ",
                "    let unicode_literal = Literal::Unicode('z');",
                "    literals.add(unicode_literal);",
                "    ",
                "    let expr = Hir { ",
                "        kind: HirKind::Repetition(hir::Repetition { ",
                "            kind: hir::RepetitionKind::OneOrMore, ",
                "            hir: Box::new(Hir { ",
                "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                "                info: HirInfo { /* initialization fields */ }",
                "            }), ",
                "            greedy: true ",
                "        }), ",
                "        info: HirInfo { /* initialization fields */ },",
                "    };",
                "    ",
                "    assert!(literals.union_prefixes(&expr)); // should succeed",
                "}"
              ],
              "oracles": [
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.union_prefixes(&expr));"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert_eq!(literals.limit_size(), 600);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert_eq!(literals.limit_class(), 60);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.literals().len() > 0);"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.any_complete());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(!literals.contains_empty());"
                ],
                [
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.min_len().is_some());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert_eq!(literals.limit_size(), 600);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert_eq!(literals.limit_class(), 60);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(!literals.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    ",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Repetition(hir::Repetition { ",
                  "            kind: hir::RepetitionKind::OneOrMore, ",
                  "            hir: Box::new(Hir { ",
                  "                kind: HirKind::Literal(hir::Literal::Byte(b'a')), ",
                  "                info: HirInfo { /* initialization fields */ }",
                  "            }), ",
                  "            greedy: true ",
                  "        }), ",
                  "        info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should succeed",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(600);",
                  "    literals.set_limit_class(60);",
                  "    let unicode_literal = Literal::Unicode('z');",
                  "    literals.add(unicode_literal);",
                  "    let expr = Hir {",
                  "    kind: HirKind::Repetition(hir::Repetition {",
                  "    kind: hir::RepetitionKind::OneOrMore,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Literal(hir::Literal::Byte(b'a')),",
                  "    info: HirInfo { /* initialization fields */ }",
                  "    }),",
                  "    greedy: true",
                  "    }),",
                  "    info: HirInfo { /* initialization fields */ },",
                  "    };",
                  "    assert!(literals.min_len().is_some());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1571:23\n     |\n1571 |                 info: HirInfo { /* initialization fields */ }\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1575:15\n     |\n1575 |         info: HirInfo { /* initialization fields */ },\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:11\n     |\n1589 |     info: HirInfo { /* initialization fields */ }\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1593:11\n     |\n1593 |     info: HirInfo { /* initialization fields */ },\n     |           ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1563:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1563 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Unicode` found for struct `literal::Literal` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1582:36\n     |\n56   | pub struct Literal {\n     | ------------------ associated item `Unicode` not found for this struct\n...\n1582 |     let unicode_literal = Literal::Unicode('z');\n     |                                    ^^^^^^^ associated item not found in `Literal`\n     |\nnote: if you're trying to build a new `literal::Literal` consider using one of the following associated functions:\n      literal::Literal::new\n      literal::Literal::empty\n    --> regex-syntax/src/hir/literal/mod.rs:881:5\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n886  |     pub fn empty() -> Literal {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut literals = Literals::empty();",
                "    literals.set_limit_size(1000);",
                "    literals.set_limit_class(100);",
                "    ",
                "    let expr = Hir { ",
                "        kind: HirKind::Alternation(vec![",
                "            Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},",
                "            Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}",
                "        ]), ",
                "        info: HirInfo { /* initialization fields */ }",
                "    };",
                "    ",
                "    assert!(literals.union_prefixes(&expr)); // should process correctly even with an empty literal array.",
                "}"
              ],
              "oracles": [
                [
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.union_prefixes(&expr));"
                ],
                [
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(!literals.is_empty());"
                ],
                [
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.limit_size() == 1000);"
                ],
                [
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.limit_class() == 100);"
                ],
                [
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.any_complete());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should process correctly even with an empty literal array.",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.union_prefixes(&expr));",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should process correctly even with an empty literal array.",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(!literals.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should process correctly even with an empty literal array.",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.limit_size() == 1000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should process correctly even with an empty literal array.",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.limit_class() == 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut literals = Literals::empty();",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    ",
                  "    let expr = Hir { ",
                  "        kind: HirKind::Alternation(vec![",
                  "            Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},",
                  "            Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}",
                  "        ]), ",
                  "        info: HirInfo { /* initialization fields */ }",
                  "    };",
                  "    ",
                  "    assert!(literals.union_prefixes(&expr)); // should process correctly even with an empty literal array.",
                  "    literals.set_limit_size(1000);",
                  "    literals.set_limit_class(100);",
                  "    let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};",
                  "    assert!(literals.any_complete());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:119\n     |\n1565 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:115\n     |\n1566 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:160\n     |\n1574 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::By...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:304\n     |\n1574 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization field...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:354\n     |\n1574 | ... HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:60\n     |\n1565 | ...   Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                      ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:58\n     |\n1566 | ...   Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization f...\n     |                                                    ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:101\n     |\n1574 |     let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization...\n     |                                                                                                     ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:247\n     |\n1574 | ...*/ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                        ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:119\n     |\n1565 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:115\n     |\n1566 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:160\n     |\n1574 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::By...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:304\n     |\n1574 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization field...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:354\n     |\n1574 | ... HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:60\n     |\n1565 | ...   Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                      ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:58\n     |\n1566 | ...   Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization f...\n     |                                                    ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:101\n     |\n1574 |     let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization...\n     |                                                                                                     ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:247\n     |\n1574 | ...*/ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                        ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:119\n     |\n1565 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:115\n     |\n1566 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:160\n     |\n1574 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::By...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:304\n     |\n1574 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization field...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:354\n     |\n1574 | ... HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:60\n     |\n1565 | ...   Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                      ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:58\n     |\n1566 | ...   Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization f...\n     |                                                    ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:101\n     |\n1574 |     let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization...\n     |                                                                                                     ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:247\n     |\n1574 | ...*/ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                        ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:119\n     |\n1565 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:115\n     |\n1566 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:160\n     |\n1574 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::By...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:304\n     |\n1574 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization field...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:354\n     |\n1574 | ... HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:60\n     |\n1565 | ...   Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                      ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:58\n     |\n1566 | ...   Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization f...\n     |                                                    ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:101\n     |\n1574 |     let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization...\n     |                                                                                                     ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:247\n     |\n1574 | ...*/ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                        ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1565:119\n     |\n1565 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }},\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1566:115\n     |\n1566 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:15\n     |\n1568 |         info: HirInfo { /* initialization fields */ }\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:160\n     |\n1574 | ...ssUnicode { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}, Hir { kind: HirKind::Class(hir::Class::By...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:304\n     |\n1574 | ...lassBytes { /* initialization fields */ })), info: HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization field...\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `HirInfo` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1574:354\n     |\n1574 | ... HirInfo { /* initialization fields */ }}]), info: HirInfo { /* initialization fields */ }};\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:60\n     |\n1565 | ...   Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                      ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:58\n     |\n1566 | ...   Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initialization f...\n     |                                                    ^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassUnicode`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:101\n     |\n1574 |     let expr = Hir { kind: HirKind::Alternation(vec![Hir { kind: HirKind::Class(hir::Class::Unicode(hir::ClassUnicode { /* initialization...\n     |                                                                                                     ^^^^^^^^^^^^^^^^^ missing `set`\n\nerror[E0063]: missing field `set` in initializer of `hir::ClassBytes`\n    --> regex-syntax/src/hir/literal/mod.rs:1574:247\n     |\n1574 | ...*/ }}, Hir { kind: HirKind::Class(hir::Class::Bytes(hir::ClassBytes { /* initialization fields */ })), info: HirInfo { /* initializati...\n     |                                                        ^^^^^^^^^^^^^^^ missing `set`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}