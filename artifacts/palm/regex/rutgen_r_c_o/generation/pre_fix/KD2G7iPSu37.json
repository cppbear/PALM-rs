{
  "name": "regex::exec::<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at",
  "name_with_impl": "regex::exec::{impl#2}::is_match_at",
  "mod_info": {
    "name": "exec",
    "loc": "src/lib.rs:652:1:652:10"
  },
  "visible": true,
  "loc": "src/exec.rs:434:5:475:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::Nothing is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "start: 0, text: [u8; 1..=100] where text is a string that does not end in an expected match based on the regex defined by MatchType::Nothing\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: &[u8] = b\"Sample text that does not match the regex\";",
                "    let start: usize = 0;",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"Sample regex\".to_string()],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: true,",
                "            is_bytes: false,",
                "            is_dfa: false,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: false,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::new(),",
                "            dfa_size_limit: 0,",
                "        },",
                "        dfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: true,",
                "            is_bytes: false,",
                "            is_dfa: false,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: false,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::new(),",
                "            dfa_size_limit: 0,",
                "        },",
                "        dfa_reverse: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: true,",
                "            is_bytes: false,",
                "            is_dfa: false,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: false,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::new(),",
                "            dfa_size_limit: 0,",
                "        },",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::Nothing,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner{",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    let _ = exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: &[u8] = b\"Sample text that does not match the regex\";",
                  "    let start: usize = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"Sample regex\".to_string()],",
                  "    nfa: Program { ..Default::default() },",
                  "    dfa: Program { ..Default::default() },",
                  "    dfa_reverse: Program { ..Default::default() },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Nothing,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { ..Default::default() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: &[u8] = b\"Sample text that does not match the regex\";",
                  "    let start: usize = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Sample regex\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: false,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::new(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: false,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::new(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: false,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::new(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Nothing,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner{",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let _ = exec.is_match_at(text, start);",
                  "    let text: &[u8] = b\"Sample text that does not match the regex\";",
                  "    let start: usize = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"Sample regex\".to_string()],",
                  "    nfa: Program { ..Default::default() },",
                  "    dfa: Program { ..Default::default() },",
                  "    dfa_reverse: Program { ..Default::default() },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Nothing,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { ..Default::default() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:40\n     |\n1377 |             prefixes: LiteralSearcher::new(),\n     |                                        ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:23\n     |\n1377 |             prefixes: LiteralSearcher::new(),\n     |                       ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |             prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1394:40\n     |\n1394 |             prefixes: LiteralSearcher::new(),\n     |                                        ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1394:23\n     |\n1394 |             prefixes: LiteralSearcher::new(),\n     |                       ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1394 |             prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1411:40\n     |\n1411 |             prefixes: LiteralSearcher::new(),\n     |                                        ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1411:23\n     |\n1411 |             prefixes: LiteralSearcher::new(),\n     |                       ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1411 |             prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1414:36\n     |\n1414 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1414:19\n     |\n1414 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1414 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1419:17\n     |\n1419 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1419 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1420:20\n     |\n1420 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1420 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1421:14\n     |\n1421 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1421 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1422:22\n     |\n1422 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1422 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1435:22\n     |\n1435 |     nfa: Program { ..Default::default() },\n     |                      ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:22\n     |\n1436 |     dfa: Program { ..Default::default() },\n     |                      ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1438:32\n     |\n1438 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1437:30\n     |\n1437 |     dfa_reverse: Program { ..Default::default() },\n     |                              ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1438:15\n     |\n1438 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1438 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `exec::ProgramCacheInner: Default` is not satisfied\n    --> src/exec.rs:1441:52\n     |\n1441 |     let cache = RefCell::new(ProgramCacheInner { ..Default::default() });\n     |                                                    ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `exec::ProgramCacheInner`\n\nSome errors have detailed explanations: E0061, E0277, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 18 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::Nfa(ty) is true\n",
        "// constraint: self.ro.match_type matches MatchType::Nfa(ty) is true\n"
      ],
      "input_infer": "text length: [1, 1048576], start: [0, text.length-1], self.ro.match_type: [MatchType::Nfa(Auto), MatchType::Nfa(Backtrack), MatchType::Nfa(PikeVM)]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                "    let text: &[u8] = b\"test string for regex\";",
                "    let start = 0;",
                "    ",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![String::from(\"test\")],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: true,",
                "            is_bytes: false,",
                "            is_dfa: false,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 0,",
                "        },",
                "        dfa: Program::default(),",
                "        dfa_reverse: Program::default(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner::default());",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"test string for regex\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"test\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"test string for regex\";",
                  "    let start = 0;",
                  "    ",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"test\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"test string for regex\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"test\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse` and `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1394:23\n     |\n1394 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse` and `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1398:7\n     |\n1398 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 7 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let match_type = MatchType::Nfa(MatchNfaType::Backtrack);",
                "    let text: &[u8] = b\"another test string\";",
                "    let start = 0;",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![String::from(\"another\")],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: true,",
                "            is_bytes: false,",
                "            is_dfa: false,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 0,",
                "        },",
                "        dfa: Program::default(),",
                "        dfa_reverse: Program::default(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner::default());",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert!(exec.is_match_at(text, start));"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert_eq!(exec.is_match_at(text, start), true);"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert_eq!(exec.ro.nfa.captures.len(), 0);"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert!(matches!(exec.ro.match_type, MatchType::Nfa(MatchNfaType::Backtrack)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Backtrack);",
                  "    let text: &[u8] = b\"another test string\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"another\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert!(exec.is_match_at(text, start));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Backtrack);",
                  "    let text: &[u8] = b\"another test string\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"another\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert_eq!(exec.is_match_at(text, start), true);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Backtrack);",
                  "    let text: &[u8] = b\"another test string\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"another\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert_eq!(exec.ro.nfa.captures.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Backtrack);",
                  "    let text: &[u8] = b\"another test string\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"another\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    is_anchored_end: true,",
                  "    });",
                  "    assert!(matches!(exec.ro.match_type, MatchType::Nfa(MatchNfaType::Backtrack)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `exec::ExecReadOnly` has no field named `is_anchored_end`\n    --> src/exec.rs:1392:5\n     |\n1392 |     is_anchored_end: true,\n     |     ^^^^^^^^^^^^^^^ `exec::ExecReadOnly` does not have this field\n     |\n     = note: available fields are: `res`, `nfa`, `dfa`, `dfa_reverse`, `suffixes`, `match_type`\n\nSome errors have detailed explanations: E0560, E0599.\nFor more information about an error, try `rustc --explain E0560`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `exec::ExecReadOnly` has no field named `is_anchored_end`\n    --> src/exec.rs:1392:5\n     |\n1392 |     is_anchored_end: true,\n     |     ^^^^^^^^^^^^^^^ `exec::ExecReadOnly` does not have this field\n     |\n     = note: available fields are: `res`, `nfa`, `dfa`, `dfa_reverse`, `suffixes`, `match_type`\n\nSome errors have detailed explanations: E0560, E0599.\nFor more information about an error, try `rustc --explain E0560`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `exec::ExecReadOnly` has no field named `is_anchored_end`\n    --> src/exec.rs:1392:5\n     |\n1392 |     is_anchored_end: true,\n     |     ^^^^^^^^^^^^^^^ `exec::ExecReadOnly` does not have this field\n     |\n     = note: available fields are: `res`, `nfa`, `dfa`, `dfa_reverse`, `suffixes`, `match_type`\n\nSome errors have detailed explanations: E0560, E0599.\nFor more information about an error, try `rustc --explain E0560`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `exec::ExecReadOnly` has no field named `is_anchored_end`\n    --> src/exec.rs:1392:5\n     |\n1392 |     is_anchored_end: true,\n     |     ^^^^^^^^^^^^^^^ `exec::ExecReadOnly` does not have this field\n     |\n     = note: available fields are: `res`, `nfa`, `dfa`, `dfa_reverse`, `suffixes`, `match_type`\n\nSome errors have detailed explanations: E0560, E0599.\nFor more information about an error, try `rustc --explain E0560`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                "    let text: &[u8] = b\"pike vm regex test\";",
                "    let start = 0;",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![String::from(\"pike\")],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: true,",
                "            is_bytes: false,",
                "            is_dfa: false,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 0,",
                "        },",
                "        dfa: Program::default(),",
                "        dfa_reverse: Program::default(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner::default());",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_match_at(text, start));"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_anchor_end_match(text));"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert_eq!(exec.ro.match_type, MatchType::Nfa(MatchNfaType::PikeVM));"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.ro.nfa.is_anchored_end);"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(!exec.ro.nfa.is_anchored_start);"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.ro.nfa.only_utf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"pike\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_match_at(text, start));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"pike\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_anchor_end_match(text));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"pike\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert_eq!(exec.ro.match_type, MatchType::Nfa(MatchNfaType::PikeVM));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"pike\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.ro.nfa.is_anchored_end);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"pike\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(!exec.ro.nfa.is_anchored_start);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"pike\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::PikeVM);",
                  "    let text: &[u8] = b\"pike vm regex test\";",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"pike\")],",
                  "    nfa: Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: false,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    },",
                  "    dfa: Program::default(),",
                  "    dfa_reverse: Program::default(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.ro.nfa.only_utf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1410:32\n     |\n1410 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1413:19\n     |\n1413 |     dfa: Program::default(),\n     |                   ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1414:27\n     |\n1414 |     dfa_reverse: Program::default(),\n     |                           ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1415:32\n     |\n1415 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1418:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1418 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 10 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1410:32\n     |\n1410 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1413:19\n     |\n1413 |     dfa: Program::default(),\n     |                   ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1414:27\n     |\n1414 |     dfa_reverse: Program::default(),\n     |                           ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1415:32\n     |\n1415 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1418:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1418 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 10 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1410:32\n     |\n1410 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1413:19\n     |\n1413 |     dfa: Program::default(),\n     |                   ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1414:27\n     |\n1414 |     dfa_reverse: Program::default(),\n     |                           ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1415:32\n     |\n1415 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1418:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1418 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1420:5\n     |\n1420 |     assert_eq!(exec.ro.match_type, MatchType::Nfa(MatchNfaType::PikeVM));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 11 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1410:32\n     |\n1410 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1413:19\n     |\n1413 |     dfa: Program::default(),\n     |                   ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1414:27\n     |\n1414 |     dfa_reverse: Program::default(),\n     |                           ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1415:32\n     |\n1415 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1418:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1418 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 10 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1410:32\n     |\n1410 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1413:19\n     |\n1413 |     dfa: Program::default(),\n     |                   ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1414:27\n     |\n1414 |     dfa_reverse: Program::default(),\n     |                           ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1415:32\n     |\n1415 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1418:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1418 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 10 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1410:32\n     |\n1410 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1413:19\n     |\n1413 |     dfa: Program::default(),\n     |                   ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1414:27\n     |\n1414 |     dfa_reverse: Program::default(),\n     |                           ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1415:32\n     |\n1415 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1418:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1418 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 10 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                "    let text: &[u8] = b\"A\".repeat(1048576).as_slice(); // generate long text",
                "    let start = 0;",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![String::from(\"A\")],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: true,",
                "            is_bytes: false,",
                "            is_dfa: false,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 0,",
                "        },",
                "        dfa: Program::default(),",
                "        dfa_reverse: Program::default(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner::default());",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_match_at(text, start));"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(self.is_anchor_end_match(text));"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert_eq!(self.ro.match_type, MatchType::Nfa(MatchNfaType::Auto));"
                ],
                [
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert_eq!(self.ro.nfa.is_anchored_end, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice(); // generate long text",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"A\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec.is_match_at(text, start));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice(); // generate long text",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"A\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(self.is_anchor_end_match(text));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice(); // generate long text",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"A\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert_eq!(self.ro.match_type, MatchType::Nfa(MatchNfaType::Auto));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice(); // generate long text",
                  "    let start = 0;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"A\")],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: true,",
                  "            is_bytes: false,",
                  "            is_dfa: false,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 0,",
                  "        },",
                  "        dfa: Program::default(),",
                  "        dfa_reverse: Program::default(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner::default());",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let match_type = MatchType::Nfa(MatchNfaType::Auto);",
                  "    let text: &[u8] = b\"A\".repeat(1048576).as_slice();",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"A\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert_eq!(self.ro.nfa.is_anchored_end, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse` and `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1394:23\n     |\n1394 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse` and `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1398:7\n     |\n1398 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 7 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0424]: expected value, found module `self`\n    --> src/exec.rs:1403:13\n     |\n1356 | fn test_is_match_at_13()\n     |    ------------------- this function can't have a `self` parameter\n...\n1403 |     assert!(self.is_anchor_end_match(text));\n     |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse` and `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1394:23\n     |\n1394 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse` and `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1398:7\n     |\n1398 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0424, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0424]: expected value, found module `self`\n    --> src/exec.rs:1403:16\n     |\n1356 | fn test_is_match_at_14()\n     |    ------------------- this function can't have a `self` parameter\n...\n1403 |     assert_eq!(self.ro.match_type, MatchType::Nfa(MatchNfaType::Auto));\n     |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse` and `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1394:23\n     |\n1394 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse` and `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1398:7\n     |\n1398 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0424, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0424]: expected value, found module `self`\n    --> src/exec.rs:1403:16\n     |\n1356 | fn test_is_match_at_15()\n     |    ------------------- this function can't have a `self` parameter\n...\n1403 |     assert_eq!(self.ro.nfa.is_anchored_end, true);\n     |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1378:40\n     |\n1378 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1381:23\n     |\n1381 |         dfa: Program::default(),\n     |                       ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `prog::Program` in the current scope\n    --> src/exec.rs:1382:31\n     |\n1382 |         dfa_reverse: Program::default(),\n     |                               ^^^^^^^ function or associated item not found in `Program`\n     |\n    ::: src/prog.rs:18:1\n     |\n18   | pub struct Program {\n     | ------------------ function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `prog::Program`, consider using `prog::Program::new` which returns `prog::Program`\n    --> src/prog.rs:80:5\n     |\n80   |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1387:49\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1387 |     let cache = RefCell::new(ProgramCacheInner::default());\n     |                                                 ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse` and `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1394:23\n     |\n1394 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse` and `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1398:7\n     |\n1398 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0424, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaMany is true\n",
        "// constraint: self.ro.match_type matches MatchType::Dfa or MatchType::DfaMany is true\n",
        "// constraint: self.shortest_dfa(text, start) matches dfa::Result::NoMatch(_) is true\n",
        "// constraint: self.shortest_dfa(text, start) matches dfa::Result::NoMatch(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "text: [1..255], start: [0..254]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"test\".to_string()],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: false,",
                "            is_bytes: true,",
                "            is_dfa: true,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 1024,",
                "        },",
                "        dfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: false,",
                "            is_bytes: true,",
                "            is_dfa: true,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 1024,",
                "        },",
                "        dfa_reverse: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: false,",
                "            is_bytes: true,",
                "            is_dfa: true,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 1024,",
                "        },",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaMany,",
                "    });",
                "    ",
                "    let cache = ProgramCache::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text: &[u8] = &[1, 2, 3, 4, 5]; // Ensure this does not match",
                "    let start: usize = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    let dfa_result = exec.shortest_dfa(text, start);",
                  "    assert_eq!(dfa_result, dfa::Result::NoMatch(_));"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    let dfa_result = exec.shortest_dfa(text, start);",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaMany,",
                  "    });",
                  "    ",
                  "    let cache = ProgramCache::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = &[1, 2, 3, 4, 5]; // Ensure this does not match",
                  "    let start: usize = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    let dfa_result = exec.shortest_dfa(text, start);",
                  "    assert_eq!(dfa_result, dfa::Result::NoMatch(_));",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaMany,",
                  "    });",
                  "    ",
                  "    let cache = ProgramCache::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = &[1, 2, 3, 4, 5]; // Ensure this does not match",
                  "    let start: usize = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    let dfa_result = exec.shortest_dfa(text, start);",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> src/exec.rs:1445:49\n     |\n1445 |     assert_eq!(dfa_result, dfa::Result::NoMatch(_));\n     |                                                 ^ `_` not allowed here\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1432:7\n     |\n1432 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0063]: missing field `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1428:23\n     |\n1428 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0369]: binary operation `==` cannot be applied to type `dfa::Result<usize>`\n    --> src/exec.rs:1445:5\n     |\n1445 |     assert_eq!(dfa_result, dfa::Result::NoMatch(_));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     dfa::Result<usize>\n     |     dfa::Result<_>\n     |\nnote: an implementation of `PartialEq<dfa::Result<_>>` might be missing for `dfa::Result<usize>`\n    --> src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<dfa::Result<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `dfa::Result<usize>` with `#[derive(PartialEq)]`\n    -->  src/dfa.rs:218:1\n     |\n218  + #[derive(PartialEq)]\n219  | pub enum Result<T> {\n     |\n\nSome errors have detailed explanations: E0063, E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1432:7\n     |\n1432 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0063]: missing field `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1428:23\n     |\n1428 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"example\".to_string()],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: false,",
                "            is_bytes: true,",
                "            is_dfa: true,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 1024,",
                "        },",
                "        dfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: false,",
                "            is_bytes: true,",
                "            is_dfa: true,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 1024,",
                "        },",
                "        dfa_reverse: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![],",
                "            only_utf8: false,",
                "            is_bytes: true,",
                "            is_dfa: true,",
                "            is_reverse: false,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 1024,",
                "        },",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaMany,",
                "    });",
                "    ",
                "    let cache = ProgramCache::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text: &[u8] = &[10, 11, 12, 13, 14]; // Ensure this does not match",
                "    let start: usize = 1;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert!(exec.is_anchor_end_match(text) == true);"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert!(exec.ro.match_type == MatchType::DfaMany);"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert!(exec.shortest_dfa(text, start) == dfa::Result::NoMatch(_));"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert_eq!(exec.is_match_at(text, start), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"example\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaMany,",
                  "    });",
                  "    ",
                  "    let cache = ProgramCache::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = &[10, 11, 12, 13, 14]; // Ensure this does not match",
                  "    let start: usize = 1;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert!(exec.is_anchor_end_match(text) == true);",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"example\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaMany,",
                  "    });",
                  "    ",
                  "    let cache = ProgramCache::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = &[10, 11, 12, 13, 14]; // Ensure this does not match",
                  "    let start: usize = 1;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert!(exec.ro.match_type == MatchType::DfaMany);",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"example\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaMany,",
                  "    });",
                  "    ",
                  "    let cache = ProgramCache::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = &[10, 11, 12, 13, 14]; // Ensure this does not match",
                  "    let start: usize = 1;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert!(exec.shortest_dfa(text, start) == dfa::Result::NoMatch(_));",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"example\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![],",
                  "            only_utf8: false,",
                  "            is_bytes: true,",
                  "            is_dfa: true,",
                  "            is_reverse: false,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 1024,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaMany,",
                  "    });",
                  "    ",
                  "    let cache = ProgramCache::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = &[10, 11, 12, 13, 14]; // Ensure this does not match",
                  "    let start: usize = 1;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".to_string()],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type: MatchType::DfaMany,",
                  "    });",
                  "    assert_eq!(exec.is_match_at(text, start), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1432:7\n     |\n1432 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0063]: missing field `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1428:23\n     |\n1428 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1432:7\n     |\n1432 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0063]: missing field `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1428:23\n     |\n1428 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1444:32\n     |\n1444 |     assert!(exec.ro.match_type == MatchType::DfaMany);\n     |             ------------------ ^^ ------------------ exec::MatchType\n     |             |\n     |             exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0063, E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 13 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> src/exec.rs:1444:68\n     |\n1444 |     assert!(exec.shortest_dfa(text, start) == dfa::Result::NoMatch(_));\n     |                                                                    ^ `_` not allowed here\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1432:7\n     |\n1432 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0063]: missing field `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1428:23\n     |\n1428 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0369]: binary operation `==` cannot be applied to type `dfa::Result<usize>`\n    --> src/exec.rs:1444:44\n     |\n1444 |     assert!(exec.shortest_dfa(text, start) == dfa::Result::NoMatch(_));\n     |             ------------------------------ ^^ ----------------------- dfa::Result<_>\n     |             |\n     |             dfa::Result<usize>\n     |\nnote: an implementation of `PartialEq<dfa::Result<_>>` might be missing for `dfa::Result<usize>`\n    --> src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<dfa::Result<_>>`\nhelp: consider annotating `dfa::Result<usize>` with `#[derive(PartialEq)]`\n    -->  src/dfa.rs:218:1\n     |\n218  + #[derive(PartialEq)]\n219  | pub enum Result<T> {\n     |\n\nSome errors have detailed explanations: E0063, E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1432:7\n     |\n1432 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0063]: missing field `suffixes` in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1428:23\n     |\n1428 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `suffixes`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nSome errors have detailed explanations: E0063, E0277, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaSuffix is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaSuffix is true\n",
        "// constraint: self.shortest_dfa_reverse_suffix(text, start) matches dfa::Result::Quit is true\n"
      ],
      "input_infer": "text: [0..255], start: [0..text.len() - 1], match_type: MatchType::DfaSuffix, is_anchor_end_match: true, shortest_dfa_reverse_suffix: dfa::Result::Quit\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let match_type = MatchType::DfaSuffix;",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"test_regex\".to_string()],",
                "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        suffixes: LiteralSearcher {},",
                "        match_type: match_type,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text = vec![b'a', b'b', b'c']; // Sample text that meets the conditions",
                "    let start = 0; // Start position within bounds",
                "",
                "    let _result = regex.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert_eq!(ro.match_type, MatchType::DfaSuffix);"
                ],
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert!(regex.is_anchor_end_match(&text));"
                ],
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert_eq!(regex.shortest_dfa_reverse_suffix(&text, start), dfa::Result::Quit);"
                ],
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert_eq!(regex.find_literals(MatchLiteralType::Unanchored, &text, start).is_none(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text = vec![b'a', b'b', b'c']; // Sample text that meets the conditions",
                  "    let start = 0; // Start position within bounds",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert_eq!(ro.match_type, MatchType::DfaSuffix);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text = vec![b'a', b'b', b'c']; // Sample text that meets the conditions",
                  "    let start = 0; // Start position within bounds",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert!(regex.is_anchor_end_match(&text));",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text = vec![b'a', b'b', b'c']; // Sample text that meets the conditions",
                  "    let start = 0; // Start position within bounds",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert_eq!(regex.shortest_dfa_reverse_suffix(&text, start), dfa::Result::Quit);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text = vec![b'a', b'b', b'c']; // Sample text that meets the conditions",
                  "    let start = 0; // Start position within bounds",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    assert_eq!(regex.find_literals(MatchLiteralType::Unanchored, &text, start).is_none(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1383:5\n     |\n1383 |     assert_eq!(ro.match_type, MatchType::DfaSuffix);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 9 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `dfa::Result<usize>`\n    --> src/exec.rs:1383:5\n     |\n1383 |     assert_eq!(regex.shortest_dfa_reverse_suffix(&text, start), dfa::Result::Quit);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     dfa::Result<usize>\n     |     dfa::Result<_>\n     |\nnote: an implementation of `PartialEq<dfa::Result<_>>` might be missing for `dfa::Result<usize>`\n    --> src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<dfa::Result<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `dfa::Result<usize>` with `#[derive(PartialEq)]`\n    -->  src/dfa.rs:218:1\n     |\n218  + #[derive(PartialEq)]\n219  | pub enum Result<T> {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 9 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let match_type = MatchType::DfaSuffix;",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"test_regex\".to_string()],",
                "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        suffixes: LiteralSearcher {},",
                "        match_type: match_type,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text = vec![b'a', b'b', b'c', b'd']; // Sample text",
                "    let start = 0; // Start position within bounds",
                "",
                "    let _result = regex.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let is_anchor_end_match_result = regex.is_anchor_end_match(&text);",
                  "    assert!(is_anchor_end_match_result);"
                ],
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let is_anchor_end_match_result = regex.is_anchor_end_match(&text);",
                  "    let dfa_result = regex.shortest_dfa_reverse_suffix(&text, start);",
                  "    assert_eq!(dfa_result, dfa::Result::Quit);"
                ],
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let is_anchor_end_match_result = regex.is_anchor_end_match(&text);",
                  "    let dfa_result = regex.shortest_dfa_reverse_suffix(&text, start);",
                  "    let match_nfa_result = regex.match_nfa(&text, start);",
                  "    assert!(match_nfa_result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text = vec![b'a', b'b', b'c', b'd']; // Sample text",
                  "    let start = 0; // Start position within bounds",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let is_anchor_end_match_result = regex.is_anchor_end_match(&text);",
                  "    assert!(is_anchor_end_match_result);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text = vec![b'a', b'b', b'c', b'd']; // Sample text",
                  "    let start = 0; // Start position within bounds",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let is_anchor_end_match_result = regex.is_anchor_end_match(&text);",
                  "    let dfa_result = regex.shortest_dfa_reverse_suffix(&text, start);",
                  "    assert_eq!(dfa_result, dfa::Result::Quit);",
                  "}"
                ],
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text = vec![b'a', b'b', b'c', b'd']; // Sample text",
                  "    let start = 0; // Start position within bounds",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let is_anchor_end_match_result = regex.is_anchor_end_match(&text);",
                  "    let dfa_result = regex.shortest_dfa_reverse_suffix(&text, start);",
                  "    let match_nfa_result = regex.match_nfa(&text, start);",
                  "    assert!(match_nfa_result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `dfa::Result<usize>`\n    --> src/exec.rs:1385:5\n     |\n1385 |     assert_eq!(dfa_result, dfa::Result::Quit);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     dfa::Result<usize>\n     |     dfa::Result<_>\n     |\nnote: an implementation of `PartialEq<dfa::Result<_>>` might be missing for `dfa::Result<usize>`\n    --> src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<dfa::Result<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `dfa::Result<usize>` with `#[derive(PartialEq)]`\n    -->  src/dfa.rs:218:1\n     |\n218  + #[derive(PartialEq)]\n219  | pub enum Result<T> {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 9 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let match_type = MatchType::DfaSuffix;",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"test_regex\".to_string()],",
                "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                "        suffixes: LiteralSearcher {},",
                "        match_type: match_type,",
                "    });",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text: Vec<u8> = vec![]; // Empty text input",
                "    let start = 0; // Start position must be valid, but text is empty",
                "",
                "    let _result = regex.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let text: Vec<u8> = vec![];",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type: match_type,",
                  "    ..Default::default()",
                  "    });",
                  "    assert_eq!(regex.is_match_at(&text, start), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let match_type = MatchType::DfaSuffix;",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test_regex\".to_string()],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },",
                  "        suffixes: LiteralSearcher {},",
                  "        match_type: match_type,",
                  "    });",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let regex = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: Vec<u8> = vec![]; // Empty text input",
                  "    let start = 0; // Start position must be valid, but text is empty",
                  "",
                  "    let _result = regex.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaSuffix;",
                  "    let text: Vec<u8> = vec![];",
                  "    let start = 0;",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type: match_type,",
                  "    ..Default::default()",
                  "    });",
                  "    assert_eq!(regex.is_match_at(&text, start), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1362:311\n     |\n1362 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1362 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1363:311\n     |\n1363 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n1363 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1364:318\n     |\n1364 | ...red_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher {}, dfa_size_limit: 1024 },\n     |                                                               ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(_, _), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::empty(), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::prefixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n1364 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::suffixes(_), dfa_size_limit: 1024 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~\n\nerror: cannot construct `literal::LiteralSearcher` with struct literal syntax due to private fields\n    --> src/exec.rs:1365:19\n     |\n1365 |         suffixes: LiteralSearcher {},\n     |                   ^^^^^^^^^^^^^^^\n     |\n     = note: private fields `complete`, `lcp`, `lcs` and `matcher` that were not provided\nhelp: you might have meant to use an associated function to build this type\n     |\n1365 |         suffixes: LiteralSearcher::new(_, _),\n     |                                  ~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::empty(),\n     |                                  ~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::prefixes(_),\n     |                                  ~~~~~~~~~~~~~\n1365 |         suffixes: LiteralSearcher::suffixes(_),\n     |                                  ~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1370:32\n     |\n1370 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1371:38\n     |\n1371 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1372:26\n     |\n1372 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1373:34\n     |\n1373 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `exec::ExecReadOnly: Default` is not satisfied\n    --> src/exec.rs:1387:7\n     |\n1387 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `exec::ExecReadOnly`\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 9 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaSuffix is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaSuffix is true\n",
        "// constraint: self.shortest_dfa_reverse_suffix(text, start) matches dfa::Result::NoMatch(_) is true\n",
        "// constraint: self.shortest_dfa_reverse_suffix(text, start) matches dfa::Result::NoMatch(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "start: 0, text length: 1 to 100, match type: DfaSuffix where text does not match the suffix condition.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: InstPtr::default(),",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let exec_read_only = Arc::new(ExecReadOnly {",
                "        res: vec![\"test\".into()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &exec_read_only,",
                "        cache: &cache,",
                "    };",
                "",
                "    let text: &[u8] = b\"a\"; // text does not match the expected suffix",
                "    let start: usize = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"a\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert!(!result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: InstPtr::default(),",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test\".into()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = b\"a\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"a\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert!(!result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1370:16\n     |\n1370 |         start: InstPtr::default(),\n     |                ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1412:12\n     |\n1412 |     start: InstPtr::default(),\n     |            ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1359:32\n     |\n1359 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1360:38\n     |\n1360 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1361:26\n     |\n1361 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1362:34\n     |\n1362 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1402:28\n     |\n1402 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1403:34\n     |\n1403 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1404:22\n     |\n1404 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1405:30\n     |\n1405 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: InstPtr::default(),",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let exec_read_only = Arc::new(ExecReadOnly {",
                "        res: vec![\"test\".into()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &exec_read_only,",
                "        cache: &cache,",
                "    };",
                "",
                "    let text: &[u8] = b\"abcde\"; // text does not match the expected suffix",
                "    let start: usize = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"abcde\";",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: InstPtr::default(),",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test\".into()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = b\"abcde\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"abcde\";",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1370:16\n     |\n1370 |         start: InstPtr::default(),\n     |                ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1412:12\n     |\n1412 |     start: InstPtr::default(),\n     |            ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1359:32\n     |\n1359 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1360:38\n     |\n1360 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1361:26\n     |\n1361 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1362:34\n     |\n1362 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1402:28\n     |\n1402 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1403:34\n     |\n1403 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1404:22\n     |\n1404 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1405:30\n     |\n1405 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: InstPtr::default(),",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let exec_read_only = Arc::new(ExecReadOnly {",
                "        res: vec![\"test\".into()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &exec_read_only,",
                "        cache: &cache,",
                "    };",
                "",
                "    let text: &[u8] = b\"xyz\"; // text does not match the expected suffix",
                "    let start: usize = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"xyz\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert!(!result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: InstPtr::default(),",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test\".into()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = b\"xyz\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"xyz\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert!(!result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1370:16\n     |\n1370 |         start: InstPtr::default(),\n     |                ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1412:12\n     |\n1412 |     start: InstPtr::default(),\n     |            ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1359:32\n     |\n1359 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1360:38\n     |\n1360 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1361:26\n     |\n1361 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1362:34\n     |\n1362 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1402:28\n     |\n1402 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1403:34\n     |\n1403 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1404:22\n     |\n1404 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1405:30\n     |\n1405 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: InstPtr::default(),",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let exec_read_only = Arc::new(ExecReadOnly {",
                "        res: vec![\"example\".into()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &exec_read_only,",
                "        cache: &cache,",
                "    };",
                "",
                "    let text: &[u8] = b\"teststring\"; // text does not match the expected suffix",
                "    let start: usize = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"teststring\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: InstPtr::default(),",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"example\".into()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = b\"teststring\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"example\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"teststring\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1370:16\n     |\n1370 |         start: InstPtr::default(),\n     |                ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1412:12\n     |\n1412 |     start: InstPtr::default(),\n     |            ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1359:32\n     |\n1359 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1360:38\n     |\n1360 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1361:26\n     |\n1361 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1362:34\n     |\n1362 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1402:28\n     |\n1402 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1403:34\n     |\n1403 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1404:22\n     |\n1404 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1405:30\n     |\n1405 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: InstPtr::default(),",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let exec_read_only = Arc::new(ExecReadOnly {",
                "        res: vec![\"sample\".into()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &exec_read_only,",
                "        cache: &cache,",
                "    };",
                "",
                "    let text: &[u8] = b\"abcdef\"; // text does not match the expected suffix",
                "    let start: usize = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"sample\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"abcdef\";",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: InstPtr::default(),",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"sample\".into()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = b\"abcdef\"; // text does not match the expected suffix",
                  "    let start: usize = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: InstPtr::default(),",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 0,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"sample\".into()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"abcdef\";",
                  "    let start: usize = 0;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1370:16\n     |\n1370 |         start: InstPtr::default(),\n     |                ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `InstPtr`\n    --> src/exec.rs:1412:12\n     |\n1412 |     start: InstPtr::default(),\n     |            ^^^^^^^ use of undeclared type `InstPtr`\n     |\nhelp: consider importing this type alias\n     |\n1353 +    use prog::InstPtr;\n     |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1359:32\n     |\n1359 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1360:38\n     |\n1360 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1361:26\n     |\n1361 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1362:34\n     |\n1362 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1402:28\n     |\n1402 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1403:34\n     |\n1403 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1404:22\n     |\n1404 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1405:30\n     |\n1405 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaSuffix is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaSuffix is true\n",
        "// constraint: self.shortest_dfa_reverse_suffix(text, start) matches dfa::Result::Match(_) is true\n",
        "// constraint: self.shortest_dfa_reverse_suffix(text, start) matches dfa::Result::Match(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "text length: 1 to 1000, start: 0 to text length - 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![String::from(\"abc\")],",
                "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text: &[u8] = b\"abc\";",
                "    let start = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(exec.is_anchor_end_match(text));"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert_eq!(exec.ro.match_type, MatchType::DfaSuffix);"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(matches!(exec.shortest_dfa_reverse_suffix(text, start), dfa::Result::Match(_)));"
                ],
                [
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(exec.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"abc\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(exec.is_anchor_end_match(text));",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"abc\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert_eq!(exec.ro.match_type, MatchType::DfaSuffix);",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"abc\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(matches!(exec.shortest_dfa_reverse_suffix(text, start), dfa::Result::Match(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"abc\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly { ... });",
                  "    let cache = RefCell::new(ProgramCacheInner { ... });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(exec.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: expected identifier, found `...`\n    --> src/exec.rs:1373:38\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ------------   ^^^ expected identifier\n     |                       |\n     |                       while parsing this struct\n\nerror: expected identifier, found `...`\n    --> src/exec.rs:1374:50\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              -----------------   ^^^ expected identifier\n     |                              |\n     |                              while parsing this struct\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:327\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:310\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:334\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:317\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse`, `match_type` and 3 other fields in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1373:23\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse`, `match_type` and 3 other fields\n\nerror[E0063]: missing fields `backtrack`, `dfa`, `dfa_reverse` and 1 other field in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1374:30\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa`, `dfa_reverse` and 1 other field\n\nSome errors have detailed explanations: E0061, E0063, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: expected identifier, found `...`\n    --> src/exec.rs:1373:38\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ------------   ^^^ expected identifier\n     |                       |\n     |                       while parsing this struct\n\nerror: expected identifier, found `...`\n    --> src/exec.rs:1374:50\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              -----------------   ^^^ expected identifier\n     |                              |\n     |                              while parsing this struct\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:327\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:310\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:334\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:317\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse`, `match_type` and 3 other fields in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1373:23\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse`, `match_type` and 3 other fields\n\nerror[E0063]: missing fields `backtrack`, `dfa`, `dfa_reverse` and 1 other field in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1374:30\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa`, `dfa_reverse` and 1 other field\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1378:5\n     |\n1378 |     assert_eq!(exec.ro.match_type, MatchType::DfaSuffix);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0061, E0063, E0369, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 17 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: expected identifier, found `...`\n    --> src/exec.rs:1373:38\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ------------   ^^^ expected identifier\n     |                       |\n     |                       while parsing this struct\n\nerror: expected identifier, found `...`\n    --> src/exec.rs:1374:50\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              -----------------   ^^^ expected identifier\n     |                              |\n     |                              while parsing this struct\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:327\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:310\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:334\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:317\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse`, `match_type` and 3 other fields in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1373:23\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse`, `match_type` and 3 other fields\n\nerror[E0063]: missing fields `backtrack`, `dfa`, `dfa_reverse` and 1 other field in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1374:30\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa`, `dfa_reverse` and 1 other field\n\nSome errors have detailed explanations: E0061, E0063, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: expected identifier, found `...`\n    --> src/exec.rs:1373:38\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ------------   ^^^ expected identifier\n     |                       |\n     |                       while parsing this struct\n\nerror: expected identifier, found `...`\n    --> src/exec.rs:1374:50\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              -----------------   ^^^ expected identifier\n     |                              |\n     |                              while parsing this struct\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:327\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:310\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:334\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:317\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse`, `match_type` and 3 other fields in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1373:23\n     |\n1373 |     let ro = Arc::new(ExecReadOnly { ... });\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse`, `match_type` and 3 other fields\n\nerror[E0063]: missing fields `backtrack`, `dfa`, `dfa_reverse` and 1 other field in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1374:30\n     |\n1374 |     let cache = RefCell::new(ProgramCacheInner { ... });\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa`, `dfa_reverse` and 1 other field\n\nSome errors have detailed explanations: E0061, E0063, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![String::from(\"xyz\")],",
                "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                "    let start = 0;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert!(exec.is_anchor_end_match(text));"
                ],
                [
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert_eq!(exec.ro.match_type, MatchType::DfaSuffix);"
                ],
                [
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert!(matches!(exec.shortest_dfa_reverse_suffix(text, start), dfa::Result::Match(_)));"
                ],
                [
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"xyz\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert!(exec.is_anchor_end_match(text));",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"xyz\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert_eq!(exec.ro.match_type, MatchType::DfaSuffix);",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"xyz\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert!(matches!(exec.shortest_dfa_reverse_suffix(text, start), dfa::Result::Match(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"xyz\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let mut ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"xyz\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "    let text: &[u8] = b\"xyzxyzxyzxyzxyzxyz\";",
                  "    let start = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:326\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:309\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:333\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:316\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1375:323\n     |\n1375 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1375:306\n     |\n1375 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1375 |     nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1376:322\n     |\n1376 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1376:305\n     |\n1376 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1376 |     dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:329\n     |\n1377 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:312\n     |\n1377 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |     dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1378:32\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1378:15\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1378 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:58\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:91\n     |\n1381 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:121\n     |\n1381 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:153\n     |\n1381 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 24 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:326\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:309\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:333\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:316\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1375:323\n     |\n1375 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1375:306\n     |\n1375 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1375 |     nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1376:322\n     |\n1376 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1376:305\n     |\n1376 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1376 |     dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:329\n     |\n1377 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:312\n     |\n1377 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |     dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1378:32\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1378:15\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1378 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:58\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:91\n     |\n1381 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:121\n     |\n1381 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:153\n     |\n1381 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1385:5\n     |\n1385 |     assert_eq!(exec.ro.match_type, MatchType::DfaSuffix);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0061, E0369, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 25 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:326\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:309\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:333\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:316\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1375:323\n     |\n1375 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1375:306\n     |\n1375 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1375 |     nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1376:322\n     |\n1376 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1376:305\n     |\n1376 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1376 |     dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:329\n     |\n1377 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:312\n     |\n1377 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |     dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1378:32\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1378:15\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1378 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:58\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:91\n     |\n1381 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:121\n     |\n1381 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:153\n     |\n1381 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 24 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:327\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:310\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:326\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:309\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:333\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:316\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1375:323\n     |\n1375 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1375:306\n     |\n1375 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1375 |     nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: false, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1376:322\n     |\n1376 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1376:305\n     |\n1376 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1376 |     dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: false, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:329\n     |\n1377 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:312\n     |\n1377 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |     dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: true, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1378:32\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1378:15\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1378 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:58\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:91\n     |\n1381 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:121\n     |\n1381 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1381:153\n     |\n1381 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1381 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 24 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![String::from(\"test\")],",
                "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::DfaSuffix,",
                "    });",
                "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                "",
                "    let text: &[u8] = b\"this is a test string\";",
                "    let start = 10;",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"test\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let text: &[u8] = b\"this is a test string\";",
                  "    let start = 10;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert!(result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![String::from(\"test\")],",
                  "        nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache };",
                  "",
                  "    let text: &[u8] = b\"this is a test string\";",
                  "    let start = 10;",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"test\")],",
                  "    nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaSuffix,",
                  "    });",
                  "    let text: &[u8] = b\"this is a test string\";",
                  "    let start = 10;",
                  "    let result = exec.is_match_at(text, start);",
                  "    assert!(result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1360:330\n     |\n1360 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1360:313\n     |\n1360 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1360 |         nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1361:329\n     |\n1361 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1361:312\n     |\n1361 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1361 |         dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1362:335\n     |\n1362 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1362:318\n     |\n1362 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1362 |         dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1363:36\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1363:19\n     |\n1363 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1363 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:58\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new()...\n     |                                                          ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(/* &prog::Program */), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                            ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:91\n     |\n1366 | ...kevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                   ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(/* &prog::Program */), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:121\n     |\n1366 | ...ck: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(/* &prog::Program */), dfa_reverse: dfa::Cache::new() });\n     |                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1366:153\n     |\n1366 | ...: dfa::Cache::new(), dfa_reverse: dfa::Cache::new() });\n     |                                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1366 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::new(), backtrack: backtrack::Cache::new(), dfa: dfa::Cache::new(), dfa_reverse: dfa::Cache::new(/* &prog::Program */) });\n     |                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1375:326\n     |\n1375 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1375:309\n     |\n1375 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1375 |     nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1376:325\n     |\n1376 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1376:308\n     |\n1376 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1376 |     dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:331\n     |\n1377 | ...e_word_boundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                                                       ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:314\n     |\n1377 | ...oundary: false, prefixes: LiteralSearcher::new(), dfa_size_limit: 10 },\n     |                              ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |     dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: false, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */), dfa_size_limit: 10 },\n     |                                                                                                                                                                                                                                                                                                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1378:32\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1378:15\n     |\n1378 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1378 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 20 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaAnchoredReverse is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaAnchoredReverse is true\n",
        "// constraint: text[start..] is \n",
        "// constraint: dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache,\n                    true,\n                    &text[start..],\n                    text.len(),\n                ) matches dfa::Result::Quit is true\n"
      ],
      "input_infer": "text length: 1 to 1048576, start: 0 to text.length - 1, self.ro.match_type: MatchType::DfaAnchoredReverse\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: Vec<u8> = vec![b'a'];",
                "    let start: usize = 0;",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &Arc::new(ExecReadOnly {",
                "            res: vec![String::from(\"a\")],",
                "            nfa: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: false,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            dfa: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: false,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            dfa_reverse: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: true,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            suffixes: LiteralSearcher::default(),",
                "            match_type,",
                "        }),",
                "        cache: &RefCell::new(ProgramCacheInner {",
                "            pikevm: pikevm::Cache::default(),",
                "            backtrack: backtrack::Cache::default(),",
                "            dfa: dfa::Cache::default(),",
                "            dfa_reverse: dfa::Cache::default(),",
                "        }),",
                "    };",
                "",
                "    exec_no_sync.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"a\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_reverse: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    ..Default::default()",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner::default()),",
                  "    };",
                  "    assert!(exec_no_sync.is_anchor_end_match(&text));"
                ],
                [
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"a\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_reverse: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    ..Default::default()",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner::default()),",
                  "    };",
                  "    assert!(matches!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse));"
                ],
                [
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"a\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_reverse: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    ..Default::default()",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner::default()),",
                  "    };",
                  "    assert!(dfa::Fsm::reverse(&exec_no_sync.ro.dfa_reverse, exec_no_sync.cache, true, &text[start..], text.len()).matches(dfa::Result::Quit));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"a\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"a\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_reverse: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    ..Default::default()",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner::default()),",
                  "    };",
                  "    assert!(exec_no_sync.is_anchor_end_match(&text));",
                  "}"
                ],
                [
                  "{",
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"a\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"a\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_reverse: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    ..Default::default()",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner::default()),",
                  "    };",
                  "    assert!(matches!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse));",
                  "}"
                ],
                [
                  "{",
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"a\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let text: Vec<u8> = vec![b'a'];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"a\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    ..Default::default()",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_reverse: true,",
                  "    ..Default::default()",
                  "    },",
                  "    match_type,",
                  "    ..Default::default()",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner::default()),",
                  "    };",
                  "    assert!(dfa::Fsm::reverse(&exec_no_sync.ro.dfa_reverse, exec_no_sync.cache, true, &text[start..], text.len()).matches(dfa::Result::Quit));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `exec::ExecReadOnly: Default` is not satisfied\n    --> src/exec.rs:1443:7\n     |\n1443 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `exec::ExecReadOnly`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1445:45\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1445 |     cache: &RefCell::new(ProgramCacheInner::default()),\n     |                                             ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `exec::ExecReadOnly: Default` is not satisfied\n    --> src/exec.rs:1443:7\n     |\n1443 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `exec::ExecReadOnly`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1445:45\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1445 |     cache: &RefCell::new(ProgramCacheInner::default()),\n     |                                             ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1436:7\n     |\n1436 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1440:7\n     |\n1440 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `exec::ExecReadOnly: Default` is not satisfied\n    --> src/exec.rs:1443:7\n     |\n1443 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `exec::ExecReadOnly`\n\nerror[E0599]: no function or associated item named `default` found for struct `exec::ProgramCacheInner` in the current scope\n    --> src/exec.rs:1445:45\n     |\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `default` not found for this struct\n...\n1445 |     cache: &RefCell::new(ProgramCacheInner::default()),\n     |                                             ^^^^^^^ function or associated item not found in `ProgramCacheInner`\n     |\nnote: if you're trying to build a new `exec::ProgramCacheInner`, consider using `exec::ProgramCacheInner::new` which returns `exec::ProgramCacheInner`\n    --> src/exec.rs:1283:5\n     |\n1283 |     fn new(ro: &ExecReadOnly) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `matches` found for enum `dfa::Result` in the current scope\n    --> src/exec.rs:1447:115\n     |\n1447 | ...ync.cache, true, &text[start..], text.len()).matches(dfa::Result::Quit));\n     |                                                 ^^^^^^^ method not found in `Result<usize>`\n     |\n    ::: src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ------------------ method `matches` not found for this enum\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 13 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: Vec<u8> = vec![b'a'; 1048576];",
                "    let start: usize = 0;",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &Arc::new(ExecReadOnly {",
                "            res: vec![String::from(\"a\")],",
                "            nfa: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: false,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            dfa: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: false,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            dfa_reverse: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: true,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            suffixes: LiteralSearcher::default(),",
                "            match_type,",
                "        }),",
                "        cache: &RefCell::new(ProgramCacheInner {",
                "            pikevm: pikevm::Cache::default(),",
                "            backtrack: backtrack::Cache::default(),",
                "            dfa: dfa::Cache::default(),",
                "            dfa_reverse: dfa::Cache::default(),",
                "        }),",
                "    };",
                "",
                "    exec_no_sync.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    assert_eq!(exec_no_sync.ro.match_type, match_type);"
                ],
                [
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    assert!(exec_no_sync.is_anchor_end_match(&text));"
                ],
                [
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let result = dfa::Fsm::reverse(",
                  "    &exec_no_sync.ro.dfa_reverse,",
                  "    exec_no_sync.cache,",
                  "    true,",
                  "    &text[start..],",
                  "    text.len(),",
                  "    );",
                  "    assert!(matches!(result, dfa::Result::Quit));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: Vec<u8> = vec![b'a'; 1048576];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"a\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    assert_eq!(exec_no_sync.ro.match_type, match_type);",
                  "}"
                ],
                [
                  "{",
                  "    let text: Vec<u8> = vec![b'a'; 1048576];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"a\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    assert!(exec_no_sync.is_anchor_end_match(&text));",
                  "}"
                ],
                [
                  "{",
                  "    let text: Vec<u8> = vec![b'a'; 1048576];",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"a\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let result = dfa::Fsm::reverse(",
                  "    &exec_no_sync.ro.dfa_reverse,",
                  "    exec_no_sync.cache,",
                  "    true,",
                  "    &text[start..],",
                  "    text.len(),",
                  "    );",
                  "    assert!(matches!(result, dfa::Result::Quit));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1429:5\n     |\n1429 |     assert_eq!(exec_no_sync.ro.match_type, match_type);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 9 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: Vec<u8> = b\"abcde\".to_vec();",
                "    let start: usize = 0;",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &Arc::new(ExecReadOnly {",
                "            res: vec![String::from(\"abc\")],",
                "            nfa: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: false,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            dfa: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: false,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            dfa_reverse: Program {",
                "                insts: vec![],",
                "                matches: vec![],",
                "                captures: vec![],",
                "                capture_name_idx: Arc::new(HashMap::new()),",
                "                start: 0,",
                "                byte_classes: vec![],",
                "                only_utf8: true,",
                "                is_bytes: false,",
                "                is_dfa: true,",
                "                is_reverse: true,",
                "                is_anchored_start: true,",
                "                is_anchored_end: true,",
                "                has_unicode_word_boundary: false,",
                "                prefixes: LiteralSearcher::default(),",
                "                dfa_size_limit: 0,",
                "            },",
                "            suffixes: LiteralSearcher::default(),",
                "            match_type,",
                "        }),",
                "        cache: &RefCell::new(ProgramCacheInner {",
                "            pikevm: pikevm::Cache::default(),",
                "            backtrack: backtrack::Cache::default(),",
                "            dfa: dfa::Cache::default(),",
                "            dfa_reverse: dfa::Cache::default(),",
                "        }),",
                "    };",
                "",
                "    exec_no_sync.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"abc\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    .. // other fields",
                  "    }),",
                  "    };",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    assert!(exec_no_sync.is_anchor_end_match(&text));"
                ],
                [
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"abc\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    .. // other fields",
                  "    }),",
                  "    };",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);"
                ],
                [
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"abc\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    .. // other fields",
                  "    }),",
                  "    };",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    assert!(dfa::Fsm::reverse("
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"abc\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"abc\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    .. // other fields",
                  "    }),",
                  "    };",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    assert!(exec_no_sync.is_anchor_end_match(&text));",
                  "}"
                ],
                [
                  "{",
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"abc\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"abc\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    .. // other fields",
                  "    }),",
                  "    };",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);",
                  "}"
                ],
                [
                  "{",
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(ExecReadOnly {",
                  "            res: vec![String::from(\"abc\")],",
                  "            nfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: false,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            dfa_reverse: Program {",
                  "                insts: vec![],",
                  "                matches: vec![],",
                  "                captures: vec![],",
                  "                capture_name_idx: Arc::new(HashMap::new()),",
                  "                start: 0,",
                  "                byte_classes: vec![],",
                  "                only_utf8: true,",
                  "                is_bytes: false,",
                  "                is_dfa: true,",
                  "                is_reverse: true,",
                  "                is_anchored_start: true,",
                  "                is_anchored_end: true,",
                  "                has_unicode_word_boundary: false,",
                  "                prefixes: LiteralSearcher::default(),",
                  "                dfa_size_limit: 0,",
                  "            },",
                  "            suffixes: LiteralSearcher::default(),",
                  "            match_type,",
                  "        }),",
                  "        cache: &RefCell::new(ProgramCacheInner {",
                  "            pikevm: pikevm::Cache::default(),",
                  "            backtrack: backtrack::Cache::default(),",
                  "            dfa: dfa::Cache::default(),",
                  "            dfa_reverse: dfa::Cache::default(),",
                  "        }),",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    let text: Vec<u8> = b\"abcde\".to_vec();",
                  "    let start: usize = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(ExecReadOnly {",
                  "    res: vec![String::from(\"abc\")],",
                  "    nfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    dfa_reverse: Program {",
                  "    is_anchored_end: true,",
                  "    .. // other fields",
                  "    },",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type,",
                  "    }),",
                  "    cache: &RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    .. // other fields",
                  "    }),",
                  "    };",
                  "    exec_no_sync.is_match_at(&text, start);",
                  "    assert!(dfa::Fsm::reverse(",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1436:7\n     |\n1436 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1436 |     ../* expr */ // other fields\n     |       ++++++++++\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1440:7\n     |\n1440 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1440 |     ../* expr */ // other fields\n     |       ++++++++++\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1444:7\n     |\n1444 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1444 |     ../* expr */ // other fields\n     |       ++++++++++\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1451:7\n     |\n1451 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1451 |     ../* expr */ // other fields\n     |       ++++++++++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1446:32\n     |\n1446 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1450:30\n     |\n1450 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0599, E0797.\nFor more information about an error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 14 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1436:7\n     |\n1436 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1436 |     ../* expr */ // other fields\n     |       ++++++++++\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1440:7\n     |\n1440 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1440 |     ../* expr */ // other fields\n     |       ++++++++++\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1444:7\n     |\n1444 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1444 |     ../* expr */ // other fields\n     |       ++++++++++\n\nerror[E0797]: base expression required after `..`\n    --> src/exec.rs:1451:7\n     |\n1451 |     .. // other fields\n     |       ^\n     |\nhelp: add a base expression here\n     |\n1451 |     ../* expr */ // other fields\n     |       ++++++++++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1379:44\n     |\n1379 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1396:44\n     |\n1396 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1413:44\n     |\n1413 |                 prefixes: LiteralSearcher::default(),\n     |                                            ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1416:40\n     |\n1416 |             suffixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1420:36\n     |\n1420 |             pikevm: pikevm::Cache::default(),\n     |                                    ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1421:42\n     |\n1421 |             backtrack: backtrack::Cache::default(),\n     |                                          ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1422:30\n     |\n1422 |             dfa: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1423:38\n     |\n1423 |             dfa_reverse: dfa::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1446:32\n     |\n1446 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1450:30\n     |\n1450 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1455:5\n     |\n1455 |     assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0369, E0599, E0797.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 15 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: mismatched closing delimiter: `}`\n    --> src/exec.rs:1455:30\n     |\n1357 | {\n     | - closing delimiter possibly meant for this\n...\n1455 |     assert!(dfa::Fsm::reverse(\n     |                              ^ unclosed delimiter\n1456 | }\n     | ^ mismatched closing delimiter\n\nerror: could not compile `regex` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaAnchoredReverse is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaAnchoredReverse is true\n",
        "// constraint: text[start..] is \n",
        "// constraint: dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache,\n                    true,\n                    &text[start..],\n                    text.len(),\n                ) matches dfa::Result::NoMatch(_) is true\n",
        "// constraint: dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache,\n                    true,\n                    &text[start..],\n                    text.len(),\n                ) matches dfa::Result::NoMatch(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "text: [0 to 255], start: [0 to length of text - 1]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"test\".to_string()],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![0; 256],",
                "            only_utf8: false,",
                "            is_bytes: false,",
                "            is_dfa: true,",
                "            is_reverse: true,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 10,",
                "        },",
                "        dfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![0; 256],",
                "            only_utf8: false,",
                "            is_bytes: false,",
                "            is_dfa: true,",
                "            is_reverse: true,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 10,",
                "        },",
                "        dfa_reverse: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![0; 256],",
                "            only_utf8: false,",
                "            is_bytes: false,",
                "            is_dfa: true,",
                "            is_reverse: true,",
                "            is_anchored_start: false,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 10,",
                "        },",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaAnchoredReverse,",
                "    });",
                "    ",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "    ",
                "    let exec = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "    ",
                "    let text: &[u8] = b\"test string\";",
                "    let start: usize = 0;",
                "    ",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".to_string()],",
                  "    ... // initialization omitted for brevity",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"test string\";",
                  "    let start: usize = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"test\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![0; 256],",
                  "            only_utf8: false,",
                  "            is_bytes: false,",
                  "            is_dfa: true,",
                  "            is_reverse: true,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 10,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![0; 256],",
                  "            only_utf8: false,",
                  "            is_bytes: false,",
                  "            is_dfa: true,",
                  "            is_reverse: true,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 10,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![0; 256],",
                  "            only_utf8: false,",
                  "            is_bytes: false,",
                  "            is_dfa: true,",
                  "            is_reverse: true,",
                  "            is_anchored_start: false,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 10,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaAnchoredReverse,",
                  "    });",
                  "    ",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    ",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "    ",
                  "    let text: &[u8] = b\"test string\";",
                  "    let start: usize = 0;",
                  "    ",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![\"test\".to_string()],",
                  "    ... // initialization omitted for brevity",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    let text: &[u8] = b\"test string\";",
                  "    let start: usize = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: expected identifier, found `...`\n    --> src/exec.rs:1433:5\n     |\n1431 |     let ro = Arc::new(ExecReadOnly {\n     |                       ------------ while parsing this struct\n1432 |     res: vec![\"test\".to_string()],\n1433 |     ... // initialization omitted for brevity\n     |     ^^^ expected identifier\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `dfa`, `dfa_reverse`, `match_type` and 2 other fields in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1431:23\n     |\n1431 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `dfa_reverse`, `match_type` and 2 other fields\n\nSome errors have detailed explanations: E0063, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 10 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"pattern\".to_string()],",
                "        nfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![0; 256],",
                "            only_utf8: false,",
                "            is_bytes: false,",
                "            is_dfa: true,",
                "            is_reverse: true,",
                "            is_anchored_start: true,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 10,",
                "        },",
                "        dfa: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![0; 256],",
                "            only_utf8: false,",
                "            is_bytes: false,",
                "            is_dfa: true,",
                "            is_reverse: true,",
                "            is_anchored_start: true,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 10,",
                "        },",
                "        dfa_reverse: Program {",
                "            insts: vec![],",
                "            matches: vec![],",
                "            captures: vec![],",
                "            capture_name_idx: Arc::new(HashMap::new()),",
                "            start: 0,",
                "            byte_classes: vec![0; 256],",
                "            only_utf8: false,",
                "            is_bytes: false,",
                "            is_dfa: true,",
                "            is_reverse: true,",
                "            is_anchored_start: true,",
                "            is_anchored_end: true,",
                "            has_unicode_word_boundary: false,",
                "            prefixes: LiteralSearcher::default(),",
                "            dfa_size_limit: 10,",
                "        },",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::DfaAnchoredReverse,",
                "    });",
                "    ",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "    ",
                "    let exec = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "    ",
                "    let text: &[u8] = b\"uniquepattern\";",
                "    let start: usize = 0;",
                "    ",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let ro = Arc::new(ExecReadOnly { res: vec![\"pattern\".to_string()], nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![0; 256], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![0; 256], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![0; 256], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, suffixes: LiteralSearcher::default(), match_type: MatchType::DfaAnchoredReverse, });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::default(), backtrack: backtrack::Cache::default(), dfa: dfa::Cache::default(), dfa_reverse: dfa::Cache::default(), });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache, };",
                  "    let text: &[u8] = b\"uniquepattern\";",
                  "    let start: usize = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"pattern\".to_string()],",
                  "        nfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![0; 256],",
                  "            only_utf8: false,",
                  "            is_bytes: false,",
                  "            is_dfa: true,",
                  "            is_reverse: true,",
                  "            is_anchored_start: true,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 10,",
                  "        },",
                  "        dfa: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![0; 256],",
                  "            only_utf8: false,",
                  "            is_bytes: false,",
                  "            is_dfa: true,",
                  "            is_reverse: true,",
                  "            is_anchored_start: true,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 10,",
                  "        },",
                  "        dfa_reverse: Program {",
                  "            insts: vec![],",
                  "            matches: vec![],",
                  "            captures: vec![],",
                  "            capture_name_idx: Arc::new(HashMap::new()),",
                  "            start: 0,",
                  "            byte_classes: vec![0; 256],",
                  "            only_utf8: false,",
                  "            is_bytes: false,",
                  "            is_dfa: true,",
                  "            is_reverse: true,",
                  "            is_anchored_start: true,",
                  "            is_anchored_end: true,",
                  "            has_unicode_word_boundary: false,",
                  "            prefixes: LiteralSearcher::default(),",
                  "            dfa_size_limit: 10,",
                  "        },",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::DfaAnchoredReverse,",
                  "    });",
                  "    ",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    ",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "    ",
                  "    let text: &[u8] = b\"uniquepattern\";",
                  "    let start: usize = 0;",
                  "    ",
                  "    exec.is_match_at(text, start);",
                  "    let ro = Arc::new(ExecReadOnly { res: vec![\"pattern\".to_string()], nfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![0; 256], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, dfa: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![0; 256], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, dfa_reverse: Program { insts: vec![], matches: vec![], captures: vec![], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![0; 256], only_utf8: false, is_bytes: false, is_dfa: true, is_reverse: true, is_anchored_start: true, is_anchored_end: true, has_unicode_word_boundary: false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, suffixes: LiteralSearcher::default(), match_type: MatchType::DfaAnchoredReverse, });",
                  "    let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::default(), backtrack: backtrack::Cache::default(), dfa: dfa::Cache::default(), dfa_reverse: dfa::Cache::default(), });",
                  "    let exec = ExecNoSync { ro: &ro, cache: &cache, };",
                  "    let text: &[u8] = b\"uniquepattern\";",
                  "    let start: usize = 0;",
                  "    assert_eq!(exec.is_match_at(text, start), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1374:40\n     |\n1374 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1391:40\n     |\n1391 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1408:40\n     |\n1408 |             prefixes: LiteralSearcher::default(),\n     |                                        ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1411:36\n     |\n1411 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1416:32\n     |\n1416 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1417:38\n     |\n1417 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1418:26\n     |\n1418 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1419:34\n     |\n1419 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1431:395\n     |\n1431 | ...false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, dfa: Program { insts: vec![], matches: vec![], captures: vec![], c...\n     |                                      ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1431:752\n     |\n1431 | ...false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, dfa_reverse: Program { insts: vec![], matches: vec![], captures: v...\n     |                                      ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1431:1117\n     |\n1431 | ...false, prefixes: LiteralSearcher::default(), dfa_size_limit: 10, }, suffixes: LiteralSearcher::default(), match_type: MatchType::DfaAn...\n     |                                      ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1431:1178\n     |\n1431 | ...10, }, suffixes: LiteralSearcher::default(), match_type: MatchType::DfaAnchoredReverse, });\n     |                                      ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1432:73\n     |\n1432 |     let cache = RefCell::new(ProgramCacheInner { pikevm: pikevm::Cache::default(), backtrack: backtrack::Cache::default(), dfa: dfa::Cach...\n     |                                                                         ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1432:113\n     |\n1432 | ...efault(), backtrack: backtrack::Cache::default(), dfa: dfa::Cache::default(), dfa_reverse: dfa::Cache::default(), });\n     |                                           ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1432:141\n     |\n1432 | ...:Cache::default(), dfa: dfa::Cache::default(), dfa_reverse: dfa::Cache::default(), });\n     |                                        ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1432:177\n     |\n1432 | ...default(), dfa_reverse: dfa::Cache::default(), });\n     |                                        ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaAnchoredReverse is true\n",
        "// constraint: self.ro.match_type matches MatchType::DfaAnchoredReverse is true\n",
        "// constraint: text[start..] is \n",
        "// constraint: dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache,\n                    true,\n                    &text[start..],\n                    text.len(),\n                ) matches dfa::Result::Match(_) is true\n",
        "// constraint: dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache,\n                    true,\n                    &text[start..],\n                    text.len(),\n                ) matches dfa::Result::Match(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "start: 0, text: [b'a'..=b'z] with length 1 to 100, self.ro.match_type: MatchType::DfaAnchoredReverse true, self.is_anchor_end_match(text): true\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex_string = \"a\";",
                "    let text: &[u8] = b\"a\"; ",
                "    let start = 0;",
                "",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "    let dfa_reverse_program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: true,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 100,",
                "    };",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![regex_string.to_string()],",
                "        nfa: dfa_reverse_program.clone(),",
                "        dfa: dfa_reverse_program.clone(),",
                "        dfa_reverse: dfa_reverse_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type,",
                "    });",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex_string = \"a\";",
                  "    let text: &[u8] = b\"a\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program { is_anchored_end: true };",
                  "    let cache = RefCell::new(ProgramCacheInner { dfa_reverse: dfa::Cache::default() });",
                  "    let ro = Arc::new(ExecReadOnly { match_type, dfa_reverse: dfa_reverse_program });",
                  "    let exec_no_sync = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec_no_sync.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex_string = \"a\";",
                  "    let text: &[u8] = b\"a\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"a\";",
                  "    let text: &[u8] = b\"a\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program { is_anchored_end: true };",
                  "    let cache = RefCell::new(ProgramCacheInner { dfa_reverse: dfa::Cache::default() });",
                  "    let ro = Arc::new(ExecReadOnly { match_type, dfa_reverse: dfa_reverse_program });",
                  "    let exec_no_sync = ExecNoSync { ro: &ro, cache: &cache };",
                  "    assert!(exec_no_sync.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `byte_classes`, `capture_name_idx`, `captures` and 11 other fields in initializer of `prog::Program`\n    --> src/exec.rs:1407:31\n     |\n1407 |     let dfa_reverse_program = Program { is_anchored_end: true };\n     |                               ^^^^^^^ missing `byte_classes`, `capture_name_idx`, `captures` and 11 other fields\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1408:75\n     |\n1408 |     let cache = RefCell::new(ProgramCacheInner { dfa_reverse: dfa::Cache::default() });\n     |                                                                           ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `backtrack`, `dfa` and `pikevm` in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1408:30\n     |\n1408 |     let cache = RefCell::new(ProgramCacheInner { dfa_reverse: dfa::Cache::default() });\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa` and `pikevm`\n\nerror[E0063]: missing fields `dfa`, `nfa`, `res` and 1 other field in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1409:23\n     |\n1409 |     let ro = Arc::new(ExecReadOnly { match_type, dfa_reverse: dfa_reverse_program });\n     |                       ^^^^^^^^^^^^ missing `dfa`, `nfa`, `res` and 1 other field\n\nSome errors have detailed explanations: E0061, E0063, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex_string = \"abc\";",
                "    let text: &[u8] = b\"abc\"; ",
                "    let start = 0;",
                "",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "    let dfa_reverse_program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: true,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 100,",
                "    };",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![regex_string.to_string()],",
                "        nfa: dfa_reverse_program.clone(),",
                "        dfa: dfa_reverse_program.clone(),",
                "        dfa_reverse: dfa_reverse_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type,",
                "    });",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_anchor_end_match(text));"
                ],
                [
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);"
                ],
                [
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(dfa::Fsm::reverse(&exec_no_sync.ro.dfa_reverse, exec_no_sync.cache, true, &text[start..], text.len()).is_match());"
                ],
                [
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));"
                ],
                [
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_anchor_end_match(text));",
                  "}"
                ],
                [
                  "{",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);",
                  "}"
                ],
                [
                  "{",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(dfa::Fsm::reverse(&exec_no_sync.ro.dfa_reverse, exec_no_sync.cache, true, &text[start..], text.len()).is_match());",
                  "}"
                ],
                [
                  "{",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));",
                  "}"
                ],
                [
                  "{",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"abc\";",
                  "    let text: &[u8] = b\"abc\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1425:28\n     |\n1425 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1426:34\n     |\n1426 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1427:22\n     |\n1427 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1428:30\n     |\n1428 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1435:32\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1435:15\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1435 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1425:28\n     |\n1425 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1426:34\n     |\n1426 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1427:22\n     |\n1427 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1428:30\n     |\n1428 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1435:32\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1435:15\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1435 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1442:5\n     |\n1442 |     assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0061, E0369, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 17 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1425:28\n     |\n1425 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1426:34\n     |\n1426 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1427:22\n     |\n1427 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1428:30\n     |\n1428 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1435:32\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1435:15\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1435 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1425:28\n     |\n1425 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1426:34\n     |\n1426 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1427:22\n     |\n1427 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1428:30\n     |\n1428 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1435:32\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1435:15\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1435 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1425:28\n     |\n1425 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1426:34\n     |\n1426 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1427:22\n     |\n1427 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1428:30\n     |\n1428 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1435:32\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1435:15\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1435 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex_string = \"abcd\";",
                "    let text: &[u8] = b\"abcd\"; ",
                "    let start = 0;",
                "",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "    let dfa_reverse_program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: true,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 100,",
                "    };",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![regex_string.to_string()],",
                "        nfa: dfa_reverse_program.clone(),",
                "        dfa: dfa_reverse_program.clone(),",
                "        dfa_reverse: dfa_reverse_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type,",
                "    });",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex_string = \"abcd\";",
                  "    let text: &[u8] = b\"abcd\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    let result = exec_no_sync.is_match_at(text, start);",
                  "    assert_eq!(result, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex_string = \"abcd\";",
                  "    let text: &[u8] = b\"abcd\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"abcd\";",
                  "    let text: &[u8] = b\"abcd\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    let result = exec_no_sync.is_match_at(text, start);",
                  "    assert_eq!(result, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1425:28\n     |\n1425 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1426:34\n     |\n1426 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1427:22\n     |\n1427 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1428:30\n     |\n1428 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1435:32\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1435:15\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1435 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex_string = \"a\";",
                "    let text: &[u8] = b\"abcde\"; ",
                "    let start = 0;",
                "",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "    let dfa_reverse_program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: true,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 100,",
                "    };",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![regex_string.to_string()],",
                "        nfa: dfa_reverse_program.clone(),",
                "        dfa: dfa_reverse_program.clone(),",
                "        dfa_reverse: dfa_reverse_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type,",
                "    });",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex_string = \"a\";",
                  "    let text: &[u8] = b\"abcde\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    assert!(exec_no_sync.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex_string = \"a\";",
                  "    let text: &[u8] = b\"abcde\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"a\";",
                  "    let text: &[u8] = b\"abcde\";",
                  "    let start = 0;",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: true,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 100,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::default(),",
                  "    backtrack: backtrack::Cache::default(),",
                  "    dfa: dfa::Cache::default(),",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    res: vec![regex_string.to_string()],",
                  "    nfa: dfa_reverse_program.clone(),",
                  "    dfa: dfa_reverse_program.clone(),",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    assert!(exec_no_sync.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1425:28\n     |\n1425 |     pikevm: pikevm::Cache::default(),\n     |                            ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1426:34\n     |\n1426 |     backtrack: backtrack::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1427:22\n     |\n1427 |     dfa: dfa::Cache::default(),\n     |                      ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1428:30\n     |\n1428 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1435:32\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1435:15\n     |\n1435 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1435 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let regex_string = \"xyz\";",
                "    let text: &[u8] = b\"xyzxyz\"; ",
                "    let start = 0;",
                "",
                "    let match_type = MatchType::DfaAnchoredReverse;",
                "    let dfa_reverse_program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: true,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 100,",
                "    };",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![regex_string.to_string()],",
                "        nfa: dfa_reverse_program.clone(),",
                "        dfa: dfa_reverse_program.clone(),",
                "        dfa_reverse: dfa_reverse_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type,",
                "    });",
                "",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_anchor_end_match(text));"
                ],
                [
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);"
                ],
                [
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(dfa::Fsm::reverse(&exec_no_sync.ro.dfa_reverse, exec_no_sync.cache, true, &text[start..], text.len()).is_match());"
                ],
                [
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let regex_string = \"xyz\";",
                  "    let text: &[u8] = b\"xyzxyz\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_anchor_end_match(text));",
                  "}"
                ],
                [
                  "{",
                  "    let regex_string = \"xyz\";",
                  "    let text: &[u8] = b\"xyzxyz\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);",
                  "}"
                ],
                [
                  "{",
                  "    let regex_string = \"xyz\";",
                  "    let text: &[u8] = b\"xyzxyz\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(dfa::Fsm::reverse(&exec_no_sync.ro.dfa_reverse, exec_no_sync.cache, true, &text[start..], text.len()).is_match());",
                  "}"
                ],
                [
                  "{",
                  "    let regex_string = \"xyz\";",
                  "    let text: &[u8] = b\"xyzxyz\"; ",
                  "    let start = 0;",
                  "",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: true,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 100,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![regex_string.to_string()],",
                  "        nfa: dfa_reverse_program.clone(),",
                  "        dfa: dfa_reverse_program.clone(),",
                  "        dfa_reverse: dfa_reverse_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type,",
                  "    });",
                  "",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let regex_string = \"xyz\";",
                  "    let match_type = MatchType::DfaAnchoredReverse;",
                  "    let dfa_reverse_program = Program {",
                  "    is_anchored_end: true,",
                  "    };",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "    dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "    match_type,",
                  "    dfa_reverse: dfa_reverse_program,",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &ro,",
                  "    cache: &cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `byte_classes`, `capture_name_idx`, `captures` and 11 other fields in initializer of `prog::Program`\n    --> src/exec.rs:1405:31\n     |\n1405 |     let dfa_reverse_program = Program {\n     |                               ^^^^^^^ missing `byte_classes`, `capture_name_idx`, `captures` and 11 other fields\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1409:30\n     |\n1409 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `backtrack`, `dfa` and `pikevm` in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1408:30\n     |\n1408 |     let cache = RefCell::new(ProgramCacheInner {\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa` and `pikevm`\n\nerror[E0063]: missing fields `dfa`, `nfa`, `res` and 1 other field in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1411:23\n     |\n1411 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `nfa`, `res` and 1 other field\n\nSome errors have detailed explanations: E0061, E0063, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `byte_classes`, `capture_name_idx`, `captures` and 11 other fields in initializer of `prog::Program`\n    --> src/exec.rs:1405:31\n     |\n1405 |     let dfa_reverse_program = Program {\n     |                               ^^^^^^^ missing `byte_classes`, `capture_name_idx`, `captures` and 11 other fields\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1409:30\n     |\n1409 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `backtrack`, `dfa` and `pikevm` in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1408:30\n     |\n1408 |     let cache = RefCell::new(ProgramCacheInner {\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa` and `pikevm`\n\nerror[E0063]: missing fields `dfa`, `nfa`, `res` and 1 other field in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1411:23\n     |\n1411 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `nfa`, `res` and 1 other field\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1419:5\n     |\n1419 |     assert_eq!(exec_no_sync.ro.match_type, MatchType::DfaAnchoredReverse);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0061, E0063, E0369, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 13 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `byte_classes`, `capture_name_idx`, `captures` and 11 other fields in initializer of `prog::Program`\n    --> src/exec.rs:1405:31\n     |\n1405 |     let dfa_reverse_program = Program {\n     |                               ^^^^^^^ missing `byte_classes`, `capture_name_idx`, `captures` and 11 other fields\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1409:30\n     |\n1409 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `backtrack`, `dfa` and `pikevm` in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1408:30\n     |\n1408 |     let cache = RefCell::new(ProgramCacheInner {\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa` and `pikevm`\n\nerror[E0063]: missing fields `dfa`, `nfa`, `res` and 1 other field in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1411:23\n     |\n1411 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `nfa`, `res` and 1 other field\n\nSome errors have detailed explanations: E0061, E0063, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1377:36\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1377:19\n     |\n1377 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1377 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1382:32\n     |\n1382 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1383:38\n     |\n1383 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1384:26\n     |\n1384 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1385:34\n     |\n1385 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1393:19\n     |\n1393 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1393 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0063]: missing fields `byte_classes`, `capture_name_idx`, `captures` and 11 other fields in initializer of `prog::Program`\n    --> src/exec.rs:1405:31\n     |\n1405 |     let dfa_reverse_program = Program {\n     |                               ^^^^^^^ missing `byte_classes`, `capture_name_idx`, `captures` and 11 other fields\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1409:30\n     |\n1409 |     dfa_reverse: dfa::Cache::default(),\n     |                              ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0063]: missing fields `backtrack`, `dfa` and `pikevm` in initializer of `exec::ProgramCacheInner`\n    --> src/exec.rs:1408:30\n     |\n1408 |     let cache = RefCell::new(ProgramCacheInner {\n     |                              ^^^^^^^^^^^^^^^^^ missing `backtrack`, `dfa` and `pikevm`\n\nerror[E0063]: missing fields `dfa`, `nfa`, `res` and 1 other field in initializer of `exec::ExecReadOnly`\n    --> src/exec.rs:1411:23\n     |\n1411 |     let ro = Arc::new(ExecReadOnly {\n     |                       ^^^^^^^^^^^^ missing `dfa`, `nfa`, `res` and 1 other field\n\nSome errors have detailed explanations: E0061, E0063, E0599, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::Dfa is true\n",
        "// constraint: self.ro.match_type matches MatchType::Dfa or MatchType::DfaMany is true\n",
        "// constraint: self.shortest_dfa(text, start) matches dfa::Result::Quit is true\n"
      ],
      "input_infer": "text: [0-255], start: 0 to length of text - 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let res = vec![\"regex_pattern\".to_string()];",
                "    let nfa_program = Program {",
                "        insts: vec![/* appropriate instructions */],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "    let dfa_program = nfa_program.clone();",
                "    let exec_read_only = ExecReadOnly {",
                "        res,",
                "        nfa: nfa_program,",
                "        dfa: dfa_program,",
                "        dfa_reverse: dfa_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::Dfa,",
                "    };",
                "    ",
                "    let program_cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    });",
                "    ",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &Arc::new(exec_read_only),",
                "        cache: &program_cache,",
                "    };",
                "",
                "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                "    let start = 0; // Start index",
                "    ",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "    insts: vec![/* appropriate instructions */],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res,",
                  "    nfa: nfa_program,",
                  "    dfa: dfa_program,",
                  "    dfa_reverse: dfa_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Dfa,",
                  "    };",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &program_cache,",
                  "    };",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let result = exec_no_sync.is_match_at(text, start);",
                  "    assert!(result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "        insts: vec![/* appropriate instructions */],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res,",
                  "        nfa: nfa_program,",
                  "        dfa: dfa_program,",
                  "        dfa_reverse: dfa_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Dfa,",
                  "    };",
                  "    ",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    ",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                  "    let start = 0; // Start index",
                  "    ",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "    insts: vec![/* appropriate instructions */],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: true,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res,",
                  "    nfa: nfa_program,",
                  "    dfa: dfa_program,",
                  "    dfa_reverse: dfa_program,",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Dfa,",
                  "    };",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &program_cache,",
                  "    };",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let result = exec_no_sync.is_match_at(text, start);",
                  "    assert!(result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1373:36\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1373:19\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1373 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1382:36\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1382:19\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1382 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1387:17\n     |\n1387 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1387 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1388:20\n     |\n1388 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1388 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1389:14\n     |\n1389 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1389 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1390:22\n     |\n1390 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1390 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1417:32\n     |\n1417 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1417:15\n     |\n1417 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1417 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1426:32\n     |\n1426 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1426:15\n     |\n1426 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1426 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1430:13\n     |\n1430 |     pikevm: pikevm::Cache::new(),\n     |             ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1430 |     pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1431:16\n     |\n1431 |     backtrack: backtrack::Cache::new(),\n     |                ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1431 |     backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1432:10\n     |\n1432 |     dfa: dfa::Cache::new(),\n     |          ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1432 |     dfa: dfa::Cache::new(/* &prog::Program */),\n     |                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1433:18\n     |\n1433 |     dfa_reverse: dfa::Cache::new(),\n     |                  ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1433 |     dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let res = vec![\"regex_pattern\".to_string()];",
                "    let nfa_program = Program {",
                "        insts: vec![/* appropriate instructions */],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "    let dfa_program = nfa_program.clone();",
                "    let exec_read_only = ExecReadOnly {",
                "        res,",
                "        nfa: nfa_program,",
                "        dfa: dfa_program,",
                "        dfa_reverse: dfa_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::DfaMany,",
                "    };",
                "    ",
                "    let program_cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    });",
                "    ",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &Arc::new(exec_read_only),",
                "        cache: &program_cache,",
                "    };",
                "",
                "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                "    let start = 0; // Start index",
                "    ",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "    is_anchored_end: true,",
                  "    is_dfa: true,",
                  "    ..Default::default()",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "    match_type: MatchType::DfaMany,",
                  "    nfa: nfa_program,",
                  "    dfa: dfa_program,",
                  "    dfa_reverse: dfa_program,",
                  "    ..Default::default()",
                  "    };",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    dfa: dfa::Cache::new(),",
                  "    ..Default::default()",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &program_cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "        insts: vec![/* appropriate instructions */],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res,",
                  "        nfa: nfa_program,",
                  "        dfa: dfa_program,",
                  "        dfa_reverse: dfa_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaMany,",
                  "    };",
                  "    ",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    ",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                  "    let start = 0; // Start index",
                  "    ",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "    is_anchored_end: true,",
                  "    is_dfa: true,",
                  "    ..Default::default()",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "    match_type: MatchType::DfaMany,",
                  "    nfa: nfa_program,",
                  "    dfa: dfa_program,",
                  "    dfa_reverse: dfa_program,",
                  "    ..Default::default()",
                  "    };",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    dfa: dfa::Cache::new(),",
                  "    ..Default::default()",
                  "    });",
                  "    let exec_no_sync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &program_cache,",
                  "    };",
                  "    assert!(exec_no_sync.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1373:36\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1373:19\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1373 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1382:36\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1382:19\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1382 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1387:17\n     |\n1387 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1387 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1388:20\n     |\n1388 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1388 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1389:14\n     |\n1389 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1389 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1390:22\n     |\n1390 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1390 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `prog::Program: Default` is not satisfied\n    --> src/exec.rs:1406:7\n     |\n1406 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `prog::Program`\n\nerror[E0277]: the trait bound `exec::ExecReadOnly: Default` is not satisfied\n    --> src/exec.rs:1414:7\n     |\n1414 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `exec::ExecReadOnly`\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1417:10\n     |\n1417 |     dfa: dfa::Cache::new(),\n     |          ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1417 |     dfa: dfa::Cache::new(/* &prog::Program */),\n     |                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the trait bound `exec::ProgramCacheInner: Default` is not satisfied\n    --> src/exec.rs:1418:7\n     |\n1418 |     ..Default::default()\n     |       ^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `exec::ProgramCacheInner`\n\nSome errors have detailed explanations: E0061, E0277, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let res = vec![\"regex_pattern\".to_string()];",
                "    let nfa_program = Program {",
                "        insts: vec![/* appropriate instructions */],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: true,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "    let dfa_program = nfa_program.clone();",
                "    let exec_read_only = ExecReadOnly {",
                "        res,",
                "        nfa: nfa_program,",
                "        dfa: dfa_program,",
                "        dfa_reverse: dfa_program,",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::Dfa,",
                "    };",
                "    ",
                "    let program_cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    });",
                "    ",
                "    let exec_no_sync = ExecNoSync {",
                "        ro: &Arc::new(exec_read_only),",
                "        cache: &program_cache,",
                "    };",
                "",
                "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                "    let start = 0; // Start index",
                "    ",
                "    exec_no_sync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    assert!(match_result == false);"
                ],
                [
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_type = exec_no_sync.ro.match_type;",
                  "    assert!(match_type == MatchType::Dfa);"
                ],
                [
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_type = exec_no_sync.ro.match_type;",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let quit_result = exec_no_sync.shortest_dfa(text, start);",
                  "    assert!(quit_result == dfa::Result::Quit);"
                ],
                [
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_type = exec_no_sync.ro.match_type;",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let quit_result = exec_no_sync.shortest_dfa(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let is_anchor_end_match_result = exec_no_sync.is_anchor_end_match(text);",
                  "    assert!(is_anchor_end_match_result == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "        insts: vec![/* appropriate instructions */],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res,",
                  "        nfa: nfa_program,",
                  "        dfa: dfa_program,",
                  "        dfa_reverse: dfa_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Dfa,",
                  "    };",
                  "    ",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    ",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                  "    let start = 0; // Start index",
                  "    ",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    assert!(match_result == false);",
                  "}"
                ],
                [
                  "{",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "        insts: vec![/* appropriate instructions */],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res,",
                  "        nfa: nfa_program,",
                  "        dfa: dfa_program,",
                  "        dfa_reverse: dfa_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Dfa,",
                  "    };",
                  "    ",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    ",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                  "    let start = 0; // Start index",
                  "    ",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_type = exec_no_sync.ro.match_type;",
                  "    assert!(match_type == MatchType::Dfa);",
                  "}"
                ],
                [
                  "{",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "        insts: vec![/* appropriate instructions */],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res,",
                  "        nfa: nfa_program,",
                  "        dfa: dfa_program,",
                  "        dfa_reverse: dfa_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Dfa,",
                  "    };",
                  "    ",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    ",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                  "    let start = 0; // Start index",
                  "    ",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_type = exec_no_sync.ro.match_type;",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let quit_result = exec_no_sync.shortest_dfa(text, start);",
                  "    assert!(quit_result == dfa::Result::Quit);",
                  "}"
                ],
                [
                  "{",
                  "    let res = vec![\"regex_pattern\".to_string()];",
                  "    let nfa_program = Program {",
                  "        insts: vec![/* appropriate instructions */],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: true,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "    let dfa_program = nfa_program.clone();",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res,",
                  "        nfa: nfa_program,",
                  "        dfa: dfa_program,",
                  "        dfa_reverse: dfa_program,",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Dfa,",
                  "    };",
                  "    ",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    ",
                  "    let exec_no_sync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8]; // Sample text",
                  "    let start = 0; // Start index",
                  "    ",
                  "    exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_result = exec_no_sync.is_match_at(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let match_type = exec_no_sync.ro.match_type;",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let quit_result = exec_no_sync.shortest_dfa(text, start);",
                  "    let text: &[u8] = &[0u8, 1u8, 2u8];",
                  "    let start = 0;",
                  "    let is_anchor_end_match_result = exec_no_sync.is_anchor_end_match(text);",
                  "    assert!(is_anchor_end_match_result == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1373:36\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1373:19\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1373 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1382:36\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1382:19\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1382 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1387:17\n     |\n1387 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1387 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1388:20\n     |\n1388 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1388 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1389:14\n     |\n1389 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1389 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1390:22\n     |\n1390 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1390 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1373:36\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1373:19\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1373 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1382:36\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1382:19\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1382 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1387:17\n     |\n1387 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1387 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1388:20\n     |\n1388 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1388 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1389:14\n     |\n1389 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1389 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1390:22\n     |\n1390 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1390 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1408:24\n     |\n1408 |     assert!(match_type == MatchType::Dfa);\n     |             ---------- ^^ -------------- exec::MatchType\n     |             |\n     |             exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0061, E0369, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 9 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1373:36\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1373:19\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1373 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1382:36\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1382:19\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1382 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1387:17\n     |\n1387 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1387 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1388:20\n     |\n1388 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1388 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1389:14\n     |\n1389 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1389 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1390:22\n     |\n1390 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1390 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `dfa::Result<usize>`\n    --> src/exec.rs:1411:25\n     |\n1411 |     assert!(quit_result == dfa::Result::Quit);\n     |             ----------- ^^ ----------------- dfa::Result<_>\n     |             |\n     |             dfa::Result<usize>\n     |\nnote: an implementation of `PartialEq<dfa::Result<_>>` might be missing for `dfa::Result<usize>`\n    --> src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<dfa::Result<_>>`\nhelp: consider annotating `dfa::Result<usize>` with `#[derive(PartialEq)]`\n    -->  src/dfa.rs:218:1\n     |\n218  + #[derive(PartialEq)]\n219  | pub enum Result<T> {\n     |\n\nSome errors have detailed explanations: E0061, E0369, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 9 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1373:36\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1373:19\n     |\n1373 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1373 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1382:36\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1382:19\n     |\n1382 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1382 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1387:17\n     |\n1387 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1387 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1388:20\n     |\n1388 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1388 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1389:14\n     |\n1389 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1389 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1390:22\n     |\n1390 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1390 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 8 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 14,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::Dfa is true\n",
        "// constraint: self.ro.match_type matches MatchType::Dfa or MatchType::DfaMany is true\n",
        "// constraint: self.shortest_dfa(text, start) matches dfa::Result::Match(_) is true\n",
        "// constraint: self.shortest_dfa(text, start) matches dfa::Result::Match(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "[start: 0, text: length 1 to 1024, self.ro.match_type: MatchType::Dfa or MatchType::DfaMany, self.is_anchor_end_match: true]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let program_cache_inner = ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    };",
                "",
                "    let program = Program {",
                "        insts: vec![], // Assuming valid instructions",
                "        matches: vec![], // Assuming valid match pointers",
                "        captures: vec![], // Assuming valid captures",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0, // Assuming a valid instruction pointer",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: true,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: true,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "",
                "    let exec_read_only = ExecReadOnly {",
                "        res: vec![\"abc\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::Dfa,",
                "    };",
                "",
                "    let cache = RefCell::new(program_cache_inner);",
                "    let exec_nosync = ExecNoSync {",
                "        ro: &Arc::new(exec_read_only),",
                "        cache: &cache,",
                "    };",
                "",
                "    let text = b\"abc\";",
                "    let start = 0;",
                "    exec_nosync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let program_cache_inner = ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: true,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: true,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res: vec![\"abc\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Dfa,",
                  "    };",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &cache,",
                  "    };",
                  "    let text = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(exec_nosync.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let program_cache_inner = ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "",
                  "    let program = Program {",
                  "        insts: vec![], // Assuming valid instructions",
                  "        matches: vec![], // Assuming valid match pointers",
                  "        captures: vec![], // Assuming valid captures",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0, // Assuming a valid instruction pointer",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: true,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res: vec![\"abc\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Dfa,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text = b\"abc\";",
                  "    let start = 0;",
                  "    exec_nosync.is_match_at(text, start);",
                  "    let program_cache_inner = ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: true,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: true,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res: vec![\"abc\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Dfa,",
                  "    };",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &cache,",
                  "    };",
                  "    let text = b\"abc\";",
                  "    let start = 0;",
                  "    assert!(exec_nosync.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1359:17\n     |\n1359 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1359 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1360:20\n     |\n1360 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1360 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1361:14\n     |\n1361 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1361 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1362:22\n     |\n1362 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1362 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1379:19\n     |\n1379 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1379 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1388:19\n     |\n1388 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1388 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1402:13\n     |\n1402 |     pikevm: pikevm::Cache::new(),\n     |             ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1402 |     pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1403:16\n     |\n1403 |     backtrack: backtrack::Cache::new(),\n     |                ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1403 |     backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1404:10\n     |\n1404 |     dfa: dfa::Cache::new(),\n     |          ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1404 |     dfa: dfa::Cache::new(/* &prog::Program */),\n     |                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1405:18\n     |\n1405 |     dfa_reverse: dfa::Cache::new(),\n     |                  ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1405 |     dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1429:15\n     |\n1429 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1429 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let program_cache_inner = ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    };",
                "",
                "    let program = Program {",
                "        insts: vec![], // Assuming valid instructions",
                "        matches: vec![], // Assuming valid match pointers",
                "        captures: vec![], // Assuming valid captures",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0, // Assuming a valid instruction pointer",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: true,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: true,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "",
                "    let exec_read_only = ExecReadOnly {",
                "        res: vec![\"abc\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::DfaMany,",
                "    };",
                "",
                "    let cache = RefCell::new(program_cache_inner);",
                "    let exec_nosync = ExecNoSync {",
                "        ro: &Arc::new(exec_read_only),",
                "        cache: &cache,",
                "    };",
                "",
                "    let text = b\"abc\";",
                "    let start = 0;",
                "    exec_nosync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let program_cache_inner = ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "    let program = Program {",
                  "    insts: vec![], // Assuming valid instructions",
                  "    matches: vec![], // Assuming valid match pointers",
                  "    captures: vec![], // Assuming valid captures",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0, // Assuming a valid instruction pointer",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: true,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: true,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res: vec![\"abc\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaMany,",
                  "    };",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &cache,",
                  "    };",
                  "    let text = b\"abc\";",
                  "    let start = 0;",
                  "    let result = exec_nosync.is_match_at(text, start);",
                  "    assert!(result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let program_cache_inner = ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "",
                  "    let program = Program {",
                  "        insts: vec![], // Assuming valid instructions",
                  "        matches: vec![], // Assuming valid match pointers",
                  "        captures: vec![], // Assuming valid captures",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0, // Assuming a valid instruction pointer",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: true,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res: vec![\"abc\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::DfaMany,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text = b\"abc\";",
                  "    let start = 0;",
                  "    exec_nosync.is_match_at(text, start);",
                  "    let program_cache_inner = ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "    let program = Program {",
                  "    insts: vec![], // Assuming valid instructions",
                  "    matches: vec![], // Assuming valid match pointers",
                  "    captures: vec![], // Assuming valid captures",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0, // Assuming a valid instruction pointer",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: true,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: true,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res: vec![\"abc\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::DfaMany,",
                  "    };",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &cache,",
                  "    };",
                  "    let text = b\"abc\";",
                  "    let start = 0;",
                  "    let result = exec_nosync.is_match_at(text, start);",
                  "    assert!(result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1359:17\n     |\n1359 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1359 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1360:20\n     |\n1360 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1360 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1361:14\n     |\n1361 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1361 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1362:22\n     |\n1362 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1362 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1379:19\n     |\n1379 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1379 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1388:19\n     |\n1388 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1388 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1402:13\n     |\n1402 |     pikevm: pikevm::Cache::new(),\n     |             ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1402 |     pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1403:16\n     |\n1403 |     backtrack: backtrack::Cache::new(),\n     |                ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1403 |     backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1404:10\n     |\n1404 |     dfa: dfa::Cache::new(),\n     |          ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1404 |     dfa: dfa::Cache::new(/* &prog::Program */),\n     |                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1405:18\n     |\n1405 |     dfa_reverse: dfa::Cache::new(),\n     |                  ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1405 |     dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1429:15\n     |\n1429 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1429 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let program_cache_inner = ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    };",
                "",
                "    let program = Program {",
                "        insts: vec![], // Assuming valid instructions",
                "        matches: vec![], // Assuming valid match pointers",
                "        captures: vec![], // Assuming valid captures",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0, // Assuming a valid instruction pointer",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: true,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: true,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::new(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "",
                "    let exec_read_only = ExecReadOnly {",
                "        res: vec![\"abc\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::new(),",
                "        match_type: MatchType::Dfa,",
                "    };",
                "",
                "    let cache = RefCell::new(program_cache_inner);",
                "    let exec_nosync = ExecNoSync {",
                "        ro: &Arc::new(exec_read_only),",
                "        cache: &cache,",
                "    };",
                "",
                "    let text = b\"a\".repeat(1024).as_slice(); // Large text input",
                "    let start = 0;",
                "    exec_nosync.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let program_cache_inner = ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: true,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: true,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res: vec![\"abc\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Dfa,",
                  "    };",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &cache,",
                  "    };",
                  "    let text = b\"a\".repeat(1024).as_slice();",
                  "    let start = 0;",
                  "    assert!(exec_nosync.is_match_at(text, start));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let program_cache_inner = ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "",
                  "    let program = Program {",
                  "        insts: vec![], // Assuming valid instructions",
                  "        matches: vec![], // Assuming valid match pointers",
                  "        captures: vec![], // Assuming valid captures",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0, // Assuming a valid instruction pointer",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: true,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::new(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "",
                  "    let exec_read_only = ExecReadOnly {",
                  "        res: vec![\"abc\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::new(),",
                  "        match_type: MatchType::Dfa,",
                  "    };",
                  "",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "        ro: &Arc::new(exec_read_only),",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    let text = b\"a\".repeat(1024).as_slice(); // Large text input",
                  "    let start = 0;",
                  "    exec_nosync.is_match_at(text, start);",
                  "    let program_cache_inner = ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    };",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: true,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: true,",
                  "    is_anchored_end: true,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::new(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = ExecReadOnly {",
                  "    res: vec![\"abc\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::new(),",
                  "    match_type: MatchType::Dfa,",
                  "    };",
                  "    let cache = RefCell::new(program_cache_inner);",
                  "    let exec_nosync = ExecNoSync {",
                  "    ro: &Arc::new(exec_read_only),",
                  "    cache: &cache,",
                  "    };",
                  "    let text = b\"a\".repeat(1024).as_slice();",
                  "    let start = 0;",
                  "    assert!(exec_nosync.is_match_at(text, start));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1359:17\n     |\n1359 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1359 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1360:20\n     |\n1360 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1360 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1361:14\n     |\n1361 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1361 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1362:22\n     |\n1362 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1362 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1379:36\n     |\n1379 |         prefixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1379:19\n     |\n1379 |         prefixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1379 |         prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1388:36\n     |\n1388 |         suffixes: LiteralSearcher::new(),\n     |                                    ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1388:19\n     |\n1388 |         suffixes: LiteralSearcher::new(),\n     |                   ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1388 |         suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1402:13\n     |\n1402 |     pikevm: pikevm::Cache::new(),\n     |             ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1402 |     pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1403:16\n     |\n1403 |     backtrack: backtrack::Cache::new(),\n     |                ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1403 |     backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1404:10\n     |\n1404 |     dfa: dfa::Cache::new(),\n     |          ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1404 |     dfa: dfa::Cache::new(/* &prog::Program */),\n     |                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1405:18\n     |\n1405 |     dfa_reverse: dfa::Cache::new(),\n     |                  ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1405 |     dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1421:32\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1421:15\n     |\n1421 |     prefixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1421 |     prefixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0624]: associated function `new` is private\n    --> src/exec.rs:1429:32\n     |\n1429 |     suffixes: LiteralSearcher::new(),\n     |                                ^^^ private associated function\n     |\n    ::: src/literal/mod.rs:76:5\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |     ------------------------------------------------ private associated function defined here\n\nerror[E0061]: this function takes 2 arguments but 0 arguments were supplied\n    --> src/exec.rs:1429:15\n     |\n1429 |     suffixes: LiteralSearcher::new(),\n     |               ^^^^^^^^^^^^^^^^^^^^-- two arguments of type `Literals` and `Matcher` are missing\n     |\nnote: associated function defined here\n    --> src/literal/mod.rs:76:8\n     |\n76   |     fn new(lits: Literals, matcher: Matcher) -> Self {\n     |        ^^^ --------------  ----------------\nhelp: provide the arguments\n     |\n1429 |     suffixes: LiteralSearcher::new(/* Literals */, /* Matcher */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0061, E0624.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 16 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is true\n",
        "// constraint: self.ro.match_type matches MatchType::Literal(ty) is true\n",
        "// constraint: self.ro.match_type matches MatchType::Literal(ty) is true\n"
      ],
      "input_infer": "text: [0, 1, 2, ..., 255], start: [0, <length_of_text>], ty: [\"Unanchored\", \"AnchoredStart\", \"AnchoredEnd\"]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                "    let start: usize = 0;",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let captures = Arc::new(HashMap::new());",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: captures.clone(),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: false,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: false,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"Hello\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::Literal(MatchLiteralType::Unanchored),",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "    assert!(exec.is_match_at(text, start));"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "    let match_type_literal = MatchType::Literal(MatchLiteralType::Unanchored);",
                  "    assert_eq!(exec.ro.match_type, match_type_literal);"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "    let match_type_literal = MatchType::Literal(MatchLiteralType::Unanchored);",
                  "    let anchor_end_match = exec.is_anchor_end_match(text);",
                  "    assert!(anchor_end_match);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::Unanchored),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "    assert!(exec.is_match_at(text, start));",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::Unanchored),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "    let match_type_literal = MatchType::Literal(MatchLiteralType::Unanchored);",
                  "    assert_eq!(exec.ro.match_type, match_type_literal);",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::Unanchored),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "    let match_type_literal = MatchType::Literal(MatchLiteralType::Unanchored);",
                  "    let anchor_end_match = exec.is_anchor_end_match(text);",
                  "    assert!(anchor_end_match);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1405:5\n     |\n1405 |     assert_eq!(exec.ro.match_type, match_type_literal);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     exec::MatchType\n     |     exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 7 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                "    let start: usize = 0;",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let captures = Arc::new(HashMap::new());",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: captures.clone(),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: false,",
                "        is_reverse: false,",
                "        is_anchored_start: true,",
                "        is_anchored_end: false,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"Hello\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::Literal(MatchLiteralType::AnchoredStart),",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.is_anchor_end_match(text) == false);"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.ro.match_type == MatchType::Literal(MatchLiteralType::AnchoredStart));"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.find_literals(MatchLiteralType::AnchoredStart, text, start).is_none());"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.shortest_dfa(text, start) == dfa::Result::Quit);"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.match_nfa(text, start) == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredStart),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.is_anchor_end_match(text) == false);",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredStart),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.ro.match_type == MatchType::Literal(MatchLiteralType::AnchoredStart));",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredStart),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.find_literals(MatchLiteralType::AnchoredStart, text, start).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredStart),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.shortest_dfa(text, start) == dfa::Result::Quit);",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: true,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredStart),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111];",
                  "    let start: usize = 0;",
                  "    assert!(exec.match_nfa(text, start) == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1404:32\n     |\n1404 |     assert!(exec.ro.match_type == MatchType::Literal(MatchLiteralType::AnchoredStart));\n     |             ------------------ ^^ --------------------------------------------------- exec::MatchType\n     |             |\n     |             exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 7 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `dfa::Result<usize>`\n    --> src/exec.rs:1404:44\n     |\n1404 |     assert!(exec.shortest_dfa(text, start) == dfa::Result::Quit);\n     |             ------------------------------ ^^ ----------------- dfa::Result<_>\n     |             |\n     |             dfa::Result<usize>\n     |\nnote: an implementation of `PartialEq<dfa::Result<_>>` might be missing for `dfa::Result<usize>`\n    --> src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<dfa::Result<_>>`\nhelp: consider annotating `dfa::Result<usize>` with `#[derive(PartialEq)]`\n    -->  src/dfa.rs:218:1\n     |\n218  + #[derive(PartialEq)]\n219  | pub enum Result<T> {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 7 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                "    let start: usize = 5; // End of \"Hello\"",
                "",
                "    let cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::default(),",
                "        backtrack: backtrack::Cache::default(),",
                "        dfa: dfa::Cache::default(),",
                "        dfa_reverse: dfa::Cache::default(),",
                "    });",
                "",
                "    let captures = Arc::new(HashMap::new());",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: captures.clone(),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: false,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: true,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 0,",
                "    };",
                "",
                "    let ro = Arc::new(ExecReadOnly {",
                "        res: vec![\"Hello\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::Literal(MatchLiteralType::AnchoredEnd),",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &ro,",
                "        cache: &cache,",
                "    };",
                "",
                "    exec.is_match_at(text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    assert!(is_anchor_end_match_result == true);"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    assert!(match_type == MatchType::Literal(MatchLiteralType::AnchoredEnd));"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    let find_literals_result = exec.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                  "    assert!(find_literals_result.is_none());"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    let find_literals_result = exec.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                  "    let shortest_dfa_result = exec.shortest_dfa(text, start);",
                  "    assert!(shortest_dfa_result == dfa::Result::Quit);"
                ],
                [
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    let find_literals_result = exec.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                  "    let shortest_dfa_result = exec.shortest_dfa(text, start);",
                  "    let match_nfa_result = exec.match_nfa(text, start);",
                  "    assert!(match_nfa_result == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredEnd),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    assert!(is_anchor_end_match_result == true);",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredEnd),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    assert!(match_type == MatchType::Literal(MatchLiteralType::AnchoredEnd));",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredEnd),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    let find_literals_result = exec.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                  "    assert!(find_literals_result.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredEnd),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    let find_literals_result = exec.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                  "    let shortest_dfa_result = exec.shortest_dfa(text, start);",
                  "    assert!(shortest_dfa_result == dfa::Result::Quit);",
                  "}"
                ],
                [
                  "{",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "",
                  "    let cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::default(),",
                  "        backtrack: backtrack::Cache::default(),",
                  "        dfa: dfa::Cache::default(),",
                  "        dfa_reverse: dfa::Cache::default(),",
                  "    });",
                  "",
                  "    let captures = Arc::new(HashMap::new());",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: captures.clone(),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: true,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 0,",
                  "    };",
                  "",
                  "    let ro = Arc::new(ExecReadOnly {",
                  "        res: vec![\"Hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Literal(MatchLiteralType::AnchoredEnd),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &ro,",
                  "        cache: &cache,",
                  "    };",
                  "",
                  "    exec.is_match_at(text, start);",
                  "    let text: &[u8] = &[72, 101, 108, 108, 111]; // \"Hello\"",
                  "    let start: usize = 5; // End of \"Hello\"",
                  "    let is_anchor_end_match_result = exec.is_anchor_end_match(text);",
                  "    let match_type = exec.ro.match_type;",
                  "    let find_literals_result = exec.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                  "    let shortest_dfa_result = exec.shortest_dfa(text, start);",
                  "    let match_nfa_result = exec.match_nfa(text, start);",
                  "    assert!(match_nfa_result == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `exec::MatchType`\n    --> src/exec.rs:1406:24\n     |\n1406 |     assert!(match_type == MatchType::Literal(MatchLiteralType::AnchoredEnd));\n     |             ---------- ^^ ------------------------------------------------- exec::MatchType\n     |             |\n     |             exec::MatchType\n     |\nnote: an implementation of `PartialEq` might be missing for `exec::MatchType`\n    --> src/exec.rs:1226:1\n     |\n1226 | enum MatchType {\n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\nhelp: consider annotating `exec::MatchType` with `#[derive(PartialEq)]`\n     |\n1226 + #[derive(PartialEq)]\n1227 | enum MatchType {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 7 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0369]: binary operation `==` cannot be applied to type `dfa::Result<usize>`\n    --> src/exec.rs:1408:33\n     |\n1408 |     assert!(shortest_dfa_result == dfa::Result::Quit);\n     |             ------------------- ^^ ----------------- dfa::Result<_>\n     |             |\n     |             dfa::Result<usize>\n     |\nnote: an implementation of `PartialEq<dfa::Result<_>>` might be missing for `dfa::Result<usize>`\n    --> src/dfa.rs:218:1\n     |\n218  | pub enum Result<T> {\n     | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<dfa::Result<_>>`\nhelp: consider annotating `dfa::Result<usize>` with `#[derive(PartialEq)]`\n    -->  src/dfa.rs:218:1\n     |\n218  + #[derive(PartialEq)]\n219  | pub enum Result<T> {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 7 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no function or associated item named `default` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1362:32\n     |\n1362 |         pikevm: pikevm::Cache::default(),\n     |                                ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `pikevm::Cache`, consider using `pikevm::Cache::new` which returns `pikevm::Cache`\n    --> src/pikevm.rs:88:5\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1363:38\n     |\n1363 |         backtrack: backtrack::Cache::default(),\n     |                                      ^^^^^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `backtrack::Cache`, consider using `backtrack::Cache::new` which returns `backtrack::Cache`\n    --> src/backtrack.rs:72:5\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1364:26\n     |\n1364 |         dfa: dfa::Cache::default(),\n     |                          ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1365:34\n     |\n1365 |         dfa_reverse: dfa::Cache::default(),\n     |                                  ^^^^^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `dfa::Cache`, consider using `dfa::Cache::new` which returns `dfa::Cache`\n    --> src/dfa.rs:425:5\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1383:36\n     |\n1383 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1392:36\n     |\n1392 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 16,
      "prompt_conds": [
        "// constraint: self.is_anchor_end_match(text) is false\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "text: [0..255], start: [0..1]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: Vec<u8> = vec![104, 101, 108, 108, 111]; // \"hello\"",
                "    let start: usize = 0;",
                "",
                "    let program_cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    });",
                "",
                "    let regex_options = RegexOptions::default();",
                "",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: true,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: false,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "",
                "    let exec_read_only = Arc::new(ExecReadOnly {",
                "        res: vec![\"^hello$\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::Dfa,",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &exec_read_only,",
                "        cache: &program_cache,",
                "    };",
                "",
                "    let result = exec.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: Vec<u8> = vec![104, 101, 108, 108, 111]; // \"hello\"",
                  "    let start: usize = 0;",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    let regex_options = RegexOptions::default();",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: false,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"^hello$\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::Dfa,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &program_cache,",
                  "    };",
                  "    assert_eq!(exec.is_anchor_end_match(&text), false);"
                ],
                [
                  "    let text: Vec<u8> = vec![104, 101, 108, 108, 111]; // \"hello\"",
                  "    let start: usize = 0;",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    let regex_options = RegexOptions::default();",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: false,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"^hello$\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::Dfa,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &program_cache,",
                  "    };",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: Vec<u8> = vec![104, 101, 108, 108, 111]; // \"hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "",
                  "    let regex_options = RegexOptions::default();",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"^hello$\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Dfa,",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let result = exec.is_match_at(&text, start);",
                  "    let text: Vec<u8> = vec![104, 101, 108, 108, 111]; // \"hello\"",
                  "    let start: usize = 0;",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    let regex_options = RegexOptions::default();",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: false,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"^hello$\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::Dfa,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &program_cache,",
                  "    };",
                  "    assert_eq!(exec.is_anchor_end_match(&text), false);",
                  "}"
                ],
                [
                  "{",
                  "    let text: Vec<u8> = vec![104, 101, 108, 108, 111]; // \"hello\"",
                  "    let start: usize = 0;",
                  "",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "",
                  "    let regex_options = RegexOptions::default();",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: true,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"^hello$\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Dfa,",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let result = exec.is_match_at(&text, start);",
                  "    let text: Vec<u8> = vec![104, 101, 108, 108, 111]; // \"hello\"",
                  "    let start: usize = 0;",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "    pikevm: pikevm::Cache::new(),",
                  "    backtrack: backtrack::Cache::new(),",
                  "    dfa: dfa::Cache::new(),",
                  "    dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "    let regex_options = RegexOptions::default();",
                  "    let program = Program {",
                  "    insts: vec![],",
                  "    matches: vec![],",
                  "    captures: vec![],",
                  "    capture_name_idx: Arc::new(HashMap::new()),",
                  "    start: 0,",
                  "    byte_classes: vec![],",
                  "    only_utf8: false,",
                  "    is_bytes: false,",
                  "    is_dfa: true,",
                  "    is_reverse: false,",
                  "    is_anchored_start: false,",
                  "    is_anchored_end: false,",
                  "    has_unicode_word_boundary: false,",
                  "    prefixes: LiteralSearcher::default(),",
                  "    dfa_size_limit: 1024,",
                  "    };",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "    res: vec![\"^hello$\".to_string()],",
                  "    nfa: program.clone(),",
                  "    dfa: program.clone(),",
                  "    dfa_reverse: program.clone(),",
                  "    suffixes: LiteralSearcher::default(),",
                  "    match_type: MatchType::Dfa,",
                  "    });",
                  "    let exec = ExecNoSync {",
                  "    ro: &exec_read_only,",
                  "    cache: &program_cache,",
                  "    };",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1362:17\n     |\n1362 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1362 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1363:20\n     |\n1363 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1363 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1364:14\n     |\n1364 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1364 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1365:22\n     |\n1365 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1365 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1384:36\n     |\n1384 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1406:13\n     |\n1406 |     pikevm: pikevm::Cache::new(),\n     |             ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1406 |     pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1407:16\n     |\n1407 |     backtrack: backtrack::Cache::new(),\n     |                ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1407 |     backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1408:10\n     |\n1408 |     dfa: dfa::Cache::new(),\n     |          ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1408 |     dfa: dfa::Cache::new(/* &prog::Program */),\n     |                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1409:18\n     |\n1409 |     dfa_reverse: dfa::Cache::new(),\n     |                  ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1409 |     dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1426:32\n     |\n1426 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1434:32\n     |\n1434 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1362:17\n     |\n1362 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1362 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1363:20\n     |\n1363 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1363 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1364:14\n     |\n1364 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1364 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1365:22\n     |\n1365 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1365 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1384:36\n     |\n1384 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1406:13\n     |\n1406 |     pikevm: pikevm::Cache::new(),\n     |             ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1406 |     pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                               ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1407:16\n     |\n1407 |     backtrack: backtrack::Cache::new(),\n     |                ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1407 |     backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1408:10\n     |\n1408 |     dfa: dfa::Cache::new(),\n     |          ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1408 |     dfa: dfa::Cache::new(/* &prog::Program */),\n     |                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1409:18\n     |\n1409 |     dfa_reverse: dfa::Cache::new(),\n     |                  ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1409 |     dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1426:32\n     |\n1426 |     prefixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1434:32\n     |\n1434 |     suffixes: LiteralSearcher::default(),\n     |                                ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 12 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let text: Vec<u8> = vec![108, 111, 114]; // \"lor\"",
                "    let start: usize = 1;",
                "",
                "    let program_cache = RefCell::new(ProgramCacheInner {",
                "        pikevm: pikevm::Cache::new(),",
                "        backtrack: backtrack::Cache::new(),",
                "        dfa: dfa::Cache::new(),",
                "        dfa_reverse: dfa::Cache::new(),",
                "    });",
                "",
                "    let regex_options = RegexOptions::default();",
                "",
                "    let program = Program {",
                "        insts: vec![],",
                "        matches: vec![],",
                "        captures: vec![],",
                "        capture_name_idx: Arc::new(HashMap::new()),",
                "        start: 0,",
                "        byte_classes: vec![],",
                "        only_utf8: false,",
                "        is_bytes: false,",
                "        is_dfa: false,",
                "        is_reverse: false,",
                "        is_anchored_start: false,",
                "        is_anchored_end: false,",
                "        has_unicode_word_boundary: false,",
                "        prefixes: LiteralSearcher::default(),",
                "        dfa_size_limit: 1024,",
                "    };",
                "",
                "    let exec_read_only = Arc::new(ExecReadOnly {",
                "        res: vec![\"hello\".to_string()],",
                "        nfa: program.clone(),",
                "        dfa: program.clone(),",
                "        dfa_reverse: program.clone(),",
                "        suffixes: LiteralSearcher::default(),",
                "        match_type: MatchType::Nfa(MatchNfaType::Auto),",
                "    });",
                "",
                "    let exec = ExecNoSync {",
                "        ro: &exec_read_only,",
                "        cache: &program_cache,",
                "    };",
                "",
                "    let result = exec.is_match_at(&text, start);",
                "}"
              ],
              "oracles": [
                [
                  "    let text: Vec<u8> = vec![108, 111, 114]; // \"lor\"",
                  "    let start: usize = 1;",
                  "    let result = exec.is_match_at(&text, start);",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let text: Vec<u8> = vec![108, 111, 114]; // \"lor\"",
                  "    let start: usize = 1;",
                  "",
                  "    let program_cache = RefCell::new(ProgramCacheInner {",
                  "        pikevm: pikevm::Cache::new(),",
                  "        backtrack: backtrack::Cache::new(),",
                  "        dfa: dfa::Cache::new(),",
                  "        dfa_reverse: dfa::Cache::new(),",
                  "    });",
                  "",
                  "    let regex_options = RegexOptions::default();",
                  "",
                  "    let program = Program {",
                  "        insts: vec![],",
                  "        matches: vec![],",
                  "        captures: vec![],",
                  "        capture_name_idx: Arc::new(HashMap::new()),",
                  "        start: 0,",
                  "        byte_classes: vec![],",
                  "        only_utf8: false,",
                  "        is_bytes: false,",
                  "        is_dfa: false,",
                  "        is_reverse: false,",
                  "        is_anchored_start: false,",
                  "        is_anchored_end: false,",
                  "        has_unicode_word_boundary: false,",
                  "        prefixes: LiteralSearcher::default(),",
                  "        dfa_size_limit: 1024,",
                  "    };",
                  "",
                  "    let exec_read_only = Arc::new(ExecReadOnly {",
                  "        res: vec![\"hello\".to_string()],",
                  "        nfa: program.clone(),",
                  "        dfa: program.clone(),",
                  "        dfa_reverse: program.clone(),",
                  "        suffixes: LiteralSearcher::default(),",
                  "        match_type: MatchType::Nfa(MatchNfaType::Auto),",
                  "    });",
                  "",
                  "    let exec = ExecNoSync {",
                  "        ro: &exec_read_only,",
                  "        cache: &program_cache,",
                  "    };",
                  "",
                  "    let result = exec.is_match_at(&text, start);",
                  "    let text: Vec<u8> = vec![108, 111, 114]; // \"lor\"",
                  "    let start: usize = 1;",
                  "    let result = exec.is_match_at(&text, start);",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/exec.rs:1354:8\n     |\n1354 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1362:17\n     |\n1362 |         pikevm: pikevm::Cache::new(),\n     |                 ^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/pikevm.rs:88:12\n     |\n88   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1362 |         pikevm: pikevm::Cache::new(/* &prog::Program */),\n     |                                   ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1363:20\n     |\n1363 |         backtrack: backtrack::Cache::new(),\n     |                    ^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/backtrack.rs:72:12\n     |\n72   |     pub fn new(_prog: &Program) -> Self {\n     |            ^^^ ---------------\nhelp: provide the argument\n     |\n1363 |         backtrack: backtrack::Cache::new(/* &prog::Program */),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1364:14\n     |\n1364 |         dfa: dfa::Cache::new(),\n     |              ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1364 |         dfa: dfa::Cache::new(/* &prog::Program */),\n     |                             ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> src/exec.rs:1365:22\n     |\n1365 |         dfa_reverse: dfa::Cache::new(),\n     |                      ^^^^^^^^^^^^^^^-- argument #1 of type `&prog::Program` is missing\n     |\nnote: associated function defined here\n    --> src/dfa.rs:425:12\n     |\n425  |     pub fn new(prog: &Program) -> Self {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1365 |         dfa_reverse: dfa::Cache::new(/* &prog::Program */),\n     |                                     ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1384:36\n     |\n1384 |         prefixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `literal::LiteralSearcher` in the current scope\n    --> src/exec.rs:1393:36\n     |\n1393 |         suffixes: LiteralSearcher::default(),\n     |                                    ^^^^^^^ function or associated item not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `literal::LiteralSearcher` consider using one of the following associated functions:\n      literal::LiteralSearcher::empty\n      literal::LiteralSearcher::prefixes\n      literal::LiteralSearcher::suffixes\n    --> src/literal/mod.rs:60:5\n     |\n60   |     pub fn empty() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^\n...\n65   |     pub fn prefixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n71   |     pub fn suffixes(lits: Literals) -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 6 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}