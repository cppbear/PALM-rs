{
  "name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_perl_class",
  "name_with_impl": "regex_syntax::ast::parse::{impl#5}::parse_perl_class",
  "mod_info": {
    "name": "ast::parse",
    "loc": "regex-syntax/src/ast/mod.rs:21:1:21:15"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/parse.rs:2087:5:2101:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: c matches 'w' is true\n",
        "// constraint: c matches 'W' is true\n",
        "// constraint: c matches 's' is true\n",
        "// constraint: c matches 'S' is true\n",
        "// constraint: c matches 'D' is true\n",
        "// constraint: c matches 'd' is true\n"
      ],
      "input_infer": "c in ['d', 'D', 's', 'S', 'w', 'W']\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\d\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\", };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5392:29\n     |\n5392 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5394:29\n     |\n5394 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5396:29\n     |\n5396 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5398:29\n     |\n5398 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5400:29\n     |\n5400 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5402:29\n     |\n5402 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5400:60\n     |\n5400 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5400:60\n     |\n5400 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\D\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, expected_kind);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, expected_negated);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Word);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Space);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Space);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);"
                ],
                [
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, expected_kind);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, expected_negated);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = '\\\\D';",
                  "    let expected_span = /* expected span position values based on the input pattern */;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let expected_negated = true;",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: character literal may only contain one codepoint\n    --> regex-syntax/src/ast/parse.rs:5390:13\n     |\n5390 |     let c = '\\\\D';\n     |             ^^^^^\n     |\nhelp: if you meant to write a string literal, use double quotes\n     |\n5390 |     let c = \"\\\\D\";\n     |             ~   ~\n\nerror: expected expression, found `;`\n    --> regex-syntax/src/ast/parse.rs:5391:87\n     |\n5391 |     let expected_span = /* expected span position values based on the input pattern */;\n     |                                                                                       ^ expected expression\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\s\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start >= 0);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5407:29\n     |\n5407 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5407:34\n     |\n5407 |     assert!(result.span.start >= 0);\n     |             -----------------    ^ expected `Position`, found integer\n     |             |\n     |             expected because this is `ast::Position`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5424:29\n     |\n5424 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5424:34\n     |\n5424 |     assert!(result.span.start >= 0);\n     |             -----------------    ^ expected `Position`, found integer\n     |             |\n     |             expected because this is `ast::Position`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5441:29\n     |\n5441 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5441:34\n     |\n5441 |     assert!(result.span.start >= 0);\n     |             -----------------    ^ expected `Position`, found integer\n     |             |\n     |             expected because this is `ast::Position`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5458:29\n     |\n5458 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5458:34\n     |\n5458 |     assert!(result.span.start >= 0);\n     |             -----------------    ^ expected `Position`, found integer\n     |             |\n     |             expected because this is `ast::Position`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5475:29\n     |\n5475 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5475:34\n     |\n5475 |     assert!(result.span.start >= 0);\n     |             -----------------    ^ expected `Position`, found integer\n     |             |\n     |             expected because this is `ast::Position`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\S\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(char, 'S');"
                ],
                [
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(span.start, expected_start_position);"
                ],
                [
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(span.end, expected_end_position);"
                ],
                [
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);"
                ],
                [
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(char, 'S');",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(span.start, expected_start_position);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(span.end, expected_end_position);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let char = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_start_position` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:28\n     |\n5393 |     assert_eq!(span.start, expected_start_position);\n     |                            ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_end_position` in this scope\n    --> regex-syntax/src/ast/parse.rs:5393:26\n     |\n5393 |     assert_eq!(span.end, expected_end_position);\n     |                          ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5394:33\n     |\n5394 |     assert_eq!(perl_class.kind, ClassPerlKind::Space);\n     |                                 ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\w\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\d\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position { /* suitable values */ }),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5407:29\n     |\n5407 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5424:29\n     |\n5424 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5441:29\n     |\n5441 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5458:29\n     |\n5458 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5475:29\n     |\n5475 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5492:29\n     |\n5492 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5477:20\n     |\n5477 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:20\n     |\n5392 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5409:20\n     |\n5409 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5426:20\n     |\n5426 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5443:20\n     |\n5443 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5460:20\n     |\n5460 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5477:20\n     |\n5477 |     pos: Cell::new(Position { /* suitable values */ }),\n     |                    ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\W\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\W\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\w\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\S\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\s\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\D\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"\\\\d\" };",
                  "    let perl_class = parser.parse_perl_class();",
                  "    assert_eq!(perl_class.negated, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5392:33\n     |\n5392 |     assert_eq!(perl_class.kind, ClassPerlKind::Word);\n     |                                 ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5394:33\n     |\n5394 |     assert_eq!(perl_class.kind, ClassPerlKind::Word);\n     |                                 ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5396:33\n     |\n5396 |     assert_eq!(perl_class.kind, ClassPerlKind::Space);\n     |                                 ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5398:33\n     |\n5398 |     assert_eq!(perl_class.kind, ClassPerlKind::Space);\n     |                                 ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5400:33\n     |\n5400 |     assert_eq!(perl_class.kind, ClassPerlKind::Digit);\n     |                                 ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5402:33\n     |\n5402 |     assert_eq!(perl_class.kind, ClassPerlKind::Digit);\n     |                                 ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5400:60\n     |\n5400 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position { /* initialize with suitable values */ }),\n     |                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5392:60\n     |\n5392 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5394:60\n     |\n5394 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5396:60\n     |\n5396 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5398:60\n     |\n5398 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nerror[E0063]: missing fields `column`, `line` and `offset` in initializer of `ast::Position`\n    --> regex-syntax/src/ast/parse.rs:5400:60\n     |\n5400 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position { /* suitable values */ }), capture_index: Cell::new(0), nest_limit: ...\n     |                                                            ^^^^^^^^ missing `column`, `line` and `offset`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { /* initialize with suitable values */ }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"\\\\x\", // Invalid character",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: c matches 'W' is true\n",
        "// constraint: c matches 'W' is true\n",
        "// expected return value/type: ast::ClassPerl { span: span, kind: kind, negated: negated }\n"
      ],
      "input_infer": "c = 'W'\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let parser = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\\\\W\",",
                "    };",
                "    ",
                "    let result = parser_i.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.span, span);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert!(!result.negated);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.span, span);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert!(!result.negated);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5413:29\n     |\n5413 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let parser = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\\\\d\",",
                "    };",
                "    ",
                "    let result = parser_i.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    assert_eq!(result, expected_result);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    assert_eq!(result, expected_result);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    assert_eq!(result, expected_result);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };",
                  "    assert_eq!(result, expected_result);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false };",
                  "    assert_eq!(result, expected_result);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: true };",
                  "    assert_eq!(result, expected_result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false };",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\s\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\S\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\w\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    let result = parser_i.parse_perl_class();",
                  "    let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: true };",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5395:56\n     |\n5395 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5395:56\n     |\n5395 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5401:56\n     |\n5401 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5395:56\n     |\n5395 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5401:56\n     |\n5401 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5407:56\n     |\n5407 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5395:56\n     |\n5395 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5401:56\n     |\n5401 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5407:56\n     |\n5407 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5413:56\n     |\n5413 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5395:56\n     |\n5395 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5401:56\n     |\n5401 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5407:56\n     |\n5407 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5413:56\n     |\n5413 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5419:56\n     |\n5419 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5395:56\n     |\n5395 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5401:56\n     |\n5401 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5407:56\n     |\n5407 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5413:56\n     |\n5413 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Space, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5419:56\n     |\n5419 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: false };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5425:56\n     |\n5425 |     let expected_result = ast::ClassPerl { span, kind: ClassPerlKind::Word, negated: true };\n     |                                                        ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let parser = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\\\\W\",",
                "    };",
                "    ",
                "    let result = parser_i.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    assert_eq!(result.span, span);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    assert_eq!(result.negated, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    assert_eq!(result.span, span);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\W\",",
                  "    };",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5412:29\n     |\n5412 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let parser = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"\\\\D\",",
                "    };",
                "    ",
                "    let result = parser_i.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    assert_eq!(result.span, span);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    assert!(result.negated);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    assert_eq!(result.span, span);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    ",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    ",
                  "    let result = parser_i.parse_perl_class();",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let parser = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "    parser: &parser,",
                  "    pattern: \"\\\\D\",",
                  "    };",
                  "    assert!(result.negated);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5412:29\n     |\n5412 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:30\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5373:48\n     |\n5373 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:30\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |       let span = Span { start: Position(0), end: Position(1) };\n     |                                                  ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5396:20\n     |\n5396 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: c matches 'w' is true\n",
        "// constraint: c matches 'w' is true\n",
        "// expected return value/type: ast::ClassPerl { span: span, kind: kind, negated: negated }\n"
      ],
      "input_infer": "c = {'w', 'W'}, span.start = 0 to 1, span.end = 1 to 2, negated = {false, true}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        pos: Cell::new(0),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"w\",",
                "    };",
                "    parser_i.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Word);"
                ],
                [
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"w\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"w\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:42\n     |\n5391 |     let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ...\n     |                                --------- ^ expected `Position`, found integer\n     |                                |\n     |                                arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:42\n     |\n5391 |     let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ...\n     |                                --------- ^ expected `Position`, found integer\n     |                                |\n     |                                arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        pos: Cell::new(0),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"W\",",
                "    };",
                "    parser_i.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Word);"
                ],
                [
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert!(result.span.start >= 0);"
                ],
                [
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"W\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"W\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"W\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert!(result.span.start >= 0);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"W\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_i = ParserI { parser: &parser, pattern: \"w\", };",
                  "    let result = parser_i.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:42\n     |\n5391 |     let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ...\n     |                                --------- ^ expected `Position`, found integer\n     |                                |\n     |                                arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:42\n     |\n5391 |     let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ...\n     |                                --------- ^ expected `Position`, found integer\n     |                                |\n     |                                arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:42\n     |\n5391 |     let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ...\n     |                                --------- ^ expected `Position`, found integer\n     |                                |\n     |                                arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5394:34\n     |\n5394 |     assert!(result.span.start >= 0);\n     |             -----------------    ^ expected `Position`, found integer\n     |             |\n     |             expected because this is `Position`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5391:42\n     |\n5391 |     let parser = Parser { pos: Cell::new(0), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ...\n     |                                --------- ^ expected `Position`, found integer\n     |                                |\n     |                                arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"expected valid Perl class but got 'x'\")]"
              ],
              "prefix": [
                "{",
                "    let parser = Parser {",
                "        pos: Cell::new(0),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"x\",",
                "    };",
                "    parser_i.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: expected_kind, negated: expected_negated });"
                ],
                [
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class().negated, false);"
                ],
                [
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class().kind, ast::ClassPerlKind::Word);"
                ],
                [
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class().span, expected_span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"x\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class(), ast::ClassPerl { span: expected_span, kind: expected_kind, negated: expected_negated });",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"x\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class().negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"x\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class().kind, ast::ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = Parser {",
                  "        pos: Cell::new(0),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_i = ParserI {",
                  "        parser: &parser,",
                  "        pattern: \"x\",",
                  "    };",
                  "    parser_i.parse_perl_class();",
                  "    let c = 'x';",
                  "    let expected_span = parser_i.span_char();",
                  "    let expected_kind = ast::ClassPerlKind::Word;",
                  "    let expected_negated = false;",
                  "    assert_eq!(parser_i.parse_perl_class().span, expected_span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/ast/parse.rs:5375:24\n     |\n5375 |         pos: Cell::new(0),\n     |              --------- ^ expected `Position`, found integer\n     |              |\n     |              arguments to this function are incorrect\n     |\nnote: associated function defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cell.rs:408:18\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: c matches 'S' is true\n",
        "// constraint: c matches 'S' is true\n",
        "// expected return value/type: ast::ClassPerl { span: span, kind: kind, negated: negated }\n"
      ],
      "input_infer": "c: 'S'\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_state = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser_state,",
                "        pattern: \"some_pattern_with_space_class\",",
                "    };",
                "",
                "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                "    let result = parser_instance.parse_perl_class(); // Here, `'S'` would have been found and matched",
                "}"
              ],
              "oracles": [
                [
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert!(result.span.start >= Position(0)); // Ensure valid span"
                ],
                [
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start); // End should be after start"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser_state = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser_state,",
                  "        pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class(); // Here, `'S'` would have been found and matched",
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser_state = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser_state,",
                  "        pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class(); // Here, `'S'` would have been found and matched",
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser_state = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser_state,",
                  "        pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class(); // Here, `'S'` would have been found and matched",
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert!(result.span.start >= Position(0)); // Ensure valid span",
                  "}"
                ],
                [
                  "{",
                  "    let parser_state = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser_state,",
                  "        pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class(); // Here, `'S'` would have been found and matched",
                  "    let parser_state = Parser {",
                  "    pos: Cell::new(Position(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    };",
                  "    let parser_instance = ParserI {",
                  "    parser: &parser_state,",
                  "    pattern: \"some_pattern_with_space_class\",",
                  "    };",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 'S'",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert!(result.span.end > result.span.start); // End should be after start",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5413:29\n     |\n5413 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:20\n     |\n5395 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:20\n     |\n5395 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:20\n     |\n5395 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5413:34\n     |\n5413 |       assert!(result.span.start >= Position(0)); // Ensure valid span\n     |                                    ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:20\n     |\n5395 |       pos: Cell::new(Position(0)),\n     |                      ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser_state = Parser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser_state,",
                "        pattern: \"some_pattern_with_non_negated_space_class\",",
                "    };",
                "",
                "    parser_instance.bump(); // Simulate advancing the parser to the 's'",
                "    let result = parser_instance.parse_perl_class(); // Should be parsed as non-negated",
                "}"
              ],
              "oracles": [
                [
                  "    let parser_state = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_instance = ParserI { parser: &parser_state, pattern: \"some_pattern_with_non_negated_space_class\", };",
                  "    parser_instance.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser_state = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_instance = ParserI { parser: &parser_state, pattern: \"some_pattern_with_non_negated_space_class\", };",
                  "    parser_instance.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser_state = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser_state,",
                  "        pattern: \"some_pattern_with_non_negated_space_class\",",
                  "    };",
                  "",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 's'",
                  "    let result = parser_instance.parse_perl_class(); // Should be parsed as non-negated",
                  "    let parser_state = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_instance = ParserI { parser: &parser_state, pattern: \"some_pattern_with_non_negated_space_class\", };",
                  "    parser_instance.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser_state = Parser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 10,",
                  "        octal: true,",
                  "        initial_ignore_whitespace: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        comments: RefCell::new(vec![]),",
                  "        stack_group: RefCell::new(vec![]),",
                  "        stack_class: RefCell::new(vec![]),",
                  "        capture_names: RefCell::new(vec![]),",
                  "        scratch: RefCell::new(String::new()),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser_state,",
                  "        pattern: \"some_pattern_with_non_negated_space_class\",",
                  "    };",
                  "",
                  "    parser_instance.bump(); // Simulate advancing the parser to the 's'",
                  "    let result = parser_instance.parse_perl_class(); // Should be parsed as non-negated",
                  "    let parser_state = Parser { pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), };",
                  "    let parser_instance = ParserI { parser: &parser_state, pattern: \"some_pattern_with_non_negated_space_class\", };",
                  "    parser_instance.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5398:29\n     |\n5398 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |   ...pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whites...\n     |                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5374:24\n     |\n5374 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5394:48\n     |\n5394 |   ...pos: Cell::new(Position(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whites...\n     |                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: c matches 's' is true\n",
        "// constraint: c matches 's' is true\n",
        "// expected return value/type: ast::ClassPerl { span: span, kind: kind, negated: negated }\n"
      ],
      "input_infer": "c = {'s', 'S'}, span = {0, 1}, negated = {true, false}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestParser {",
                "        pos: Cell<Position>,",
                "        capture_index: Cell<u32>,",
                "        nest_limit: u32,",
                "        octal: bool,",
                "        ignore_whitespace: Cell<bool>,",
                "        pattern: String,",
                "    }",
                "",
                "    impl TestParser {",
                "        fn char(&self) -> char {",
                "            's'",
                "        }",
                "",
                "        fn span_char(&self) -> Span {",
                "            Span { start: Position(0), end: Position(1) }",
                "        }",
                "",
                "        fn bump(&self) {}",
                "    }",
                "",
                "    let parser = TestParser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        pattern: String::from(\"\\\\s\"),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: &parser.pattern,",
                "    };",
                "",
                "    parser_instance.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.span.start, Position(0));"
                ],
                [
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.span.end, Position(1));"
                ],
                [
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            's'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\s\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.span.start, Position(0));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            's'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\s\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.span.end, Position(1));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            's'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\s\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            's'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\s\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let parser_instance = ParserI { parser: &parser, pattern: &parser.pattern };",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5410:34\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5410 |     let result = parser_instance.parse_perl_class();\n     |                                  ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5411:35\n     |\n5411 |       assert_eq!(result.span.start, Position(0));\n     |                                     ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5410:34\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5410 |     let result = parser_instance.parse_perl_class();\n     |                                  ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5411:33\n     |\n5411 |       assert_eq!(result.span.end, Position(1));\n     |                                   ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5411:29\n     |\n5411 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5410:34\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5410 |     let result = parser_instance.parse_perl_class();\n     |                                  ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5410:34\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5410 |     let result = parser_instance.parse_perl_class();\n     |                                  ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestParser {",
                "        pos: Cell<Position>,",
                "        capture_index: Cell<u32>,",
                "        nest_limit: u32,",
                "        octal: bool,",
                "        ignore_whitespace: Cell<bool>,",
                "        pattern: String,",
                "    }",
                "",
                "    impl TestParser {",
                "        fn char(&self) -> char {",
                "            'S'",
                "        }",
                "",
                "        fn span_char(&self) -> Span {",
                "            Span { start: Position(0), end: Position(1) }",
                "        }",
                "",
                "        fn bump(&self) {}",
                "    }",
                "",
                "    let parser = TestParser {",
                "        pos: Cell::new(Position(0)),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        pattern: String::from(\"\\\\S\"),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: &parser.pattern,",
                "    };",
                "",
                "    parser_instance.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    assert_eq!(c, 'S');"
                ],
                [
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    assert_eq!(span.start, Position(0));"
                ],
                [
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    assert_eq!(span.end, Position(1));"
                ],
                [
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            'S'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\S\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    assert_eq!(c, 'S');",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            'S'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\S\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    assert_eq!(span.start, Position(0));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            'S'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\S\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    assert_eq!(span.end, Position(1));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            'S'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\S\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            'S'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\S\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestParser {",
                  "        pos: Cell<Position>,",
                  "        capture_index: Cell<u32>,",
                  "        nest_limit: u32,",
                  "        octal: bool,",
                  "        ignore_whitespace: Cell<bool>,",
                  "        pattern: String,",
                  "    }",
                  "",
                  "    impl TestParser {",
                  "        fn char(&self) -> char {",
                  "            'S'",
                  "        }",
                  "",
                  "        fn span_char(&self) -> Span {",
                  "            Span { start: Position(0), end: Position(1) }",
                  "        }",
                  "",
                  "        fn bump(&self) {}",
                  "    }",
                  "",
                  "    let parser = TestParser {",
                  "        pos: Cell::new(Position(0)),",
                  "        capture_index: Cell::new(0),",
                  "        nest_limit: 0,",
                  "        octal: false,",
                  "        ignore_whitespace: Cell::new(false),",
                  "        pattern: String::from(\"\\\\S\"),",
                  "    };",
                  "",
                  "    let parser_instance = ParserI {",
                  "        parser: &parser,",
                  "        pattern: &parser.pattern,",
                  "    };",
                  "",
                  "    parser_instance.parse_perl_class();",
                  "    let c = parser_instance.parser.char();",
                  "    let span = parser_instance.parser.span_char();",
                  "    parser_instance.parser.bump();",
                  "    let result = parser_instance.parse_perl_class();",
                  "    assert_eq!(result.span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5412:28\n     |\n5412 |       assert_eq!(span.start, Position(0));\n     |                              ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5412:26\n     |\n5412 |       assert_eq!(span.end, Position(1));\n     |                            ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5413:29\n     |\n5413 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5412:34\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5412 |     let result = parser_instance.parse_perl_class();\n     |                                  ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5412:34\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5412 |     let result = parser_instance.parse_perl_class();\n     |                                  ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5395:24\n     |\n5395 |           pos: Cell::new(Position(0)),\n     |                          ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5408:21\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5408 |     parser_instance.parse_perl_class();\n     |                     ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0599]: the method `parse_perl_class` exists for struct `ParserI<'_, &TestParser>`, but its trait bounds were not satisfied\n    --> regex-syntax/src/ast/parse.rs:5412:34\n     |\n276  | struct ParserI<'s, P> {\n     | --------------------- method `parse_perl_class` not found for this struct\n...\n5412 |     let result = parser_instance.parse_perl_class();\n     |                                  ^^^^^^^^^^^^^^^^ method cannot be called on `ParserI<'_, &TestParser>` due to unsatisfied trait bounds\n     |\nnote: trait bound `&TestParser: Borrow<parse::Parser>` was not satisfied\n    --> regex-syntax/src/ast/parse.rs:969:13\n     |\n969  | impl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n     |             ^^^^^^^^^^^^^^  --------------\n     |             |\n     |             unsatisfied trait bound introduced here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:27\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                             ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `Position`\n    --> regex-syntax/src/ast/parse.rs:5388:45\n     |\n5388 |               Span { start: Position(0), end: Position(1) }\n     |                                               ^^^^^^^^^^^ help: use struct literal syntax instead: `Position { offset: val, line: val, column: val }`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | / pub struct Position {\n364  | |     /// The absolute offset of this position, starting at `0` from the\n365  | |     /// beginning of the regular expression pattern string.\n366  | |     pub offset: usize,\n...    |\n370  | |     pub column: usize,\n371  | | }\n     | |_- `Position` defined here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: c matches 'D' is true\n",
        "// constraint: c matches 'D' is true\n",
        "// expected return value/type: ast::ClassPerl { span: span, kind: kind, negated: negated }\n"
      ],
      "input_infer": "'matches c = 'd', 'D', 's', 'S', 'w', 'W' and triggers panic when c is not one of them'\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: r\"\\d\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_negated = true;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, expected_negated);"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_negated = true;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, expected_kind);"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_negated = true;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_negated = true;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, expected_negated);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_negated = true;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, expected_kind);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_negated = true;",
                  "    let expected_kind = ast::ClassPerlKind::Digit;",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: r\"\\D\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = parser.char();",
                  "    assert_eq!(c, 'D');"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.negated);"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    assert_eq!(c, 'D');",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.negated);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: r\"\\s\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: r\"\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: r\"\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.negated);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: r\"\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ast::ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: r\"\\D\", };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.negated);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, i...\n     |                                                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0, /* usize */, /* usize */)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: r\"\\D\", };\n     |                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5390:60\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0)), capture_index: Cell::new(0), nest_limit: 10, octal: true, i...\n     |                                                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5390 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::new(0, /* usize */, /* usize */)), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: r\"\\D\", };\n     |                                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: r\"\\S\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = 'D';",
                  "    let span = parser.span_char();",
                  "    let negated = true;",
                  "    let kind = ast::ClassPerlKind::Digit;",
                  "    let expected = ast::ClassPerl { span, kind, negated };",
                  "    assert_eq!(parser.parse_perl_class(), expected);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = 'D';",
                  "    let span = parser.span_char();",
                  "    let negated = true;",
                  "    let kind = ast::ClassPerlKind::Digit;",
                  "    let expected = ast::ClassPerl { span, kind, negated };",
                  "    assert_eq!(parser.parse_perl_class(), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: r\"\\w\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(c, 'w');"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_class_perl = ast::ClassPerl { span: span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "    assert_eq!(parser.parse_perl_class(), expected_class_perl);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(c, 'w');",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    let expected_class_perl = ast::ClassPerl { span: span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "    assert_eq!(parser.parse_perl_class(), expected_class_perl);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: r\"\\W\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = 'D';",
                  "    let span = Span { start: Position::new(0), end: Position::new(2) };",
                  "    let kind = ClassPerlKind::Digit;",
                  "    let negated = true;",
                  "    let expected = ast::ClassPerl { span, kind, negated };",
                  "    assert_eq!(parser.parse_perl_class(), expected);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = 'D';",
                  "    let span = Span { start: Position::new(0), end: Position::new(2) };",
                  "    let kind = ClassPerlKind::Digit;",
                  "    let negated = true;",
                  "    let expected = ast::ClassPerl { span, kind, negated };",
                  "    assert_eq!(parser.parse_perl_class(), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5392:16\n     |\n5392 |     let kind = ClassPerlKind::Digit;\n     |                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5375:28\n     |\n5375 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5375 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5391:30\n     |\n5391 |     let span = Span { start: Position::new(0), end: Position::new(2) };\n     |                              ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5391 |     let span = Span { start: Position::new(0, /* usize */, /* usize */), end: Position::new(2) };\n     |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5391:53\n     |\n5391 |     let span = Span { start: Position::new(0), end: Position::new(2) };\n     |                                                     ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5391 |     let span = Span { start: Position::new(0), end: Position::new(2, /* usize */, /* usize */) };\n     |                                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position::new(0)),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: true,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: r\"\\x\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position::new(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: r\"\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position::new(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: r\"\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position::new(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: r\"\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start < result.span.end);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\x\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position::new(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: r\"\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\x\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position::new(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: r\"\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser {",
                  "            pos: Cell::new(Position::new(0)),",
                  "            capture_index: Cell::new(0),",
                  "            nest_limit: 10,",
                  "            octal: true,",
                  "            initial_ignore_whitespace: false,",
                  "            ignore_whitespace: Cell::new(false),",
                  "            comments: RefCell::new(vec![]),",
                  "            stack_group: RefCell::new(vec![]),",
                  "            stack_class: RefCell::new(vec![]),",
                  "            capture_names: RefCell::new(vec![]),",
                  "            scratch: RefCell::new(String::new()),",
                  "        },",
                  "        pattern: r\"\\x\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI {",
                  "    parser: Parser {",
                  "    pos: Cell::new(Position::new(0)),",
                  "    capture_index: Cell::new(0),",
                  "    nest_limit: 10,",
                  "    octal: true,",
                  "    initial_ignore_whitespace: false,",
                  "    ignore_whitespace: Cell::new(false),",
                  "    comments: RefCell::new(vec![]),",
                  "    stack_group: RefCell::new(vec![]),",
                  "    stack_class: RefCell::new(vec![]),",
                  "    capture_names: RefCell::new(vec![]),",
                  "    scratch: RefCell::new(String::new()),",
                  "    },",
                  "    pattern: r\"\\D\",",
                  "    };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(result.span.start < result.span.end);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5376:28\n     |\n5376 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5376 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5393:20\n     |\n5393 |     pos: Cell::new(Position::new(0)),\n     |                    ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5393 |     pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5408:29\n     |\n5408 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5376:28\n     |\n5376 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5376 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5393:20\n     |\n5393 |     pos: Cell::new(Position::new(0)),\n     |                    ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5393 |     pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5376:28\n     |\n5376 |             pos: Cell::new(Position::new(0)),\n     |                            ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5376 |             pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 3 arguments but 1 argument was supplied\n    --> regex-syntax/src/ast/parse.rs:5393:20\n     |\n5393 |     pos: Cell::new(Position::new(0)),\n     |                    ^^^^^^^^^^^^^--- two arguments of type `usize` and `usize` are missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/ast/mod.rs:438:12\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |            ^^^ -------------  -----------  -------------\nhelp: provide the arguments\n     |\n5393 |     pos: Cell::new(Position::new(0, /* usize */, /* usize */)),\n     |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: c matches 'd' is true\n",
        "// constraint: c matches 'd' is true\n",
        "// expected return value/type: ast::ClassPerl { span: span, kind: kind, negated: negated }\n"
      ],
      "input_infer": "Test input ranges: c in ['d', 'D', 's', 'S', 'w', 'W']\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                "        pattern: \"\\\\d\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\d\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5380:29\n     |\n5380 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                "        pattern: \"\\\\D\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(c, 'D');"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(parser.parse_perl_class().negated, true);"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(parser.parse_perl_class().kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(parser.parse_perl_class().span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(c, 'D');",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(parser.parse_perl_class().negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(parser.parse_perl_class().kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\D\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let c = parser.char();",
                  "    let span = parser.span_char();",
                  "    parser.bump();",
                  "    assert_eq!(parser.parse_perl_class().span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5381:48\n     |\n5381 |     assert_eq!(parser.parse_perl_class().kind, ClassPerlKind::Digit);\n     |                                                ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                "        pattern: \"\\\\s\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\s\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5380:29\n     |\n5380 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5384:29\n     |\n5384 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5386:29\n     |\n5386 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5390:29\n     |\n5390 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                "        pattern: \"\\\\S\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\S\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5380:29\n     |\n5380 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5384:29\n     |\n5384 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5386:29\n     |\n5386 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5390:29\n     |\n5390 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                "        pattern: \"\\\\w\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let result = panic::catch_unwind(|| {",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\x\" };",
                  "    parser.parse_perl_class();",
                  "    });",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Space);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.span, expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\w\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\D\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\s\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\S\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\w\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let result = panic::catch_unwind(|| {",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\x\" };",
                  "    parser.parse_perl_class();",
                  "    });",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_span` in this scope\n    --> regex-syntax/src/ast/parse.rs:5380:29\n     |\n5380 |     assert_eq!(result.span, expected_span);\n     |                             ^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5380:29\n     |\n5380 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_span` in this scope\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     assert_eq!(result.span, expected_span);\n     |                             ^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_span` in this scope\n    --> regex-syntax/src/ast/parse.rs:5384:29\n     |\n5384 |     assert_eq!(result.span, expected_span);\n     |                             ^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5384:29\n     |\n5384 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_span` in this scope\n    --> regex-syntax/src/ast/parse.rs:5386:29\n     |\n5386 |     assert_eq!(result.span, expected_span);\n     |                             ^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5386:29\n     |\n5386 |     assert_eq!(result.kind, ClassPerlKind::Space);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_span` in this scope\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |     assert_eq!(result.span, expected_span);\n     |                             ^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5388:29\n     |\n5388 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `expected_span` in this scope\n    --> regex-syntax/src/ast/parse.rs:5390:29\n     |\n5390 |     assert_eq!(result.span, expected_span);\n     |                             ^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5390:29\n     |\n5390 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `panic`\n    --> regex-syntax/src/ast/parse.rs:5390:18\n     |\n5390 |     let result = panic::catch_unwind(|| {\n     |                  ^^^^^ use of undeclared crate or module `panic`\n     |\nhelp: consider importing this module\n     |\n5368 +    use std::panic;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5382:70\n     |\n5382 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5384:70\n     |\n5384 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5386:70\n     |\n5386 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5388:70\n     |\n5388 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5391:70\n     |\n5391 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                "        pattern: \"\\\\W\",",
                "    };",
                "    parser.parse_perl_class();",
                "}"
              ],
              "oracles": [
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(\"expected valid Perl class but got 'D'\" != panic!(\"{}\", parser.char()) );"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);"
                ],
                [
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Digit);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, false);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert!(\"expected valid Perl class but got 'D'\" != panic!(\"{}\", parser.char()) );",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.kind, ClassPerlKind::Word);",
                  "}"
                ],
                [
                  "{",
                  "    let parser = ParserI {",
                  "        parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) },",
                  "        pattern: \"\\\\W\",",
                  "    };",
                  "    parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\d\" };",
                  "    let result = parser.parse_perl_class();",
                  "    let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"\\\\W\" };",
                  "    let result = parser.parse_perl_class();",
                  "    assert_eq!(result.negated, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5380:29\n     |\n5380 |     assert_eq!(result.kind, ClassPerlKind::Digit);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: unreachable expression\n    --> regex-syntax/src/ast/parse.rs:5380:13\n     |\n5380 |     assert!(\"expected valid Perl class but got 'D'\" != panic!(\"{}\", parser.char()) );\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---------------------------\n     |             |                                          |\n     |             |                                          any code following this expression is unreachable\n     |             unreachable expression\n     |\n     = note: `#[warn(unreachable_code)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/ast/parse.rs:5382:29\n     |\n5382 |     assert_eq!(result.kind, ClassPerlKind::Word);\n     |                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n5368 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/ast/parse.rs:5369:8\n     |\n5369 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5374:51\n     |\n5374 | ...   parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whi...\n     |                                                 ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5378:70\n     |\n5378 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Position` in the current scope\n    --> regex-syntax/src/ast/parse.rs:5380:70\n     |\n5380 |     let parser = ParserI { parser: Parser { pos: Cell::new(Position::default()), capture_index: Cell::new(0), nest_limit: 10, octal: fals...\n     |                                                                      ^^^^^^^ function or associated item not found in `Position`\n     |\n    ::: regex-syntax/src/ast/mod.rs:363:1\n     |\n363  | pub struct Position {\n     | ------------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Position`, consider using `ast::Position::new` which returns `ast::Position`\n    --> regex-syntax/src/ast/mod.rs:438:5\n     |\n438  |     pub fn new(offset: usize, line: usize, column: usize) -> Position {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}