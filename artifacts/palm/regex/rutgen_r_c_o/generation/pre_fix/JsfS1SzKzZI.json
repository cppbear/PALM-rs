{
  "name": "regex_syntax::ast::visitor::ast::visitor::HeapVisitor<'a>::visit_class",
  "name_with_impl": "regex_syntax::ast::visitor::{impl#0}::visit_class",
  "mod_info": {
    "name": "ast::visitor",
    "loc": "regex-syntax/src/ast/mod.rs:23:1:23:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/visitor.rs:330:5:368:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.visit_class_pre(&ast, visitor)? is Err/None\n"
      ],
      "input_infer": "1 <= ast.kind <= 10000, 0 <= self.stack_class.len() <= 1000, 0 <= visitor.return_value <= 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = TestVisitor::new();",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 1),",
                "        negated: false,",
                "        kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)),",
                "    };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 1),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:35\n    |\n569 |         kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)),\n    |               ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassSetItem`, found `Box<fn(...) -> ... {ClassSetItem::Empty}>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected enum `ClassSetItem`\n             found struct `Box<fn(Span) -> ClassSetItem {ClassSetItem::Empty}>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:933:5\n    |\n933 |     Item(ClassSetItem),\n    |     ^^^^\nhelp: use parentheses to construct this tuple variant\n    |\n569 |         kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)(/* Span */)),\n    |                                                                     ++++++++++++\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:31\n    |\n577 |     kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)),\n    |           ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ClassSetItem`, found `Box<fn(...) -> ... {ClassSetItem::Empty}>`\n    |           |\n    |           arguments to this enum variant are incorrect\n    |\n    = note: expected enum `ClassSetItem`\n             found struct `Box<fn(Span) -> ClassSetItem {ClassSetItem::Empty}>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:933:5\n    |\n933 |     Item(ClassSetItem),\n    |     ^^^^\nhelp: use parentheses to construct this tuple variant\n    |\n577 |     kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Empty)(/* Span */)),\n    |                                                                 ++++++++++++\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = TestVisitor::new();",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 3),",
                "        negated: false,",
                "        kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                "    };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 3),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 3),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 3),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 3),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 3),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:63\n    |\n569 |         kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:19\n    |\n573 |     let visitor = TestVisitor::new();\n    |                   ^^^^^^^^^^^\n    |                   |\n    |                   use of undeclared type `TestVisitor`\n    |                   help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:59\n    |\n577 |     kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),\n    |                                                           ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = TestVisitor::new();",
                "    let item1 = ast::ClassSetItem::Single('a');",
                "    let item2 = ast::ClassSetItem::Single('b');",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 5),",
                "        negated: false,",
                "        kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),",
                "    };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = TestVisitor::new();",
                  "    let item1 = ast::ClassSetItem::Single('a');",
                  "    let item2 = ast::ClassSetItem::Single('b');",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_err());"
                ],
                [
                  "    let mut visitor = TestVisitor::new();",
                  "    let item1 = ast::ClassSetItem::Single('a');",
                  "    let item2 = ast::ClassSetItem::Single('b');",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.calls.len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let item1 = ast::ClassSetItem::Single('a');",
                  "    let item2 = ast::ClassSetItem::Single('b');",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 5),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let mut visitor = TestVisitor::new();",
                  "    let item1 = ast::ClassSetItem::Single('a');",
                  "    let item2 = ast::ClassSetItem::Single('b');",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let item1 = ast::ClassSetItem::Single('a');",
                  "    let item2 = ast::ClassSetItem::Single('b');",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 5),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let mut visitor = TestVisitor::new();",
                  "    let item1 = ast::ClassSetItem::Single('a');",
                  "    let item2 = ast::ClassSetItem::Single('b');",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(visitor.calls.len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:566:36\n    |\n566 |     let item1 = ast::ClassSetItem::Single('a');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:36\n    |\n567 |     let item2 = ast::ClassSetItem::Single('b');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:571:30\n    |\n571 |         kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),\n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n571 |         kind: ast::ClassSet::union(vec![Box::new(item1), Box::new(item2)]),\n    |                              ~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:36\n    |\n576 |     let item1 = ast::ClassSetItem::Single('a');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:36\n    |\n577 |     let item2 = ast::ClassSetItem::Single('b');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:581:26\n    |\n581 |     kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),\n    |                          ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n581 |     kind: ast::ClassSet::union(vec![Box::new(item1), Box::new(item2)]),\n    |                          ~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:566:36\n    |\n566 |     let item1 = ast::ClassSetItem::Single('a');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:36\n    |\n567 |     let item2 = ast::ClassSetItem::Single('b');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:571:30\n    |\n571 |         kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),\n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n571 |         kind: ast::ClassSet::union(vec![Box::new(item1), Box::new(item2)]),\n    |                              ~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:36\n    |\n576 |     let item1 = ast::ClassSetItem::Single('a');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:36\n    |\n577 |     let item2 = ast::ClassSetItem::Single('b');\n    |                                    ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:581:26\n    |\n581 |     kind: ast::ClassSet::Union(vec![Box::new(item1), Box::new(item2)]),\n    |                          ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n581 |     kind: ast::ClassSet::union(vec![Box::new(item1), Box::new(item2)]),\n    |                          ~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = TestVisitor::new();",
                "    let lhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')));",
                "    let rhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')));",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 6),",
                "        negated: false,",
                "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                "            span: Span::new(0, 6),",
                "            kind: ast::ClassSetBinaryOpKind::Union,",
                "            lhs: Box::new(lhs),",
                "            rhs: Box::new(rhs),",
                "        })),",
                "    };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = TestVisitor::new();",
                  "    let lhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')));",
                  "    let rhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')));",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 6),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "    span: Span::new(0, 6),",
                  "    kind: ast::ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    })),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let lhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')));",
                  "    let rhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')));",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 6),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 6),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        })),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let mut visitor = TestVisitor::new();",
                  "    let lhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')));",
                  "    let rhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')));",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 6),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "    span: Span::new(0, 6),",
                  "    kind: ast::ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    })),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 6),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |             span: Span::new(0, 6),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::new(0, 6),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::new(0, 6),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:566:63\n    |\n566 |     let lhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')));\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:63\n    |\n567 |     let rhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')));\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:573:46\n     |\n573  |             kind: ast::ClassSetBinaryOpKind::Union,\n     |                                              ^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `Union` not found for this enum\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:39\n    |\n571 |           kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {\n    |  _______________-----------------------_^\n    | |               |\n    | |               arguments to this enum variant are incorrect\n572 | |             span: Span::new(0, 6),\n573 | |             kind: ast::ClassSetBinaryOpKind::Union,\n574 | |             lhs: Box::new(lhs),\n575 | |             rhs: Box::new(rhs),\n576 | |         })),\n    | |__________^ expected `ClassSetBinaryOp`, found `Box<ClassSetBinaryOp>`\n    |\n    = note: expected struct `ClassSetBinaryOp`\n               found struct `Box<ClassSetBinaryOp>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:935:5\n    |\n935 |     BinaryOp(ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider unboxing the value\n    |\n571 |         kind: ast::ClassSet::BinaryOp(*Box::new(ast::ClassSetBinaryOp {\n    |                                       +\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:581:63\n    |\n581 |     let lhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a')));\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:63\n    |\n582 |     let rhs = ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('b')));\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSetBinaryOpKind` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:588:38\n     |\n588  |     kind: ast::ClassSetBinaryOpKind::Union,\n     |                                      ^^^^^ variant or associated item not found in `ClassSetBinaryOpKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1088:1\n     |\n1088 | pub enum ClassSetBinaryOpKind {\n     | ----------------------------- variant or associated item `Union` not found for this enum\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:35\n    |\n586 |       kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {\n    |  ___________-----------------------_^\n    | |           |\n    | |           arguments to this enum variant are incorrect\n587 | |     span: Span::new(0, 6),\n588 | |     kind: ast::ClassSetBinaryOpKind::Union,\n589 | |     lhs: Box::new(lhs),\n590 | |     rhs: Box::new(rhs),\n591 | |     })),\n    | |______^ expected `ClassSetBinaryOp`, found `Box<ClassSetBinaryOp>`\n    |\n    = note: expected struct `ClassSetBinaryOp`\n               found struct `Box<ClassSetBinaryOp>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:935:5\n    |\n935 |     BinaryOp(ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider unboxing the value\n    |\n586 |     kind: ast::ClassSet::BinaryOp(*Box::new(ast::ClassSetBinaryOp {\n    |                                   +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = TestVisitor::new();",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 4),",
                "        negated: true,",
                "        kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                "    };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 4),",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 4),",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert_eq!(result.err(), Some(ExpectedError));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 4),",
                  "        negated: true,",
                  "        kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 4),",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 4),",
                  "        negated: true,",
                  "        kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let mut visitor = TestVisitor::new();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 4),",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert_eq!(result.err(), Some(ExpectedError));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 4),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 4),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:63\n    |\n569 |         kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:59\n    |\n577 |     kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),\n    |                                                           ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 4),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 4),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `ExpectedError` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:35\n    |\n581 |     assert_eq!(result.err(), Some(ExpectedError));\n    |                                   ^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:63\n    |\n569 |         kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:59\n    |\n577 |     kind: ast::ClassSet::Item(Box::new(ast::ClassSetItem::Single('a'))),\n    |                                                           ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = TestVisitor::new();",
                "    let items: Vec<_> = (1..=1000).map(|i| ast::ClassSetItem::Single(char::from(i))) ",
                "                                     .collect();",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 1000),",
                "        negated: false,",
                "        kind: ast::ClassSet::Union(items.into_iter().map(Box::new).collect()),",
                "    };",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = TestVisitor::new();",
                  "    let items: Vec<_> = (1..=1000).map(|i| ast::ClassSetItem::Single(char::from(i))).collect();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 1000),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(items.into_iter().map(Box::new).collect()),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = TestVisitor::new();",
                  "    let items: Vec<_> = (1..=1000).map(|i| ast::ClassSetItem::Single(char::from(i))) ",
                  "                                     .collect();",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 1000),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union(items.into_iter().map(Box::new).collect()),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&ast, &mut visitor);",
                  "    let mut visitor = TestVisitor::new();",
                  "    let items: Vec<_> = (1..=1000).map(|i| ast::ClassSetItem::Single(char::from(i))).collect();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 1000),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(items.into_iter().map(Box::new).collect()),",
                  "    };",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&ast, &mut visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 1000),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:11\n    |\n578 |     span: Span::new(0, 1000),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:566:63\n    |\n566 |     let items: Vec<_> = (1..=1000).map(|i| ast::ClassSetItem::Single(char::from(i))) \n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:571:30\n    |\n571 |         kind: ast::ClassSet::Union(items.into_iter().map(Box::new).collect()),\n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n571 |         kind: ast::ClassSet::union(items.into_iter().map(Box::new).collect()),\n    |                              ~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `TestVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = TestVisitor::new();\n    |                       ^^^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `TestVisitor`\n    |                       help: a struct with a similar name exists: `HeapVisitor`\n\nerror[E0599]: no variant or associated item named `Single` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:63\n    |\n576 |     let items: Vec<_> = (1..=1000).map(|i| ast::ClassSetItem::Single(char::from(i))).collect();\n    |                                                               ^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Single` not found for this enum\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     kind: ast::ClassSet::Union(items.into_iter().map(Box::new).collect()),\n    |                          ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n580 |     kind: ast::ClassSet::union(items.into_iter().map(Box::new).collect()),\n    |                          ~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.visit_class_pre(&ast, visitor)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct_class(&ast) is true\n",
        "// constraint: self.visit_class_post(&ast, visitor)? is Err/None\n"
      ],
      "input_infer": "test input ranges: ast: ClassBracketed with valid spans, negated: true, kind: ClassSetBinaryOp with valid lhs and rhs returning Some in induct_class, visitor: compatible Visitor implementation with no errors on visit_class_pre but returns Err/None on visit_class_post\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let class_set_binary_op = ClassSetBinaryOp {",
                "        span: Span::new(0, 5),",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                "            span: span.clone(),",
                "            negated: false,",
                "            kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                "        }))),",
                "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                "    };",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: true,",
                "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                "    };",
                "",
                "    struct TestVisitor;",
                "    impl Visitor for TestVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                "            Ok(())",
                "        }",
                "    };",
                "",
                "    let mut visitor = TestVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 5),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "    }))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    assert!(self.visit_class_pre(&ast, visitor).is_ok());"
                ],
                [
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 5),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "    }))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    assert!(self.induct_class(&ast).is_some());"
                ],
                [
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 5),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "    }))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    assert!(self.visit_class_post(&ast, visitor).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 5),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "            span: span.clone(),",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "        }))),",
                  "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 5),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "    }))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    assert!(self.visit_class_pre(&ast, visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 5),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "            span: span.clone(),",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "        }))),",
                  "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 5),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "    }))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    assert!(self.induct_class(&ast).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "        span: Span::new(0, 5),",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "            span: span.clone(),",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "        }))),",
                  "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(0, 5);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(0, 5),",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),",
                  "    }))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    assert!(self.visit_class_post(&ast, visitor).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:67\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                   ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |             kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:27\n    |\n576 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:579:15\n    |\n579 |         kind: ClassSet::BinaryOp(class_set_binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:56\n    |\n587 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:31\n    |\n596 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:597:11\n    |\n597 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:63\n    |\n599 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                               ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:11\n    |\n602 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:19\n    |\n604 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:606:27\n    |\n606 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:609:11\n    |\n609 |     kind: ClassSet::BinaryOp(class_set_binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:611:13\n    |\n563 | fn test_visit_class_08()\n    |    ------------------- this function can't have a `self` parameter\n...\n611 |     assert!(self.visit_class_pre(&ast, visitor).is_ok());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:611:35\n    |\n611 |     assert!(self.visit_class_pre(&ast, visitor).is_ok());\n    |                                   ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:590:6\n    |\n590 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n583 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:572:61\n    |\n572 |             kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:65\n    |\n574 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:53\n    |\n602 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                          -------------------------- ^^^ expected `Literal`, found `char`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:604:61\n    |\n604 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0423, E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:67\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                   ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |             kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:27\n    |\n576 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:579:15\n    |\n579 |         kind: ClassSet::BinaryOp(class_set_binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:56\n    |\n587 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:31\n    |\n596 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:597:11\n    |\n597 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:63\n    |\n599 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                               ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:11\n    |\n602 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:19\n    |\n604 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:606:27\n    |\n606 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:609:11\n    |\n609 |     kind: ClassSet::BinaryOp(class_set_binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:611:13\n    |\n563 | fn test_visit_class_09()\n    |    ------------------- this function can't have a `self` parameter\n...\n611 |     assert!(self.induct_class(&ast).is_some());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:611:32\n    |\n611 |     assert!(self.induct_class(&ast).is_some());\n    |                                ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:590:6\n    |\n590 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n583 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:572:61\n    |\n572 |             kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:65\n    |\n574 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:53\n    |\n602 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                          -------------------------- ^^^ expected `Literal`, found `char`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:604:61\n    |\n604 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0423, E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:67\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                   ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |             kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:27\n    |\n576 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:579:15\n    |\n579 |         kind: ClassSet::BinaryOp(class_set_binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:56\n    |\n587 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:31\n    |\n596 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:597:11\n    |\n597 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:63\n    |\n599 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                               ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:11\n    |\n602 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:19\n    |\n604 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:606:27\n    |\n606 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:609:11\n    |\n609 |     kind: ClassSet::BinaryOp(class_set_binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:611:13\n    |\n563 | fn test_visit_class_10()\n    |    ------------------- this function can't have a `self` parameter\n...\n611 |     assert!(self.visit_class_post(&ast, visitor).is_err());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:611:36\n    |\n611 |     assert!(self.visit_class_post(&ast, visitor).is_err());\n    |                                    ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:590:6\n    |\n590 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n583 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:572:61\n    |\n572 |             kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:65\n    |\n574 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:53\n    |\n602 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('a')),\n    |                          -------------------------- ^^^ expected `Literal`, found `char`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:604:61\n    |\n604 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0423, E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(5, 10);",
                "    let class_set_binary_op = ClassSetBinaryOp {",
                "        span: Span::new(5, 10),",
                "        kind: ClassSetBinaryOpKind::Binary,",
                "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                "    };",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: true,",
                "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                "    };",
                "",
                "    struct TestVisitor;",
                "    impl Visitor for TestVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                "            Err(())",
                "        }",
                "    };",
                "",
                "    let mut visitor = TestVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Binary,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_pre(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_ok());"
                ],
                [
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Binary,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).is_some());"
                ],
                [
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Binary,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "        span: Span::new(5, 10),",
                  "        kind: ClassSetBinaryOpKind::Binary,",
                  "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Err(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Binary,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_pre(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "        span: Span::new(5, 10),",
                  "        kind: ClassSetBinaryOpKind::Binary,",
                  "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Err(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Binary,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "        span: Span::new(5, 10),",
                  "        kind: ClassSetBinaryOpKind::Binary,",
                  "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Err(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(5, 10);",
                  "    let class_set_binary_op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Binary,",
                  "    lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),",
                  "    rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::BinaryOp(class_set_binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(5, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(5, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Binary,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:27\n    |\n572 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:15\n    |\n575 |         kind: ClassSet::BinaryOp(class_set_binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:56\n    |\n583 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:16\n    |\n591 |     let span = Span::new(5, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:31\n    |\n592 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:593:11\n    |\n593 |     span: Span::new(5, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     kind: ClassSetBinaryOpKind::Binary,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:595:19\n    |\n595 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:19\n    |\n596 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:598:27\n    |\n598 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:11\n    |\n601 |     kind: ClassSet::BinaryOp(class_set_binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:586:6\n    |\n586 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:579:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n579 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:65\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:65\n    |\n570 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:595:61\n    |\n595 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:61\n    |\n596 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(5, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(5, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Binary,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:27\n    |\n572 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:15\n    |\n575 |         kind: ClassSet::BinaryOp(class_set_binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:56\n    |\n583 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:16\n    |\n591 |     let span = Span::new(5, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:31\n    |\n592 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:593:11\n    |\n593 |     span: Span::new(5, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     kind: ClassSetBinaryOpKind::Binary,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:595:19\n    |\n595 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:19\n    |\n596 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:598:27\n    |\n598 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:11\n    |\n601 |     kind: ClassSet::BinaryOp(class_set_binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:586:6\n    |\n586 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:579:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n579 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:65\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:65\n    |\n570 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:595:61\n    |\n595 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:61\n    |\n596 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(5, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(5, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Binary,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:27\n    |\n572 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:15\n    |\n575 |         kind: ClassSet::BinaryOp(class_set_binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:56\n    |\n583 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:16\n    |\n591 |     let span = Span::new(5, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:31\n    |\n592 |     let class_set_binary_op = ClassSetBinaryOp {\n    |                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:593:11\n    |\n593 |     span: Span::new(5, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     kind: ClassSetBinaryOpKind::Binary,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:595:19\n    |\n595 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:19\n    |\n596 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:598:27\n    |\n598 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:11\n    |\n601 |     kind: ClassSet::BinaryOp(class_set_binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:586:6\n    |\n586 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:579:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n579 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:65\n    |\n569 |         lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:65\n    |\n570 |         rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                                      -------------------------- ^^^ expected `Literal`, found `char`\n    |                                      |\n    |                                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:595:61\n    |\n595 |     lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('c'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:61\n    |\n596 |     rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('d'))),\n    |                                  -------------------------- ^^^ expected `Literal`, found `char`\n    |                                  |\n    |                                  arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 3);",
                "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                "        span: span.clone(),",
                "        negated: false,",
                "        kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                "    });",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Item(class_set_item),",
                "    };",
                "",
                "    struct TestVisitor;",
                "    impl Visitor for TestVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "",
                "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                "            Ok(())",
                "        }",
                "    };",
                "",
                "    let mut visitor = TestVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let induct = heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).unwrap();",
                  "    assert_eq!(induct, ClassFrame::Union { head: &ast::ClassSetItem::Literal('e'), tail: &[] });"
                ],
                [
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let induct = heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).unwrap();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), induct));",
                  "    assert!(heap_visitor.visit_class_pre(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_ok());"
                ],
                [
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let induct = heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).unwrap();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), induct));",
                  "    assert!(heap_visitor.visit_class_post(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "        span: span.clone(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let induct = heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).unwrap();",
                  "    assert_eq!(induct, ClassFrame::Union { head: &ast::ClassSetItem::Literal('e'), tail: &[] });",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "        span: span.clone(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let induct = heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).unwrap();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), induct));",
                  "    assert!(heap_visitor.visit_class_pre(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "        span: span.clone(),",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "",
                  "    struct TestVisitor;",
                  "    impl Visitor for TestVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "",
                  "        fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
                  "            Ok(())",
                  "        }",
                  "    };",
                  "",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap_err();",
                  "    let span = Span::new(0, 3);",
                  "    let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {",
                  "    span: span.clone(),",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),",
                  "    });",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(class_set_item),",
                  "    };",
                  "    let mut visitor = TestVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let induct = heap_visitor.induct_class(&ClassInduct::from_bracketed(&class_bracketed)).unwrap();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), induct));",
                  "    assert!(heap_visitor.visit_class_post(&ClassInduct::from_bracketed(&class_bracketed), &mut visitor).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 3);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:55\n    |\n566 |     let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:15\n    |\n574 |         kind: ClassSet::Item(class_set_item),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:56\n    |\n582 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:590:16\n    |\n590 |     let span = Span::new(0, 3);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:55\n    |\n591 |     let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSet::Item(class_set_item),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:585:6\n    |\n585 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n578 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:57\n    |\n569 |         kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |                              -------------------------- ^^^ expected `Literal`, found `char`\n    |                              |\n    |                              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:53\n    |\n594 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |                          -------------------------- ^^^ expected `Literal`, found `char`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:604:78\n    |\n604 |     assert_eq!(induct, ClassFrame::Union { head: &ast::ClassSetItem::Literal('e'), tail: &[] });\n    |                                                   -------------------------- ^^^ expected `Literal`, found `char`\n    |                                                   |\n    |                                                   arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:604:5\n    |\n604 |     assert_eq!(induct, ClassFrame::Union { head: &ast::ClassSetItem::Literal('e'), tail: &[] });\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassFrame<'_>\n    |     ast::visitor::ClassFrame<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassFrame<'_>>` might be missing for `ast::visitor::ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassFrame<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0369, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 3);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:55\n    |\n566 |     let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:15\n    |\n574 |         kind: ClassSet::Item(class_set_item),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:56\n    |\n582 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:590:16\n    |\n590 |     let span = Span::new(0, 3);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:55\n    |\n591 |     let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSet::Item(class_set_item),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:585:6\n    |\n585 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n578 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:57\n    |\n569 |         kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |                              -------------------------- ^^^ expected `Literal`, found `char`\n    |                              |\n    |                              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:53\n    |\n594 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |                          -------------------------- ^^^ expected `Literal`, found `char`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 3);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:55\n    |\n566 |     let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:574:15\n    |\n574 |         kind: ClassSet::Item(class_set_item),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:56\n    |\n582 |         fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:590:16\n    |\n590 |     let span = Span::new(0, 3);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:591:55\n    |\n591 |     let class_set_item = ast::ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSet::Item(class_set_item),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unnecessary trailing semicolon\n   --> regex-syntax/src/ast/visitor.rs:585:6\n    |\n585 |     };\n    |      ^ help: remove this semicolon\n    |\n    = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n578 |     impl Visitor for TestVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:57\n    |\n569 |         kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |                              -------------------------- ^^^ expected `Literal`, found `char`\n    |                              |\n    |                              arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:53\n    |\n594 |     kind: ClassSet::Item(ast::ClassSetItem::Literal('e')),\n    |                          -------------------------- ^^^ expected `Literal`, found `char`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0308, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.visit_class_pre(&ast, visitor)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct_class(&ast) is true\n",
        "// constraint: self.visit_class_post(&ast, visitor)? is Ok/Some\n",
        "// constraint: self.stack_class.pop() matches Some((post_ast, frame)) is true\n",
        "// constraint: let Some(x) = self.pop_class(frame) is true\n",
        "// constraint: self.visit_class_post(&post_ast, visitor)? is Err/None\n"
      ],
      "input_infer": "1 <= ast.span <= 10, ast.negated in [true, false], ast.kind in [normal, binary], self.stack_class.size in [1, 5], frame type in [Union, Binary], V::Output in [Ok, Err], V::Err is non-empty\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "struct MockVisitor {",
            "    result: Result<(), String>,",
            "}",
            "",
            "impl MockVisitor {",
            "    fn new(result: Result<(), String>) -> Self {",
            "        MockVisitor { result }",
            "    }",
            "}",
            "",
            "impl Visitor for MockVisitor {",
            "    type Output = ();",
            "    type Err = String;",
            "",
            "    fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {",
            "        Ok(())",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 5);",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                "            span,",
                "            negated: false,",
                "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                "        })),",
                "    };",
                "    ",
                "    let mut visitor = MockVisitor::new(Ok(()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::Union { head: &class_bracketed.kind, tail: &[] }));",
                "",
                "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 5);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    })),",
                  "    };",
                  "    assert!(visitor.result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 5);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "            span,",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "        })),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::Union { head: &class_bracketed.kind, tail: &[] }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let span = Span::new(1, 5);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    })),",
                  "    };",
                  "    assert!(visitor.result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:27\n    |\n585 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:54\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:600:16\n    |\n600 |     let span = Span::new(1, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:11\n    |\n604 |     kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:26\n    |\n604 |     kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:604:50\n    |\n604 |     kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                  ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:607:11\n    |\n607 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:607:26\n    |\n607 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:607:48\n    |\n607 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(2, 8);",
                "    let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                "    }));",
                "    let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),",
                "    }));",
                "    let binary_op = ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(left),",
                "        rhs: Box::new(right),",
                "    };",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::BinaryOp(binary_op),",
                "    };",
                "",
                "    let mut visitor = MockVisitor::new(Ok(()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::BinaryLHS { op: &binary_op, lhs: &binary_op.lhs, rhs: &binary_op.rhs }));",
                "",
                "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    assert!(induct_result.is_some());"
                ],
                [
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    assert!(post_visit_result.is_ok());"
                ],
                [
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    let pop_result = heap_visitor.stack_class.pop();",
                  "    assert!(pop_result.is_some());"
                ],
                [
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    let pop_result = heap_visitor.stack_class.pop();",
                  "    let pop_class_result = heap_visitor.pop_class(frame);",
                  "    assert!(pop_class_result.is_some());"
                ],
                [
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    let pop_result = heap_visitor.stack_class.pop();",
                  "    let pop_class_result = heap_visitor.pop_class(frame);",
                  "    let post_visit_post_result = heap_visitor.visit_class_post(&post_ast, &mut mock_visitor);",
                  "    assert!(post_visit_post_result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(2, 8);",
                  "    let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    }));",
                  "    let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),",
                  "    }));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(left),",
                  "        rhs: Box::new(right),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::BinaryLHS { op: &binary_op, lhs: &binary_op.lhs, rhs: &binary_op.rhs }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(2, 8);",
                  "    let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    }));",
                  "    let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),",
                  "    }));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(left),",
                  "        rhs: Box::new(right),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::BinaryLHS { op: &binary_op, lhs: &binary_op.lhs, rhs: &binary_op.rhs }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    assert!(induct_result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(2, 8);",
                  "    let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    }));",
                  "    let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),",
                  "    }));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(left),",
                  "        rhs: Box::new(right),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::BinaryLHS { op: &binary_op, lhs: &binary_op.lhs, rhs: &binary_op.rhs }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    assert!(post_visit_result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(2, 8);",
                  "    let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    }));",
                  "    let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),",
                  "    }));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(left),",
                  "        rhs: Box::new(right),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::BinaryLHS { op: &binary_op, lhs: &binary_op.lhs, rhs: &binary_op.rhs }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    let pop_result = heap_visitor.stack_class.pop();",
                  "    assert!(pop_result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(2, 8);",
                  "    let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    }));",
                  "    let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),",
                  "    }));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(left),",
                  "        rhs: Box::new(right),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::BinaryLHS { op: &binary_op, lhs: &binary_op.lhs, rhs: &binary_op.rhs }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    let pop_result = heap_visitor.stack_class.pop();",
                  "    let pop_class_result = heap_visitor.pop_class(frame);",
                  "    assert!(pop_class_result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(2, 8);",
                  "    let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),",
                  "    }));",
                  "    let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),",
                  "    }));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(left),",
                  "        rhs: Box::new(right),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::BinaryLHS { op: &binary_op, lhs: &binary_op.lhs, rhs: &binary_op.rhs }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let mock_visitor = MockVisitor::new(Ok(()));",
                  "    let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);",
                  "    let induct_result = heap_visitor.induct_class(&ast);",
                  "    let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);",
                  "    let pop_result = heap_visitor.stack_class.pop();",
                  "    let pop_class_result = heap_visitor.pop_class(frame);",
                  "    let post_visit_post_result = heap_visitor.visit_class_post(&post_ast, &mut mock_visitor);",
                  "    assert!(post_visit_post_result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(2, 8);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:31\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:55\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:52\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                        ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:593:15\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:593:30\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:52\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:21\n    |\n595 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:15\n    |\n604 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:613:48\n    |\n613 |     let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);\n    |                                                ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(2, 8);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:31\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:55\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:52\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                        ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:593:15\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:593:30\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:52\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:21\n    |\n595 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:15\n    |\n604 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:613:48\n    |\n613 |     let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);\n    |                                                ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:614:52\n    |\n614 |     let induct_result = heap_visitor.induct_class(&ast);\n    |                                                    ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(2, 8);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:31\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:55\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:52\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                        ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:593:15\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:593:30\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:52\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:21\n    |\n595 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:15\n    |\n604 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:613:48\n    |\n613 |     let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);\n    |                                                ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:614:52\n    |\n614 |     let induct_result = heap_visitor.induct_class(&ast);\n    |                                                    ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:615:60\n    |\n615 |     let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);\n    |                                                            ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(2, 8);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:31\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:55\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:52\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                        ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:593:15\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:593:30\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:52\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:21\n    |\n595 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:15\n    |\n604 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:613:48\n    |\n613 |     let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);\n    |                                                ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:614:52\n    |\n614 |     let induct_result = heap_visitor.induct_class(&ast);\n    |                                                    ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:615:60\n    |\n615 |     let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);\n    |                                                            ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(2, 8);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:31\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:55\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:52\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                        ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:593:15\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:593:30\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:52\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:21\n    |\n595 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:15\n    |\n604 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:613:48\n    |\n613 |     let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);\n    |                                                ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:614:52\n    |\n614 |     let induct_result = heap_visitor.induct_class(&ast);\n    |                                                    ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:615:60\n    |\n615 |     let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);\n    |                                                            ^^^ not a value\n\nerror[E0425]: cannot find value `frame` in this scope\n   --> regex-syntax/src/ast/visitor.rs:617:51\n    |\n617 |     let pop_class_result = heap_visitor.pop_class(frame);\n    |                                                   ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(2, 8);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:31\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:55\n    |\n585 |     let left = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                       ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:52\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:590:32\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |     let right = ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                        ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:593:15\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:593:30\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:593:52\n    |\n593 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:21\n    |\n595 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:15\n    |\n604 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:613:48\n    |\n613 |     let result = heap_visitor.visit_class_pre(&ast, &mut mock_visitor);\n    |                                                ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:614:52\n    |\n614 |     let induct_result = heap_visitor.induct_class(&ast);\n    |                                                    ^^^ not a value\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:615:60\n    |\n615 |     let post_visit_result = heap_visitor.visit_class_post(&ast, &mut mock_visitor);\n    |                                                            ^^^ not a value\n\nerror[E0425]: cannot find value `frame` in this scope\n   --> regex-syntax/src/ast/visitor.rs:617:51\n    |\n617 |     let pop_class_result = heap_visitor.pop_class(frame);\n    |                                                   ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `post_ast` in this scope\n   --> regex-syntax/src/ast/visitor.rs:618:65\n    |\n618 |     let post_visit_post_result = heap_visitor.visit_class_post(&post_ast, &mut mock_visitor);\n    |                                                                 ^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let span = Span::new(3, 6);",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: true,",
                "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                "            span,",
                "            negated: true,",
                "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('c'))),",
                "        })),",
                "    };",
                "",
                "    let mut visitor = MockVisitor::new(Err(\"Error\".to_string()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::Union { head: &class_bracketed.kind, tail: &[] }));",
                "",
                "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 10);",
                "    let class_bracketed_1 = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                "            span,",
                "            negated: false,",
                "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),",
                "        })),",
                "    };",
                "    let class_bracketed_2 = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::BinaryOp(ClassSetBinaryOp {",
                "            span,",
                "            kind: ClassSetBinaryOpKind::Intersect,",
                "            lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),",
                "            rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                "                span,",
                "                negated: false,",
                "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),",
                "            }))),",
                "        }),",
                "    };",
                "    ",
                "    let mut visitor = MockVisitor::new(Ok(()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed_2), ClassFrame::BinaryLHS { op: &class_bracketed_2.kind, lhs: &class_bracketed_2.kind, rhs: &class_bracketed_2.kind }));",
                "",
                "    heap_visitor.visit_class(&class_bracketed_2, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.visit_class_pre(&ast, visitor), Ok(()));"
                ],
                [
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.induct_class(&ast).is_some());"
                ],
                [
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.visit_class_post(&ast, visitor), Ok(()));"
                ],
                [
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.stack_class.pop().is_some());"
                ],
                [
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.pop_class(frame).is_some());"
                ],
                [
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.visit_class_post(&post_ast, visitor), Err(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed_1 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "            span,",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),",
                  "        })),",
                  "    };",
                  "    let class_bracketed_2 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersect,",
                  "            lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),",
                  "            rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "                span,",
                  "                negated: false,",
                  "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),",
                  "            }))),",
                  "        }),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed_2), ClassFrame::BinaryLHS { op: &class_bracketed_2.kind, lhs: &class_bracketed_2.kind, rhs: &class_bracketed_2.kind }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed_2, &mut visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.visit_class_pre(&ast, visitor), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed_1 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "            span,",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),",
                  "        })),",
                  "    };",
                  "    let class_bracketed_2 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersect,",
                  "            lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),",
                  "            rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "                span,",
                  "                negated: false,",
                  "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),",
                  "            }))),",
                  "        }),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed_2), ClassFrame::BinaryLHS { op: &class_bracketed_2.kind, lhs: &class_bracketed_2.kind, rhs: &class_bracketed_2.kind }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed_2, &mut visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.induct_class(&ast).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed_1 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "            span,",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),",
                  "        })),",
                  "    };",
                  "    let class_bracketed_2 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersect,",
                  "            lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),",
                  "            rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "                span,",
                  "                negated: false,",
                  "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),",
                  "            }))),",
                  "        }),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed_2), ClassFrame::BinaryLHS { op: &class_bracketed_2.kind, lhs: &class_bracketed_2.kind, rhs: &class_bracketed_2.kind }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed_2, &mut visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.visit_class_post(&ast, visitor), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed_1 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "            span,",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),",
                  "        })),",
                  "    };",
                  "    let class_bracketed_2 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersect,",
                  "            lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),",
                  "            rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "                span,",
                  "                negated: false,",
                  "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),",
                  "            }))),",
                  "        }),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed_2), ClassFrame::BinaryLHS { op: &class_bracketed_2.kind, lhs: &class_bracketed_2.kind, rhs: &class_bracketed_2.kind }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed_2, &mut visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.stack_class.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed_1 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "            span,",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),",
                  "        })),",
                  "    };",
                  "    let class_bracketed_2 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersect,",
                  "            lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),",
                  "            rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "                span,",
                  "                negated: false,",
                  "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),",
                  "            }))),",
                  "        }),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed_2), ClassFrame::BinaryLHS { op: &class_bracketed_2.kind, lhs: &class_bracketed_2.kind, rhs: &class_bracketed_2.kind }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed_2, &mut visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(self.pop_class(frame).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed_1 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "            span,",
                  "            negated: false,",
                  "            kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),",
                  "        })),",
                  "    };",
                  "    let class_bracketed_2 = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersect,",
                  "            lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),",
                  "            rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {",
                  "                span,",
                  "                negated: false,",
                  "                kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),",
                  "            }))),",
                  "        }),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed_2), ClassFrame::BinaryLHS { op: &class_bracketed_2.kind, lhs: &class_bracketed_2.kind, rhs: &class_bracketed_2.kind }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed_2, &mut visitor).unwrap();",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(self.visit_class_post(&post_ast, visitor), Err(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:29\n    |\n585 |     let class_bracketed_1 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:54\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:29\n    |\n594 |     let class_bracketed_2 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:597:34\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |             kind: ClassSetBinaryOpKind::Intersect,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:600:42\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:601:42\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:66\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                  ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:23\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:38\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:604:60\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:616:16\n    |\n582 | fn test_visit_class_24()\n    |    ------------------- this function can't have a `self` parameter\n...\n616 |     assert_eq!(self.visit_class_pre(&ast, visitor), Ok(()));\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:616:38\n    |\n616 |     assert_eq!(self.visit_class_pre(&ast, visitor), Ok(()));\n    |                                      ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:29\n    |\n585 |     let class_bracketed_1 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:54\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:29\n    |\n594 |     let class_bracketed_2 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:597:34\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |             kind: ClassSetBinaryOpKind::Intersect,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:600:42\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:601:42\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:66\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                  ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:23\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:38\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:604:60\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:616:13\n    |\n582 | fn test_visit_class_25()\n    |    ------------------- this function can't have a `self` parameter\n...\n616 |     assert!(self.induct_class(&ast).is_some());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:616:32\n    |\n616 |     assert!(self.induct_class(&ast).is_some());\n    |                                ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:29\n    |\n585 |     let class_bracketed_1 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:54\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:29\n    |\n594 |     let class_bracketed_2 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:597:34\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |             kind: ClassSetBinaryOpKind::Intersect,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:600:42\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:601:42\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:66\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                  ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:23\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:38\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:604:60\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:616:16\n    |\n582 | fn test_visit_class_26()\n    |    ------------------- this function can't have a `self` parameter\n...\n616 |     assert_eq!(self.visit_class_post(&ast, visitor), Ok(()));\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0423]: expected value, found module `ast`\n   --> regex-syntax/src/ast/visitor.rs:616:39\n    |\n616 |     assert_eq!(self.visit_class_post(&ast, visitor), Ok(()));\n    |                                       ^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0423, E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:29\n    |\n585 |     let class_bracketed_1 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:54\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:29\n    |\n594 |     let class_bracketed_2 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:597:34\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |             kind: ClassSetBinaryOpKind::Intersect,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:600:42\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:601:42\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:66\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                  ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:23\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:38\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:604:60\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:616:13\n    |\n582 | fn test_visit_class_27()\n    |    ------------------- this function can't have a `self` parameter\n...\n616 |     assert!(self.stack_class.pop().is_some());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0424, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:29\n    |\n585 |     let class_bracketed_1 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:54\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:29\n    |\n594 |     let class_bracketed_2 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:597:34\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |             kind: ClassSetBinaryOpKind::Intersect,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:600:42\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:601:42\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:66\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                  ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:23\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:38\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:604:60\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:616:13\n    |\n582 | fn test_visit_class_28()\n    |    ------------------- this function can't have a `self` parameter\n...\n616 |     assert!(self.pop_class(frame).is_some());\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0425]: cannot find value `frame` in this scope\n   --> regex-syntax/src/ast/visitor.rs:616:28\n    |\n616 |     assert!(self.pop_class(frame).is_some());\n    |                            ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0424, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:29\n    |\n585 |     let class_bracketed_1 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:54\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |             kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('x'))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:594:29\n    |\n594 |     let class_bracketed_2 = ClassBracketed {\n    |                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:597:15\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:597:34\n    |\n597 |         kind: ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:19\n    |\n599 |             kind: ClassSetBinaryOpKind::Intersect,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:600:42\n    |\n600 |             lhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(class_bracketed_1))),\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:27\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:601:42\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:601:66\n    |\n601 |             rhs: Box::new(ClassSet::Item(ClassSetItem::Bracketed(ClassBracketed {\n    |                                                                  ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:23\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:604:38\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:604:60\n    |\n604 |                 kind: ClassSet::Item(ClassSetItem::Literal(Literal::from_char('y'))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/ast/visitor.rs:616:16\n    |\n582 | fn test_visit_class_29()\n    |    ------------------- this function can't have a `self` parameter\n...\n616 |     assert_eq!(self.visit_class_post(&post_ast, visitor), Err(None));\n    |                ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0425]: cannot find value `post_ast` in this scope\n   --> regex-syntax/src/ast/visitor.rs:616:39\n    |\n616 |     assert_eq!(self.visit_class_post(&post_ast, visitor), Err(None));\n    |                                       ^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0424, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 5);",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {",
                "            items: vec![],",
                "        })),",
                "    };",
                "    ",
                "    let mut visitor = MockVisitor::new(Ok(()));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::Union { head: &class_bracketed.kind, tail: &[] }));",
                "",
                "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let global_stack_class_len_after = heap_visitor.stack_class.len();",
                  "    assert_eq!(global_stack_class_len_after, 0);"
                ],
                [
                  "    let global_stack_class_len_after = heap_visitor.stack_class.len();",
                  "    let visitor_result = visitor.result;",
                  "    assert!(visitor_result.is_ok());"
                ],
                [
                  "    let global_stack_class_len_after = heap_visitor.stack_class.len();",
                  "    let visitor_result = visitor.result;",
                  "    let visitor_error = visitor_result.err();",
                  "    assert!(visitor_error.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 5);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {",
                  "            items: vec![],",
                  "        })),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::Union { head: &class_bracketed.kind, tail: &[] }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let global_stack_class_len_after = heap_visitor.stack_class.len();",
                  "    assert_eq!(global_stack_class_len_after, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 5);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {",
                  "            items: vec![],",
                  "        })),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::Union { head: &class_bracketed.kind, tail: &[] }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let global_stack_class_len_after = heap_visitor.stack_class.len();",
                  "    let visitor_result = visitor.result;",
                  "    assert!(visitor_result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 5);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {",
                  "            items: vec![],",
                  "        })),",
                  "    };",
                  "    ",
                  "    let mut visitor = MockVisitor::new(Ok(()));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.stack_class.push((ClassInduct::from_bracketed(&class_bracketed), ClassFrame::Union { head: &class_bracketed.kind, tail: &[] }));",
                  "",
                  "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
                  "    let global_stack_class_len_after = heap_visitor.stack_class.len();",
                  "    let visitor_result = visitor.result;",
                  "    let visitor_error = visitor_result.err();",
                  "    assert!(visitor_error.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:27\n    |\n585 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:588:50\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |                                                  ^^^^^^^^^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:27\n    |\n585 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:588:50\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |                                                  ^^^^^^^^^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _op: &ClassSetBinaryOp) -> Result<(), Self::Err> {\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(1, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:27\n    |\n585 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:30\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for MockVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:588:50\n    |\n588 |         kind: ClassSet::Item(ClassSetItem::Union(ast::ClassSetUnion {\n    |                                                  ^^^^^^^^^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0063, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self.visit_class_pre(&ast, visitor)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct_class(&ast) is true\n",
        "// constraint: self.visit_class_post(&ast, visitor)? is Ok/Some\n",
        "// constraint: self.stack_class.pop() matches Some((post_ast, frame)) is true\n",
        "// constraint: let Some(x) = self.pop_class(frame) is true\n",
        "// constraint: self.visit_class_post(&post_ast, visitor)? is Ok/Some\n",
        "// constraint: self.stack_class.pop() matches None is true\n",
        "// constraint: self.stack_class.pop() matches None is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 < ast.len() <= 10, 0 < stack_class.len() <= 5, 1 <= frame <= 3\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = ast::ClassBracketed { ",
                "        span: Span::new(0, 10), ",
                "        negated: false, ",
                "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "            span: Span::new(0, 5), ",
                "            negated: false, ",
                "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                "        }))) ",
                "    };",
                "    let mut visitor = MyVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    ",
                "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());"
                ],
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.induct_class(&ast).is_some());"
                ],
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());"
                ],
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.pop_class(frame).is_some());"
                ],
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());"
                ],
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.stack_class.pop().is_none());"
                ],
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.stack_class.pop().is_none());"
                ],
                [
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.induct_class(&ast).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.pop_class(frame).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.stack_class.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert!(heap_visitor.stack_class.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 10), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "            span: Span::new(0, 5), ",
                  "            negated: false, ",
                  "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
                  "        }))) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    ",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed {",
                  "    span: Span::new(0, 10),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span::new(0, 5),",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
                  "    })))",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
                  "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:42\n    |\n589 |     assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());\n    |                          --------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                          |\n    |                          arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:371:8\n    |\n371 |     fn visit_class_pre<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^\n372 |         &self,\n373 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:39\n    |\n589 |     assert!(heap_visitor.induct_class(&ast).is_some());\n    |                          ------------ ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                          |\n    |                          arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:406:8\n    |\n406 |     fn induct_class(\n    |        ^^^^^^^^^^^^\n407 |         &self,\n408 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:43\n    |\n589 |     assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());\n    |                          ---------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                          |\n    |                          arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:388:8\n    |\n388 |     fn visit_class_post<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^^\n389 |         &self,\n390 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 10), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:19\n    |\n569 |             span: Span::new(0, 5), \n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     span: Span::new(0, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:571:66\n    |\n571 |             kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) \n    |                                       -------------------------- ^^^ expected `Literal`, found `char`\n    |                                       |\n    |                                       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:58\n    |\n584 |     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))\n    |                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                               |\n    |                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = ast::ClassBracketed { ",
                "        span: Span::new(0, 15), ",
                "        negated: false, ",
                "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
                "            items: vec![",
                "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "                    span: Span::new(0, 5), ",
                "                    negated: false, ",
                "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
                "                })),",
                "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "                    span: Span::new(5, 10), ",
                "                    negated: false, ",
                "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
                "                })),",
                "            ]",
                "        }) ",
                "    };",
                "    let mut visitor = MyVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let x = heap_visitor.induct_class(&ast).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((ast, x));",
                  "    ast = child;",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
                  "    let x = heap_visitor.pop_class(frame).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((post_ast, x));",
                  "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
                  "    assert_eq!(heap_visitor.stack_class.pop(), None);"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let x = heap_visitor.induct_class(&ast).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((ast, x));",
                  "    ast = child;",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
                  "    let x = heap_visitor.pop_class(frame).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((post_ast, x));",
                  "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
                  "    assert_eq!(heap_visitor.stack_class.pop(), None);"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let x = heap_visitor.induct_class(&ast).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((ast, x));",
                  "    ast = child;",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
                  "    let x = heap_visitor.pop_class(frame).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((post_ast, x));",
                  "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
                  "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 15), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
                  "            items: vec![",
                  "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "                    span: Span::new(0, 5), ",
                  "                    negated: false, ",
                  "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
                  "                })),",
                  "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "                    span: Span::new(5, 10), ",
                  "                    negated: false, ",
                  "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
                  "                })),",
                  "            ]",
                  "        }) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let x = heap_visitor.induct_class(&ast).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((ast, x));",
                  "    ast = child;",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
                  "    let x = heap_visitor.pop_class(frame).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((post_ast, x));",
                  "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
                  "    assert_eq!(heap_visitor.stack_class.pop(), None);",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 15), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
                  "            items: vec![",
                  "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "                    span: Span::new(0, 5), ",
                  "                    negated: false, ",
                  "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
                  "                })),",
                  "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "                    span: Span::new(5, 10), ",
                  "                    negated: false, ",
                  "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
                  "                })),",
                  "            ]",
                  "        }) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let x = heap_visitor.induct_class(&ast).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((ast, x));",
                  "    ast = child;",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
                  "    let x = heap_visitor.pop_class(frame).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((post_ast, x));",
                  "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
                  "    assert_eq!(heap_visitor.stack_class.pop(), None);",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed { ",
                  "        span: Span::new(0, 15), ",
                  "        negated: false, ",
                  "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
                  "            items: vec![",
                  "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "                    span: Span::new(0, 5), ",
                  "                    negated: false, ",
                  "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
                  "                })),",
                  "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "                    span: Span::new(5, 10), ",
                  "                    negated: false, ",
                  "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
                  "                })),",
                  "            ]",
                  "        }) ",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let x = heap_visitor.induct_class(&ast).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((ast, x));",
                  "    ast = child;",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
                  "    let x = heap_visitor.pop_class(frame).unwrap();",
                  "    let child = x.child();",
                  "    heap_visitor.stack_class.push((post_ast, x));",
                  "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
                  "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 15), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |                     span: Span::new(0, 5), \n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:27\n    |\n576 |                     span: Span::new(5, 10), \n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:43\n    |\n587 |     let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![a...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:203\n    |\n587 | ...m::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Litera...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:366\n    |\n587 | ...m::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Liter...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:30\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { \n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n568 |         kind: ast::ClassSet::union(ast::ClassSetUnion { \n    |                              ~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:74\n    |\n573 |                     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) \n    |                                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                                               |\n    |                                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:74\n    |\n578 |                     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))\n    |                                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                                               |\n    |                                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:568:36\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { \n    |                                    ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:587:98\n    |\n587 | ..., negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBrackete...\n    |                                           ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n587 |     let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };\n    |                                                                                                  ~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:289\n    |\n587 | ...lse, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span:...\n    |                                   -------------------------- ^^^ expected `Literal`, found `char`\n    |                                   |\n    |                                   arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:453\n    |\n587 | ...lse, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };\n    |                                   -------------------------- ^^^ expected `Literal`, found `char`\n    |                                   |\n    |                                   arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:587:104\n    |\n587 | ..., 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBra...\n    |                                                      ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:588:23\n    |\n588 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:34\n    |\n590 |     heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();\n    |                  --------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:371:8\n    |\n371 |     fn visit_class_pre<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^\n372 |         &self,\n373 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let x = heap_visitor.induct_class(&ast).unwrap();\n    |                          ------------ ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                          |\n    |                          arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:406:8\n    |\n406 |     fn induct_class(\n    |        ^^^^^^^^^^^^\n407 |         &self,\n408 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:36\n    |\n593 |     heap_visitor.stack_class.push((ast, x));\n    |                                    ^^^ expected `ClassInduct<'_>`, found `ClassBracketed`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n587 | ... ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] })...\n    |           --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- expected due to this value\n...\n594 | ... = child;\n    |       ^^^^^ expected `ClassBracketed`, found `ClassInduct<'_>`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:595:35\n    |\n595 |     heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();\n    |                  ---------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:388:8\n    |\n388 |     fn visit_class_post<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^^\n389 |         &self,\n390 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<(ClassInduct<'_>, ClassFrame<'_>)>`\n   --> regex-syntax/src/ast/visitor.rs:601:5\n    |\n601 |     assert_eq!(heap_visitor.stack_class.pop(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<(ClassInduct<'_>, ClassFrame<'_>)>\n    |     Option<(ClassInduct<'_>, ClassFrame<'_>)>\n    |\nnote: the following types would have to `impl` their required traits for this operation to be valid\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n...\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\nhelp: consider annotating `ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0369, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 15), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |                     span: Span::new(0, 5), \n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:27\n    |\n576 |                     span: Span::new(5, 10), \n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:43\n    |\n587 |     let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![a...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:203\n    |\n587 | ...m::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Litera...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:366\n    |\n587 | ...m::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Liter...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:30\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { \n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n568 |         kind: ast::ClassSet::union(ast::ClassSetUnion { \n    |                              ~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:74\n    |\n573 |                     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) \n    |                                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                                               |\n    |                                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:74\n    |\n578 |                     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))\n    |                                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                                               |\n    |                                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:568:36\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { \n    |                                    ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:587:98\n    |\n587 | ..., negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBrackete...\n    |                                           ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n587 |     let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };\n    |                                                                                                  ~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:289\n    |\n587 | ...lse, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span:...\n    |                                   -------------------------- ^^^ expected `Literal`, found `char`\n    |                                   |\n    |                                   arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:453\n    |\n587 | ...lse, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };\n    |                                   -------------------------- ^^^ expected `Literal`, found `char`\n    |                                   |\n    |                                   arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:587:104\n    |\n587 | ..., 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBra...\n    |                                                      ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:588:23\n    |\n588 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:34\n    |\n590 |     heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();\n    |                  --------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:371:8\n    |\n371 |     fn visit_class_pre<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^\n372 |         &self,\n373 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let x = heap_visitor.induct_class(&ast).unwrap();\n    |                          ------------ ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                          |\n    |                          arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:406:8\n    |\n406 |     fn induct_class(\n    |        ^^^^^^^^^^^^\n407 |         &self,\n408 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:36\n    |\n593 |     heap_visitor.stack_class.push((ast, x));\n    |                                    ^^^ expected `ClassInduct<'_>`, found `ClassBracketed`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n587 | ... ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] })...\n    |           --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- expected due to this value\n...\n594 | ... = child;\n    |       ^^^^^ expected `ClassBracketed`, found `ClassInduct<'_>`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:595:35\n    |\n595 |     heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();\n    |                  ---------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:388:8\n    |\n388 |     fn visit_class_post<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^^\n389 |         &self,\n390 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<(ClassInduct<'_>, ClassFrame<'_>)>`\n   --> regex-syntax/src/ast/visitor.rs:601:5\n    |\n601 |     assert_eq!(heap_visitor.stack_class.pop(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<(ClassInduct<'_>, ClassFrame<'_>)>\n    |     Option<(ClassInduct<'_>, ClassFrame<'_>)>\n    |\nnote: the following types would have to `impl` their required traits for this operation to be valid\n   --> regex-syntax/src/ast/visitor.rs:174:1\n    |\n174 | enum ClassFrame<'a> {\n    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n...\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ClassFrame<'_>` with `#[derive(PartialEq)]`\n    |\n174 + #[derive(PartialEq)]\n175 | enum ClassFrame<'a> {\n    |\nhelp: consider annotating `ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0369, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 15), \n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |                     span: Span::new(0, 5), \n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:27\n    |\n576 |                     span: Span::new(5, 10), \n    |                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:43\n    |\n587 |     let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![a...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:203\n    |\n587 | ...m::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Litera...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:366\n    |\n587 | ...m::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Liter...\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:30\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { \n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n568 |         kind: ast::ClassSet::union(ast::ClassSetUnion { \n    |                              ~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:74\n    |\n573 |                     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) \n    |                                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                                               |\n    |                                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:74\n    |\n578 |                     kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))\n    |                                               -------------------------- ^^^ expected `Literal`, found `char`\n    |                                               |\n    |                                               arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:568:36\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { \n    |                                    ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:587:98\n    |\n587 | ..., negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBrackete...\n    |                                           ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n587 |     let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };\n    |                                                                                                  ~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:289\n    |\n587 | ...lse, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span:...\n    |                                   -------------------------- ^^^ expected `Literal`, found `char`\n    |                                   |\n    |                                   arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:453\n    |\n587 | ...lse, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };\n    |                                   -------------------------- ^^^ expected `Literal`, found `char`\n    |                                   |\n    |                                   arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:971:5\n    |\n971 |     Literal(Literal),\n    |     ^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:587:104\n    |\n587 | ..., 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBra...\n    |                                                      ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:588:23\n    |\n588 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:34\n    |\n590 |     heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();\n    |                  --------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:371:8\n    |\n371 |     fn visit_class_pre<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^\n372 |         &self,\n373 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let x = heap_visitor.induct_class(&ast).unwrap();\n    |                          ------------ ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                          |\n    |                          arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:406:8\n    |\n406 |     fn induct_class(\n    |        ^^^^^^^^^^^^\n407 |         &self,\n408 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:36\n    |\n593 |     heap_visitor.stack_class.push((ast, x));\n    |                                    ^^^ expected `ClassInduct<'_>`, found `ClassBracketed`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n587 | ... ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] })...\n    |           --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- expected due to this value\n...\n594 | ... = child;\n    |       ^^^^^ expected `ClassBracketed`, found `ClassInduct<'_>`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:595:35\n    |\n595 |     heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();\n    |                  ---------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:388:8\n    |\n388 |     fn visit_class_post<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^^\n389 |         &self,\n390 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 20),",
                "        negated: false,",
                "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                "            span: Span::new(0, 10),",
                "            kind: ast::ClassSetBinaryOpKind::Union,",
                "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                "        })),",
                "    };",
                "    let mut visitor = MyVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.induct_class(&ast).is_some());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack_class.pop().is_some());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.pop_class(frame).is_some());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack_class.pop().is_none());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack_class.pop().is_none());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor).unwrap(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.induct_class(&ast).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack_class.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.pop_class(frame).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack_class.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert!(heap_visitor.stack_class.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 20),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
                  "            span: Span::new(0, 10),",
                  "            kind: ast::ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
                  "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
                  "        })),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor).unwrap(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:584:1\n    |\n559 | mod llmtests {\n    |              - this opening brace...\n...\n583 | }\n    | - ...matches this closing brace\n584 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = ast::ClassBracketed {",
                "        span: Span::new(0, 5),",
                "        negated: false,",
                "        kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),",
                "    };",
                "    let mut visitor = MyVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
                  "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
                  "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
                  "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
                  "    assert!(stack_class_empty_pop.is_none());"
                ],
                [
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
                  "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
                  "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
                  "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
                  "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 5),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
                  "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
                  "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
                  "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
                  "    assert!(stack_class_empty_pop.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = ast::ClassBracketed {",
                  "        span: Span::new(0, 5),",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),",
                  "    };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
                  "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
                  "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
                  "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
                  "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
                  "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
                  "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
                  "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
                  "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] ...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:30\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),\n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n568 |         kind: ast::ClassSet::union(ast::ClassSetUnion { items: vec![] }),\n    |                              ~~~~~\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:568:36\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),\n    |                                    ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:97\n    |\n574 | ..., negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };\n    |                                           ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n574 |     let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::union(ast::ClassSetUnion { items: vec![] }) };\n    |                                                                                                 ~~~~~\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:574:103\n    |\n574 | ...0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };\n    |                                                      ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:34\n    |\n577 |     heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();\n    |                  --------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ast::visitor::ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:371:8\n    |\n371 |     fn visit_class_pre<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^\n372 |         &self,\n373 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:35\n    |\n579 |     heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();\n    |                  ---------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ast::visitor::ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:388:8\n    |\n388 |     fn visit_class_post<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^^\n389 |         &self,\n390 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] ...\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:30\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),\n    |                              ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n568 |         kind: ast::ClassSet::union(ast::ClassSetUnion { items: vec![] }),\n    |                              ~~~~~\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:568:36\n    |\n568 |         kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),\n    |                                    ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:97\n    |\n574 | ..., negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };\n    |                                           ^^^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `Union` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n    |\n574 |     let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::union(ast::ClassSetUnion { items: vec![] }) };\n    |                                                                                                 ~~~~~\n\nerror[E0063]: missing field `span` in initializer of `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:574:103\n    |\n574 | ...0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };\n    |                                                      ^^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:34\n    |\n577 |     heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();\n    |                  --------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ast::visitor::ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:371:8\n    |\n371 |     fn visit_class_pre<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^\n372 |         &self,\n373 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:35\n    |\n579 |     heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();\n    |                  ---------------- ^^^^ expected `&ClassInduct<'_>`, found `&ClassBracketed`\n    |                  |\n    |                  arguments to this method are incorrect\n    |\n    = note: expected reference `&ast::visitor::ClassInduct<'_>`\n               found reference `&ClassBracketed`\nnote: method defined here\n   --> regex-syntax/src/ast/visitor.rs:388:8\n    |\n388 |     fn visit_class_post<V: Visitor>(\n    |        ^^^^^^^^^^^^^^^^\n389 |         &self,\n390 |         ast: &ClassInduct<'a>,\n    |         ---------------------\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: self.visit_class_pre(&ast, visitor)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct_class(&ast) is true\n",
        "// constraint: self.visit_class_post(&ast, visitor)? is Ok/Some\n",
        "// constraint: self.stack_class.pop() matches Some((post_ast, frame)) is true\n",
        "// constraint: let Some(x) = self.pop_class(frame) is true\n",
        "// constraint: let ClassFrame::BinaryRHS { ref op, .. } = x is true\n",
        "// constraint: visitor.visit_class_set_binary_op_in(op)? is Err/None\n"
      ],
      "input_infer": "ast input range: valid ClassBracketed with a ClassSet containing a BinaryOp that has valid lhs/rhs, and the visitor configured to return an error for visit_class_set_binary_op_in()\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "fn test_visit_class_valid_binary_op_error() {",
            "    let mut visitor = MockVisitor::new_with_error();",
            "    let span = Span::new(0, 10);",
            "    let lhs = Box::new(ClassSet::Item(ast::ClassSetItem::Literal('a')));",
            "    let rhs = Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b')));",
            "    let binary_op = ClassSetBinaryOp {",
            "        span,",
            "        kind: ClassSetBinaryOpKind::Union,",
            "        lhs,",
            "        rhs,",
            "    };",
            "    let class_set = ClassSet::BinaryOp(Box::new(binary_op));",
            "    let class_bracketed = ClassBracketed {",
            "        span,",
            "        negated: false,",
            "        kind: class_set,",
            "    };",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
            "}",
            "",
            "fn test_visit_class_valid_binary_op_success() {",
            "    let mut visitor = MockVisitor::new_with_success();",
            "    let span = Span::new(0, 10);",
            "    let lhs = Box::new(ClassSet::Item(ast::ClassSetItem::Literal('a')));",
            "    let rhs = Box::new(ClassSet::Item(ast::ClassSetItem::Literal('b')));",
            "    let binary_op = ClassSetBinaryOp {",
            "        span,",
            "        kind: ClassSetBinaryOpKind::Union,",
            "        lhs,",
            "        rhs,",
            "    };",
            "    let class_set = ClassSet::BinaryOp(Box::new(binary_op));",
            "    let class_bracketed = ClassBracketed {",
            "        span,",
            "        negated: false,",
            "        kind: class_set,",
            "    };",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
            "}",
            "",
            "fn test_visit_class_empty_class_set() {",
            "    let mut visitor = MockVisitor::new_with_error();",
            "    let span = Span::new(0, 10);",
            "    let class_set = ClassSet::BinaryOp(Box::new(ClassSetBinaryOp {",
            "        span,",
            "        kind: ClassSetBinaryOpKind::Union,",
            "        lhs: Box::new(ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "        rhs: Box::new(ClassSet::Item(ast::ClassSetItem::Empty)),",
            "    }));",
            "    let class_bracketed = ClassBracketed {",
            "        span,",
            "        negated: false,",
            "        kind: class_set,",
            "    };",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class(&class_bracketed, &mut visitor).unwrap();",
            "}"
          ],
          "chain_tests": []
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: self.visit_class_pre(&ast, visitor)? is Ok/Some\n",
        "// constraint: let Some(x) = self.induct_class(&ast) is true\n",
        "// constraint: self.visit_class_post(&ast, visitor)? is Ok/Some\n",
        "// constraint: self.stack_class.pop() matches Some((post_ast, frame)) is true\n",
        "// constraint: let Some(x) = self.pop_class(frame) is true\n",
        "// constraint: let ClassFrame::BinaryRHS { ref op, .. } = x is true\n",
        "// constraint: visitor.visit_class_set_binary_op_in(op)? is Ok/Some\n",
        "// constraint: self.visit_class_pre(&ast, visitor)? is Err/None\n"
      ],
      "input_infer": "0 <= ast.kind <= 10, 1 <= self.stack_class.len() <= 5, 0 < ast.span <= 100, 1 <= visitor.calls <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "struct TestVisitor {",
            "    calls: usize,",
            "}",
            "",
            "impl TestVisitor {",
            "    fn new() -> Self {",
            "        Self { calls: 0 }",
            "    }",
            "}",
            "",
            "impl Visitor for TestVisitor {",
            "    type Output = ();",
            "    type Err = ();",
            "",
            "    fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {",
            "        self.calls += 1;",
            "        Ok(())",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 10);",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                "    };",
                "    ",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 0);"
                ],
                [
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(heap_visitor.stack_class.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 10);",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(heap_visitor.stack_class.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:27\n    |\n586 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:30\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:52\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:72\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:596:87\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:596:109\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:27\n    |\n586 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:30\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:52\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:72\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:596:87\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:596:109\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:27\n    |\n586 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:30\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:52\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(1, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:72\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:596:87\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:596:109\n    |\n596 |     let class_bracketed = ClassBracketed { span, negated: false, kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('a'))), };\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 20);",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: true,",
                "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                "    };",
                "    ",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 0);"
                ],
                [
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let mut class_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Subtract,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))",
                  "    };",
                  "    let result = visitor.visit_class_set_binary_op_in(&class_op);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let mut class_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Subtract,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))",
                  "    };",
                  "    let result = visitor.visit_class_set_binary_op_in(&class_op);",
                  "    assert_eq!(visitor.calls, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let mut class_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Subtract,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))",
                  "    };",
                  "    let result = visitor.visit_class_set_binary_op_in(&class_op);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 20);",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let mut class_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Subtract,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))",
                  "    };",
                  "    let result = visitor.visit_class_set_binary_op_in(&class_op);",
                  "    assert_eq!(visitor.calls, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:27\n    |\n586 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:30\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:52\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:599:26\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:599:48\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:27\n    |\n586 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:30\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:52\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:599:26\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:599:48\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:27\n    |\n586 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:30\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:52\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:599:26\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:599:48\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:604:24\n    |\n604 |     let mut class_op = ClassSetBinaryOp {\n    |                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:606:11\n    |\n606 |     kind: ClassSetBinaryOpKind::Subtract,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:607:19\n    |\n607 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:607:34\n    |\n607 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:607:56\n    |\n607 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:608:19\n    |\n608 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:608:34\n    |\n608 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:608:56\n    |\n608 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:27\n    |\n586 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:589:30\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:589:52\n    |\n589 |         kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:595:16\n    |\n595 |     let span = Span::new(1, 20);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:599:26\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                          ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:599:48\n    |\n599 |     kind: ClassSet::Item(ClassSetItem::Literal(Literal::new('b'))),\n    |                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:604:24\n    |\n604 |     let mut class_op = ClassSetBinaryOp {\n    |                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:606:11\n    |\n606 |     kind: ClassSetBinaryOpKind::Subtract,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:607:19\n    |\n607 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:607:34\n    |\n607 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:607:56\n    |\n607 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:608:19\n    |\n608 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:608:34\n    |\n608 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:608:56\n    |\n608 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('c'))))\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 30);",
                "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));",
                "    let binary_op = ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(lhs),",
                "        rhs: Box::new(rhs),",
                "    };",
                "",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::BinaryOp(binary_op),",
                "    };",
                "    ",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 30);",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span::new(1, 30);",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 30);",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    };",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 30);",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 30);",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    };",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 30);",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let class_bracketed = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::BinaryOp(binary_op),",
                  "    };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 30);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:30\n    |\n586 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:52\n    |\n586 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:587:15\n    |\n587 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:587:30\n    |\n587 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:587:52\n    |\n587 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:21\n    |\n588 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:590:15\n    |\n590 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:27\n    |\n595 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:15\n    |\n598 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:604:16\n    |\n604 |     let span = Span::new(1, 30);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:15\n    |\n605 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:605:30\n    |\n605 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:605:52\n    |\n605 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:606:15\n    |\n606 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:606:30\n    |\n606 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:606:52\n    |\n606 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:607:21\n    |\n607 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:609:11\n    |\n609 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:613:27\n    |\n613 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:616:11\n    |\n616 |     kind: ClassSet::BinaryOp(binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 30);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:30\n    |\n586 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:52\n    |\n586 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:587:15\n    |\n587 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:587:30\n    |\n587 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:587:52\n    |\n587 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:21\n    |\n588 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:590:15\n    |\n590 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:595:27\n    |\n595 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:15\n    |\n598 |         kind: ClassSet::BinaryOp(binary_op),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:604:16\n    |\n604 |     let span = Span::new(1, 30);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:15\n    |\n605 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:605:30\n    |\n605 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:605:52\n    |\n605 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:606:15\n    |\n606 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:606:30\n    |\n606 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:606:52\n    |\n606 |     let lhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('d')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:607:21\n    |\n607 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:609:11\n    |\n609 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:613:27\n    |\n613 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:616:11\n    |\n616 |     kind: ClassSet::BinaryOp(binary_op),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 40);",
                "    let items = vec![",
                "        ClassSetItem::Literal(Literal::new('e')),",
                "        ClassSetItem::Literal(Literal::new('f')),",
                "    ];",
                "    let union = ClassSet::Union(ast::Union { items });",
                "",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: union,",
                "    };",
                "    ",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 40);",
                  "    let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];",
                  "    let union = ClassSet::Union(ast::Union { items });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 40);",
                  "    let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];",
                  "    let union = ClassSet::Union(ast::Union { items });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 40);",
                  "    let items = vec![",
                  "        ClassSetItem::Literal(Literal::new('e')),",
                  "        ClassSetItem::Literal(Literal::new('f')),",
                  "    ];",
                  "    let union = ClassSet::Union(ast::Union { items });",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: union,",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 40);",
                  "    let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];",
                  "    let union = ClassSet::Union(ast::Union { items });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 40);",
                  "    let items = vec![",
                  "        ClassSetItem::Literal(Literal::new('e')),",
                  "        ClassSetItem::Literal(Literal::new('f')),",
                  "    ];",
                  "    let union = ClassSet::Union(ast::Union { items });",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: union,",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 40);",
                  "    let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];",
                  "    let union = ClassSet::Union(ast::Union { items });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 40);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:587:9\n    |\n587 |         ClassSetItem::Literal(Literal::new('e')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:587:31\n    |\n587 |         ClassSetItem::Literal(Literal::new('e')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:9\n    |\n588 |         ClassSetItem::Literal(Literal::new('f')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:31\n    |\n588 |         ClassSetItem::Literal(Literal::new('f')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let union = ClassSet::Union(ast::Union { items });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:590:38\n    |\n590 |     let union = ClassSet::Union(ast::Union { items });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n590 -     let union = ClassSet::Union(ast::Union { items });\n590 +     let union = ClassSet::Union(Union { items });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:27\n    |\n592 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:601:16\n    |\n601 |     let span = Span::new(1, 40);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:602:22\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:602:44\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:602:86\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:603:17\n    |\n603 |     let union = ClassSet::Union(ast::Union { items });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:603:38\n    |\n603 |     let union = ClassSet::Union(ast::Union { items });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n603 -     let union = ClassSet::Union(ast::Union { items });\n603 +     let union = ClassSet::Union(Union { items });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:604:27\n    |\n604 |     let class_bracketed = ClassBracketed { span, negated: false, kind: union };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 40);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:587:9\n    |\n587 |         ClassSetItem::Literal(Literal::new('e')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:587:31\n    |\n587 |         ClassSetItem::Literal(Literal::new('e')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:9\n    |\n588 |         ClassSetItem::Literal(Literal::new('f')),\n    |         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:31\n    |\n588 |         ClassSetItem::Literal(Literal::new('f')),\n    |                               ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:17\n    |\n590 |     let union = ClassSet::Union(ast::Union { items });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:590:38\n    |\n590 |     let union = ClassSet::Union(ast::Union { items });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n590 -     let union = ClassSet::Union(ast::Union { items });\n590 +     let union = ClassSet::Union(Union { items });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:27\n    |\n592 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:601:16\n    |\n601 |     let span = Span::new(1, 40);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:602:22\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:602:44\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:602:86\n    |\n602 |     let items = vec![ClassSetItem::Literal(Literal::new('e')), ClassSetItem::Literal(Literal::new('f'))];\n    |                                                                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:603:17\n    |\n603 |     let union = ClassSet::Union(ast::Union { items });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:603:38\n    |\n603 |     let union = ClassSet::Union(ast::Union { items });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n603 -     let union = ClassSet::Union(ast::Union { items });\n603 +     let union = ClassSet::Union(Union { items });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:604:27\n    |\n604 |     let class_bracketed = ClassBracketed { span, negated: false, kind: union };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 50);",
                "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                "",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: union,",
                "    };",
                "    ",
                "    let mut visitor = TestVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 0);"
                ],
                [
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(heap_visitor.stack_class.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: union,",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: union,",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert_eq!(visitor.calls, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: union,",
                  "    };",
                  "    ",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    let span = Span::new(1, 50);",
                  "    let union = ClassSet::Union(ast::Union { items: vec![] });",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: union };",
                  "    let mut visitor = TestVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.visit_class(&class_bracketed, &mut visitor);",
                  "    assert!(heap_visitor.stack_class.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 50);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:17\n    |\n586 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:586:38\n    |\n586 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n586 -     let union = ClassSet::Union(ast::Union { items: vec![] });\n586 +     let union = ClassSet::Union(Union { items: vec![] });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:27\n    |\n588 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:597:16\n    |\n597 |     let span = Span::new(1, 50);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:17\n    |\n598 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:598:38\n    |\n598 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n598 -     let union = ClassSet::Union(ast::Union { items: vec![] });\n598 +     let union = ClassSet::Union(Union { items: vec![] });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed { span, negated: false, kind: union };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 50);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:17\n    |\n586 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:586:38\n    |\n586 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n586 -     let union = ClassSet::Union(ast::Union { items: vec![] });\n586 +     let union = ClassSet::Union(Union { items: vec![] });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:27\n    |\n588 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:597:16\n    |\n597 |     let span = Span::new(1, 50);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:17\n    |\n598 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:598:38\n    |\n598 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n598 -     let union = ClassSet::Union(ast::Union { items: vec![] });\n598 +     let union = ClassSet::Union(Union { items: vec![] });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed { span, negated: false, kind: union };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:52\n    |\n576 |     fn visit_class_set_binary_op_in(&mut self, _: &ClassSetBinaryOp) -> Result<Self::Output, Self::Err> {\n    |                                                    ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:16\n    |\n585 |     let span = Span::new(1, 50);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:17\n    |\n586 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:586:38\n    |\n586 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n586 -     let union = ClassSet::Union(ast::Union { items: vec![] });\n586 +     let union = ClassSet::Union(Union { items: vec![] });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:27\n    |\n588 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:597:16\n    |\n597 |     let span = Span::new(1, 50);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:17\n    |\n598 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Union` in module `ast`\n   --> regex-syntax/src/ast/visitor.rs:598:38\n    |\n598 |     let union = ClassSet::Union(ast::Union { items: vec![] });\n    |                                      ^^^^^ not found in `ast`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use std::collections::btree_set::Union;\n    |\n560 +    use std::collections::hash_set::Union;\n    |\n560 +    use ast::ClassSetItem::Union;\n    |\n560 +    use ast::visitor::ClassFrame::Union;\n    |\nhelp: if you import `Union`, refer to it directly\n    |\n598 -     let union = ClassSet::Union(ast::Union { items: vec![] });\n598 +     let union = ClassSet::Union(Union { items: vec![] });\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed { span, negated: false, kind: union };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:572:1\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n572 | impl Visitor for TestVisitor {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0412, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}