{
  "name": "regex_syntax::ast::visitor::ast::visitor::ClassFrame<'a>::child",
  "name_with_impl": "regex_syntax::ast::visitor::{impl#2}::child",
  "mod_info": {
    "name": "ast::visitor",
    "loc": "regex-syntax/src/ast/mod.rs:23:1:23:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/visitor.rs:487:5:498:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *self matches ClassFrame::BinaryRHS { ref rhs, .. } is true\n"
      ],
      "input_infer": "test input ranges: lhs must be a valid ClassSet that triggers BinaryRHS, rhs must be a valid ClassSet, both lhs and rhs should be non-empty and contain a variety of ClassSetItems including Literal, Range, and Union, the span must be suitably defined to cover edge cases like zero-length and maximal length, ensuring no empty ClassSetItems present\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                "    let rhs = ClassSet::Item(literal.clone());",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span: Span::new(1, 2),",
                "        kind: ClassSetBinaryOpKind::SomeKind,",
                "        lhs: Box::new(rhs.clone()),",
                "        rhs: Box::new(lhs.clone()),",
                "    });",
                "",
                "    let frame = ClassFrame::BinaryRHS {",
                "        op: &ClassSetBinaryOp {",
                "            span: Span::new(1, 3),",
                "            kind: ClassSetBinaryOpKind::SomeKind,",
                "            lhs: Box::new(lhs),",
                "            rhs: Box::new(rhs),",
                "        },",
                "        rhs: &rhs,",
                "    };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let rhs = ClassSet::Item(literal.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(1, 2), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(rhs.clone()), rhs: Box::new(lhs.clone()), });",
                  "    let frame = ClassFrame::BinaryRHS { op: &ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs), rhs: Box::new(rhs), }, rhs: &rhs, };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs), rhs: Box::new(rhs) }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let rhs = ClassSet::Item(literal.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(1, 2),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(1, 3),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let rhs = ClassSet::Item(literal.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(1, 2), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(rhs.clone()), rhs: Box::new(lhs.clone()), });",
                  "    let frame = ClassFrame::BinaryRHS { op: &ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs), rhs: Box::new(rhs), }, rhs: &rhs, };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs), rhs: Box::new(rhs) }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:41\n    |\n565 |     let literal = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::Item(literal.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:34\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(1, 2),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::SomeKind,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0425]: cannot find value `lhs` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |         rhs: Box::new(lhs.clone()),\n    |                       ^^^ help: a local variable with a similar name exists: `rhs`\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:14\n    |\n575 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |             span: Span::new(1, 3),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |             kind: ClassSetBinaryOpKind::SomeKind,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:19\n    |\n584 |     let literal = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let literal = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:15\n    |\n585 |     let rhs = ClassSet::Item(literal.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(1, 2), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(rhs.clone(...\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:34\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(1, 2), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(rhs.clone(...\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:586:59\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(1, 2), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(rhs.clone(...\n    |                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:586:82\n    |\n586 | ...Op { span: Span::new(1, 2), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(rhs.clone()), rhs: Box::new(lhs.clone()), });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:46\n    |\n587 |     let frame = ClassFrame::BinaryRHS { op: &ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::ne...\n    |                                              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:71\n    |\n587 |     let frame = ClassFrame::BinaryRHS { op: &ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::ne...\n    |                                                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:587:94\n    |\n587 | ...Op { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs), rhs: Box::new(rhs), }, rhs: &rhs, };\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:47\n    |\n589 |     assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::n...\n    |                                               ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:589:72\n    |\n589 |     assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::n...\n    |                                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:589:95\n    |\n589 | ...Op { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs), rhs: Box::new(rhs) }));\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:589:5\n    |\n589 |     assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp { span: Span::new(1, 3), kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(lhs), rhs: Box::new(rhs) }...\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                "    let rhs = ClassSet::Item(range.clone());",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span: Span::new(2, 4),",
                "        kind: ClassSetBinaryOpKind::SomeKind,",
                "        lhs: Box::new(rhs.clone()),",
                "        rhs: Box::new(lhs.clone()),",
                "    });",
                "",
                "    let frame = ClassFrame::BinaryRHS {",
                "        op: &ClassSetBinaryOp {",
                "            span: Span::new(2, 5),",
                "            kind: ClassSetBinaryOpKind::SomeKind,",
                "            lhs: Box::new(lhs),",
                "            rhs: Box::new(rhs),",
                "        },",
                "        rhs: &rhs,",
                "    };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let rhs = ClassSet::Item(range.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(2, 4),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(2, 5),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(frame.child(), ClassInduct::from_set(&rhs));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let rhs = ClassSet::Item(range.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(2, 4),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(2, 5),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let rhs = ClassSet::Item(range.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(2, 4),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(2, 5),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(frame.child(), ClassInduct::from_set(&rhs));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:565:17\n    |\n565 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:565:37\n    |\n565 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::Item(range.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:34\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(2, 4),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::SomeKind,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0425]: cannot find value `lhs` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |         rhs: Box::new(lhs.clone()),\n    |                       ^^^ help: a local variable with a similar name exists: `rhs`\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:14\n    |\n575 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |             span: Span::new(2, 5),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |             kind: ClassSetBinaryOpKind::SomeKind,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:17\n    |\n584 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:37\n    |\n584 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:15\n    |\n585 |     let rhs = ClassSet::Item(range.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:34\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::new(2, 4),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:588:11\n    |\n588 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:10\n    |\n593 |     op: &ClassSetBinaryOp {\n    |          ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     span: Span::new(2, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:595:11\n    |\n595 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:601:5\n    |\n601 |     assert_eq!(frame.child(), ClassInduct::from_set(&rhs));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));",
                "    let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));",
                "    let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));",
                "    let rhs = ClassSet::Item(union.clone());",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span: Span::new(3, 5),",
                "        kind: ClassSetBinaryOpKind::SomeKind,",
                "        lhs: Box::new(rhs.clone()),",
                "        rhs: Box::new(lhs.clone()),",
                "    });",
                "",
                "    let frame = ClassFrame::BinaryRHS {",
                "        op: &ClassSetBinaryOp {",
                "            span: Span::new(3, 6),",
                "            kind: ClassSetBinaryOpKind::SomeKind,",
                "            lhs: Box::new(lhs),",
                "            rhs: Box::new(rhs),",
                "        },",
                "        rhs: &rhs,",
                "    };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));",
                  "    let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));",
                  "    let rhs = ClassSet::Item(union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(3, 5),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(3, 6),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::from_set(&rhs));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));",
                  "    let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));",
                  "    let rhs = ClassSet::Item(union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(3, 5),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(3, 6),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));",
                  "    let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));",
                  "    let rhs = ClassSet::Item(union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(3, 5),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(3, 6),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::from_set(&rhs));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:45\n    |\n565 |     let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:45\n    |\n566 |     let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));\n    |                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:567:17\n    |\n567 |     let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:567:37\n    |\n567 |     let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let rhs = ClassSet::Item(union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:15\n    |\n570 |         span: Span::new(3, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         kind: ClassSetBinaryOpKind::SomeKind,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0425]: cannot find value `lhs` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |         rhs: Box::new(lhs.clone()),\n    |                       ^^^ help: a local variable with a similar name exists: `rhs`\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:14\n    |\n577 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:19\n    |\n578 |             span: Span::new(3, 6),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:579:19\n    |\n579 |             kind: ClassSetBinaryOpKind::SomeKind,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:586:23\n    |\n586 |     let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:586:45\n    |\n586 |     let union_item1 = ClassSetItem::Literal(Literal::new(\"a\"));\n    |                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:587:23\n    |\n587 |     let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:587:45\n    |\n587 |     let union_item2 = ClassSetItem::Literal(Literal::new(\"b\"));\n    |                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:588:17\n    |\n588 |     let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:588:37\n    |\n588 |     let union = ClassSetItem::Union(ClassSetUnion::new(vec![union_item1, union_item2]));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:589:15\n    |\n589 |     let rhs = ClassSet::Item(union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:590:15\n    |\n590 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:34\n    |\n590 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:11\n    |\n591 |     span: Span::new(3, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:592:11\n    |\n592 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:597:10\n    |\n597 |     op: &ClassSetBinaryOp {\n    |          ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     span: Span::new(3, 6),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:606:5\n    |\n606 |     assert_eq!(result, ClassInduct::from_set(&rhs));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                "    let rhs = ClassSet::Item(empty_union.clone());",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span: Span::new(0, 1),",
                "        kind: ClassSetBinaryOpKind::SomeKind,",
                "        lhs: Box::new(rhs.clone()),",
                "        rhs: Box::new(lhs.clone()),",
                "    });",
                "",
                "    let frame = ClassFrame::BinaryRHS {",
                "        op: &ClassSetBinaryOp {",
                "            span: Span::new(0, 2),",
                "            kind: ClassSetBinaryOpKind::SomeKind,",
                "            lhs: Box::new(lhs),",
                "            rhs: Box::new(rhs),",
                "        },",
                "        rhs: &rhs,",
                "    };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    assert_eq!(empty_union, ClassSetItem::Union(ClassSetUnion::new(vec![])));"
                ],
                [
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    assert_eq!(rhs, ClassSet::Item(empty_union.clone()));"
                ],
                [
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(0, 1),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    assert_eq!(lhs.kind, ClassSetBinaryOpKind::SomeKind);"
                ],
                [
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(0, 1),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(frame.child().child(), ClassInduct::BinaryOp(&frame.op));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(0, 1),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(0, 2),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    assert_eq!(empty_union, ClassSetItem::Union(ClassSetUnion::new(vec![])));",
                  "}"
                ],
                [
                  "{",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(0, 1),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(0, 2),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    assert_eq!(rhs, ClassSet::Item(empty_union.clone()));",
                  "}"
                ],
                [
                  "{",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(0, 1),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(0, 2),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(0, 1),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    assert_eq!(lhs.kind, ClassSetBinaryOpKind::SomeKind);",
                  "}"
                ],
                [
                  "{",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(0, 1),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(0, 2),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let rhs = ClassSet::Item(empty_union.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(0, 1),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(0, 2),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(frame.child().child(), ClassInduct::BinaryOp(&frame.op));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:565:43\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::Item(empty_union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:34\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::SomeKind,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0425]: cannot find value `lhs` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |         rhs: Box::new(lhs.clone()),\n    |                       ^^^ help: a local variable with a similar name exists: `rhs`\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:14\n    |\n575 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |             span: Span::new(0, 2),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |             kind: ClassSetBinaryOpKind::SomeKind,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:584:43\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:29\n    |\n585 |     assert_eq!(empty_union, ClassSetItem::Union(ClassSetUnion::new(vec![])));\n    |                             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:585:49\n    |\n585 |     assert_eq!(empty_union, ClassSetItem::Union(ClassSetUnion::new(vec![])));\n    |                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:565:43\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::Item(empty_union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:34\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::SomeKind,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0425]: cannot find value `lhs` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |         rhs: Box::new(lhs.clone()),\n    |                       ^^^ help: a local variable with a similar name exists: `rhs`\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:14\n    |\n575 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |             span: Span::new(0, 2),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |             kind: ClassSetBinaryOpKind::SomeKind,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:584:43\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:15\n    |\n585 |     let rhs = ClassSet::Item(empty_union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:21\n    |\n586 |     assert_eq!(rhs, ClassSet::Item(empty_union.clone()));\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:565:43\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::Item(empty_union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:34\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::SomeKind,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0425]: cannot find value `lhs` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |         rhs: Box::new(lhs.clone()),\n    |                       ^^^ help: a local variable with a similar name exists: `rhs`\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:14\n    |\n575 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |             span: Span::new(0, 2),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |             kind: ClassSetBinaryOpKind::SomeKind,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:584:43\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:15\n    |\n585 |     let rhs = ClassSet::Item(empty_union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:34\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:588:11\n    |\n588 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:592:26\n    |\n592 |     assert_eq!(lhs.kind, ClassSetBinaryOpKind::SomeKind);\n    |                          ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:565:43\n    |\n565 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::Item(empty_union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:34\n    |\n567 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::SomeKind,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0425]: cannot find value `lhs` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |         rhs: Box::new(lhs.clone()),\n    |                       ^^^ help: a local variable with a similar name exists: `rhs`\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:14\n    |\n575 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |             span: Span::new(0, 2),\n    |                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |             kind: ClassSetBinaryOpKind::SomeKind,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:23\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:584:43\n    |\n584 |     let empty_union = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:585:15\n    |\n585 |     let rhs = ClassSet::Item(empty_union.clone());\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:586:15\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:34\n    |\n586 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:588:11\n    |\n588 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:10\n    |\n593 |     op: &ClassSetBinaryOp {\n    |          ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     span: Span::new(0, 2),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:595:11\n    |\n595 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `child` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:601:30\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `child` not found for this enum\n...\n601 |     assert_eq!(frame.child().child(), ClassInduct::BinaryOp(&frame.op));\n    |                -----         ^^^^^ method not found in `ClassInduct<'_>`\n    |                |\n    |                method `child` is available on `&ast::visitor::ClassFrame<'_>`\n\nerror[E0609]: no field `op` on type `ast::visitor::ClassFrame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:601:68\n    |\n601 |     assert_eq!(frame.child().child(), ClassInduct::BinaryOp(&frame.op));\n    |                                                                    ^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                "    let rhs = ClassSet::Item(literal.clone());",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span: Span::new(0, 0),",
                "        kind: ClassSetBinaryOpKind::SomeKind,",
                "        lhs: Box::new(rhs.clone()),",
                "        rhs: Box::new(lhs.clone()),",
                "    });",
                "",
                "    let frame = ClassFrame::BinaryRHS {",
                "        op: &ClassSetBinaryOp {",
                "            span: Span::new(0, 1),",
                "            kind: ClassSetBinaryOpKind::SomeKind,",
                "            lhs: Box::new(lhs),",
                "            rhs: Box::new(rhs),",
                "        },",
                "        rhs: &rhs,",
                "    };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let rhs = ClassSet::Item(literal.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(0, 0),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(0, 1),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let rhs = ClassSet::Item(literal.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span::new(0, 0),",
                  "        kind: ClassSetBinaryOpKind::SomeKind,",
                  "        lhs: Box::new(rhs.clone()),",
                  "        rhs: Box::new(lhs.clone()),",
                  "    });",
                  "",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span: Span::new(0, 1),",
                  "            kind: ClassSetBinaryOpKind::SomeKind,",
                  "            lhs: Box::new(lhs),",
                  "            rhs: Box::new(rhs),",
                  "        },",
                  "        rhs: &rhs,",
                  "    };",
                  "    let _ = frame.child();",
                  "    let literal = ClassSetItem::Literal(Literal::new(\"a\"));",
                  "    let rhs = ClassSet::Item(literal.clone());",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span: Span::new(0, 0),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(rhs.clone()),",
                  "    rhs: Box::new(lhs.clone()),",
                  "    });",
                  "    let frame = ClassFrame::BinaryRHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span: Span::new(0, 1),",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    },",
                  "    rhs: &rhs,",
                  "    };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:602:45\n    |\n564 | {\n    | - closing delimiter possibly meant for this\n...\n602 |     assert_eq!(result, ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                             ^ unclosed delimiter\n603 | }\n604 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:604:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n604 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *self matches ClassFrame::BinaryLHS { ref lhs, .. } is true\n",
        "// constraint: *self matches ClassFrame::BinaryLHS { ref lhs, .. } is true\n"
      ],
      "input_infer": "lhs: ClassSet::BinaryOp(ClassSetBinaryOp { span: Span::new(0, 10), kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))) })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 10);",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                "    });",
                "    ",
                "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                "",
                "    let frame = ClassFrame::BinaryLHS {",
                "        op: &ClassSetBinaryOp {",
                "            span,",
                "            kind: ClassSetBinaryOpKind::Intersection,",
                "            lhs: Box::new(lhs.clone()),",
                "            rhs: Box::new(rhs.clone()),",
                "        },",
                "        lhs: &lhs,",
                "        rhs: &rhs,",
                "    };",
                "",
                "    let result = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::from_set(&lhs));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    ",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersection,",
                  "            lhs: Box::new(lhs.clone()),",
                  "            rhs: Box::new(rhs.clone()),",
                  "        },",
                  "        lhs: &lhs,",
                  "        rhs: &rhs,",
                  "    };",
                  "",
                  "    let result = frame.child();",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::from_set(&lhs));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:34\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Intersection,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:60\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:38\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:52\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:14\n    |\n576 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:578:19\n    |\n578 |             kind: ClassSetBinaryOpKind::Intersection,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:16\n    |\n587 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:34\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:590:11\n    |\n590 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:56\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('a')))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:592:19\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:34\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:56\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:15\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:594:52\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Literal(Literal::new('c')));\n    |                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:10\n    |\n596 |     op: &ClassSetBinaryOp {\n    |          ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:606:5\n    |\n606 |     assert_eq!(result, ClassInduct::from_set(&lhs));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 10);",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                "    });",
                "    ",
                "    let rhs = ClassSet::Item(ClassSetItem::Empty(span));",
                "",
                "    let frame = ClassFrame::BinaryLHS {",
                "        op: &ClassSetBinaryOp {",
                "            span,",
                "            kind: ClassSetBinaryOpKind::Intersection,",
                "            lhs: Box::new(lhs.clone()),",
                "            rhs: Box::new(rhs.clone()),",
                "        },",
                "        lhs: &lhs,",
                "        rhs: &rhs,",
                "    };",
                "",
                "    let result = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Empty(span));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(result, ClassInduct::from_set(&lhs));"
                ],
                [
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Empty(span));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(result, ClassInduct::Item(&ClassSetItem::Empty(span)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    ",
                  "    let rhs = ClassSet::Item(ClassSetItem::Empty(span));",
                  "",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersection,",
                  "            lhs: Box::new(lhs.clone()),",
                  "            rhs: Box::new(rhs.clone()),",
                  "        },",
                  "        lhs: &lhs,",
                  "        rhs: &rhs,",
                  "    };",
                  "",
                  "    let result = frame.child();",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Empty(span));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(result, ClassInduct::from_set(&lhs));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    ",
                  "    let rhs = ClassSet::Item(ClassSetItem::Empty(span));",
                  "",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Intersection,",
                  "            lhs: Box::new(lhs.clone()),",
                  "            rhs: Box::new(rhs.clone()),",
                  "        },",
                  "        lhs: &lhs,",
                  "        rhs: &rhs,",
                  "    };",
                  "",
                  "    let result = frame.child();",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Empty(span));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(result, ClassInduct::Item(&ClassSetItem::Empty(span)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:34\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Intersection,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:38\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:14\n    |\n576 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:578:19\n    |\n578 |             kind: ClassSetBinaryOpKind::Intersection,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:16\n    |\n587 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:34\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:590:11\n    |\n590 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:592:19\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:34\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:56\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:15\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:10\n    |\n596 |     op: &ClassSetBinaryOp {\n    |          ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:605:5\n    |\n605 |     assert_eq!(result, ClassInduct::from_set(&lhs));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:34\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Intersection,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:38\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:14\n    |\n576 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:578:19\n    |\n578 |             kind: ClassSetBinaryOpKind::Intersection,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:16\n    |\n587 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:34\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:590:11\n    |\n590 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(span))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:592:19\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:34\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:56\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:15\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Empty(span));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:10\n    |\n596 |     op: &ClassSetBinaryOp {\n    |          ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:605:43\n    |\n605 |     assert_eq!(result, ClassInduct::Item(&ClassSetItem::Empty(span)));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:605:5\n    |\n605 |     assert_eq!(result, ClassInduct::Item(&ClassSetItem::Empty(span)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 10);",
                "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Union,",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                "    });",
                "    ",
                "    let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                "",
                "    let frame = ClassFrame::BinaryLHS {",
                "        op: &ClassSetBinaryOp {",
                "            span,",
                "            kind: ClassSetBinaryOpKind::Union,",
                "            lhs: Box::new(lhs.clone()),",
                "            rhs: Box::new(rhs.clone()),",
                "        },",
                "        lhs: &lhs,",
                "        rhs: &rhs,",
                "    };",
                "",
                "    let result = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(result, ClassInduct::from_set(&lhs));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Union,",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    ",
                  "    let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "        op: &ClassSetBinaryOp {",
                  "            span,",
                  "            kind: ClassSetBinaryOpKind::Union,",
                  "            lhs: Box::new(lhs.clone()),",
                  "            rhs: Box::new(rhs.clone()),",
                  "        },",
                  "        lhs: &lhs,",
                  "        rhs: &rhs,",
                  "    };",
                  "",
                  "    let result = frame.child();",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),",
                  "    });",
                  "    let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let frame = ClassFrame::BinaryLHS {",
                  "    op: &ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Union,",
                  "    lhs: Box::new(lhs.clone()),",
                  "    rhs: Box::new(rhs.clone()),",
                  "    },",
                  "    lhs: &lhs,",
                  "    rhs: &rhs,",
                  "    };",
                  "    assert_eq!(result, ClassInduct::from_set(&lhs));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:34\n    |\n566 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: ClassSetBinaryOpKind::Union,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:569:58\n    |\n569 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),\n    |                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:38\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:15\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:573:50\n    |\n573 |     let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                  ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:14\n    |\n576 |         op: &ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:578:19\n    |\n578 |             kind: ClassSetBinaryOpKind::Union,\n    |                   ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:16\n    |\n587 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:588:15\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:34\n    |\n588 |     let lhs = ClassSet::BinaryOp(ClassSetBinaryOp {\n    |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:590:11\n    |\n590 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:591:19\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:591:34\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')))),\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:592:19\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:592:34\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:592:56\n    |\n592 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal::new('b')))),\n    |                                                        ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:594:15\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:594:50\n    |\n594 |     let rhs = ClassSet::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                  ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:596:10\n    |\n596 |     op: &ClassSetBinaryOp {\n    |          ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:598:11\n    |\n598 |     kind: ClassSetBinaryOpKind::Union,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:605:5\n    |\n605 |     assert_eq!(result, ClassInduct::from_set(&lhs));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *self matches ClassFrame::Binary { op, .. } is true\n",
        "// constraint: *self matches ClassFrame::Binary { op, .. } is true\n",
        "// expected return value/type: ClassInduct::BinaryOp(op)\n"
      ],
      "input_infer": "1 <= op <= 100\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let op = ClassSetBinaryOp { ",
                "        span: Span { /* initialize with valid data */ }, ",
                "        kind: ClassSetBinaryOpKind::SomeKind, ",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))), ",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))) ",
                "    };",
                "    let frame = ClassFrame::Binary { op: &op };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))) };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&op));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let op = ClassSetBinaryOp { ",
                  "        span: Span { /* initialize with valid data */ }, ",
                  "        kind: ClassSetBinaryOpKind::SomeKind, ",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))), ",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))) ",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let _ = frame.child();",
                  "    let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))) };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&op));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:14\n    |\n565 |     let op = ClassSetBinaryOp { \n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span { /* initialize with valid data */ }, \n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         kind: ClassSetBinaryOpKind::SomeKind, \n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:23\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))), \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:38\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))), \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:60\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))), \n    |                                                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))) \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))) \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:60\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* initialize with valid data */ }))) \n    |                                                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:14\n    |\n573 |     let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(Class...\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:39\n    |\n573 |     let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(Class...\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:573:72\n    |\n573 | ... Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* vali...\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:118\n    |\n573 | ...ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))), rhs: Box::new(Clas...\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:133\n    |\n573 | ...d::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSet...\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:155\n    |\n573 | ...lhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal...\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:202\n    |\n573 | ...iteral { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:217\n    |\n573 | ...ata */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))) };\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:239\n    |\n573 | ...rhs: Box::new(ClassSet::Item(ClassSetItem::Literal(Literal { /* valid data */ }))) };\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:576:5\n    |\n576 |     assert_eq!(result, ClassInduct::BinaryOp(&op));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let op = ClassSetBinaryOp { ",
                "        span: Span { /* initialize with valid data */ }, ",
                "        kind: ClassSetBinaryOpKind::SomeKind, ",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))), ",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))) ",
                "    };",
                "    let frame = ClassFrame::Binary { op: &op };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))) };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&op));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let op = ClassSetBinaryOp { ",
                  "        span: Span { /* initialize with valid data */ }, ",
                  "        kind: ClassSetBinaryOpKind::SomeKind, ",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))), ",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))) ",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let _ = frame.child();",
                  "    let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))) };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&op));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:14\n    |\n565 |     let op = ClassSetBinaryOp { \n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span { /* initialize with valid data */ }, \n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         kind: ClassSetBinaryOpKind::SomeKind, \n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:23\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))), \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:38\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))), \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:58\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))), \n    |                                                          ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))) \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))) \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:58\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* initialize with valid data */ }))) \n    |                                                          ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:14\n    |\n573 |     let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(Class...\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:39\n    |\n573 |     let op = ClassSetBinaryOp { span: Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(Class...\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:573:72\n    |\n573 | ... Span { /* valid data */ }, kind: ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* ...\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:118\n    |\n573 | ...ClassSetBinaryOpKind::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))), rhs: Box::new(...\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:133\n    |\n573 | ...d::SomeKind, lhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))), rhs: Box::new(ClassSet::Item(Clas...\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:153\n    |\n573 | ...hs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Rang...\n    |                                                    ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:206\n    |\n573 | ...tRange { /* valid data */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:573:221\n    |\n573 | ...ata */ }))), rhs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))) };\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:241\n    |\n573 | ...hs: Box::new(ClassSet::Item(ClassSetItem::Range(ClassSetRange { /* valid data */ }))) };\n    |                                                    ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:576:5\n    |\n576 |     assert_eq!(result, ClassInduct::BinaryOp(&op));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let op = ClassSetBinaryOp { ",
                "        span: Span { /* initialize with valid data */ }, ",
                "        kind: ClassSetBinaryOpKind::SomeKind, ",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))), ",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))) ",
                "    };",
                "    let frame = ClassFrame::Binary { op: &op };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span { /* initialize with valid data */ },",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ })))",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&op));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let op = ClassSetBinaryOp { ",
                  "        span: Span { /* initialize with valid data */ }, ",
                  "        kind: ClassSetBinaryOpKind::SomeKind, ",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))), ",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))) ",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let _ = frame.child();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span { /* initialize with valid data */ },",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ })))",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert_eq!(result, ClassInduct::BinaryOp(&op));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:14\n    |\n565 |     let op = ClassSetBinaryOp { \n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span { /* initialize with valid data */ }, \n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         kind: ClassSetBinaryOpKind::SomeKind, \n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:23\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))), \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:38\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))), \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:60\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))), \n    |                                                            ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))) \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))) \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:60\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))) \n    |                                                            ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:14\n    |\n573 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:11\n    |\n574 |     span: Span { /* initialize with valid data */ },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:576:34\n    |\n576 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:56\n    |\n576 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ }))),\n    |                                                        ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ })))\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:577:34\n    |\n577 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ })))\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:56\n    |\n577 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Unicode(ClassUnicode { /* initialize with valid data */ })))\n    |                                                        ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, ClassInduct::BinaryOp(&op));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let op = ClassSetBinaryOp { ",
                "        span: Span { /* initialize with valid data */ }, ",
                "        kind: ClassSetBinaryOpKind::SomeKind, ",
                "        lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))), ",
                "        rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))) ",
                "    };",
                "    let frame = ClassFrame::Binary { op: &op };",
                "    let _ = frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span { /* initialize with valid data */ },",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ })))",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert!(matches!(result, ClassInduct::BinaryOp(&op)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let op = ClassSetBinaryOp { ",
                  "        span: Span { /* initialize with valid data */ }, ",
                  "        kind: ClassSetBinaryOpKind::SomeKind, ",
                  "        lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))), ",
                  "        rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))) ",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let _ = frame.child();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span { /* initialize with valid data */ },",
                  "    kind: ClassSetBinaryOpKind::SomeKind,",
                  "    lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))),",
                  "    rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ })))",
                  "    };",
                  "    let frame = ClassFrame::Binary { op: &op };",
                  "    let result = frame.child();",
                  "    assert!(matches!(result, ClassInduct::BinaryOp(&op)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:14\n    |\n565 |     let op = ClassSetBinaryOp { \n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span { /* initialize with valid data */ }, \n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         kind: ClassSetBinaryOpKind::SomeKind, \n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:23\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))), \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:568:38\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))), \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:58\n    |\n568 |         lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))), \n    |                                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))) \n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:38\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))) \n    |                                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:58\n    |\n569 |         rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))) \n    |                                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:14\n    |\n573 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:11\n    |\n574 |     span: Span { /* initialize with valid data */ },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     kind: ClassSetBinaryOpKind::SomeKind,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:576:19\n    |\n576 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:576:34\n    |\n576 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))),\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:54\n    |\n576 |     lhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ }))),\n    |                                                      ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ })))\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:577:34\n    |\n577 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ })))\n    |                                  ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:54\n    |\n577 |     rhs: Box::new(ClassSet::Item(ClassSetItem::Empty(Span { /* initialize with valid data */ })))\n    |                                                      ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *self matches ClassFrame::Union { head, .. } is true\n",
        "// constraint: *self matches ClassFrame::Union { head, .. } is true\n",
        "// expected return value/type: ClassInduct::Item(head)\n"
      ],
      "input_infer": "ClassFrame::Union { head: &valid_class_set_item }, ClassFrame::Union { head: &valid_class_set_item } where valid_class_set_item represents valid variants of ClassSetItem (e.g., Literal, Range, Ascii, Unicode, Perl, Bracketed, Union)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let literal = ClassSetItem::Literal(Literal::from_char('a'));",
                "    let class_set = ClassSet::Item(literal);",
                "    let class_frame = ClassFrame::Union {",
                "        head: &class_set,",
                "        tail: &[],",
                "    };",
                "    class_frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let literal = ClassSetItem::Literal(Literal::from_char('a'));",
                  "    let class_set = ClassSet::Item(literal);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let literal = ClassSetItem::Literal(Literal::from_char('a'));",
                  "    let class_set = ClassSet::Item(literal);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let literal = ClassSetItem::Literal(Literal::from_char('a'));",
                  "    let class_set = ClassSet::Item(literal);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = ClassSetItem::Literal(Literal::from_char('a'));\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:41\n    |\n566 |     let literal = ClassSetItem::Literal(Literal::from_char('a'));\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(literal);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:19\n    |\n574 |     let literal = ClassSetItem::Literal(Literal::from_char('a'));\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:41\n    |\n574 |     let literal = ClassSetItem::Literal(Literal::from_char('a'));\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(literal);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n578 |     assert_eq!(result, ClassInduct::Item(&class_set));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                "    let class_set = ClassSet::Item(range);",
                "    let class_frame = ClassFrame::Union {",
                "        head: &class_set,",
                "        tail: &[],",
                "    };",
                "    class_frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let class_set = ClassSet::Item(range);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert!(matches!(result, ClassInduct::Item(_)));"
                ],
                [
                  "    let span = Span::new(0, 5);",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let class_set = ClassSet::Item(range);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let class_set = ClassSet::Item(range);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let class_set = ClassSet::Item(range);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert!(matches!(result, ClassInduct::Item(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let class_set = ClassSet::Item(range);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let class_set = ClassSet::Item(range);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:566:37\n    |\n566 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(range);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(range);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:566:37\n    |\n566 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(range);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let range = ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                     ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(range);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n578 |     assert_eq!(result, ClassInduct::Item(&class_set));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);",
                "    let class_set = ClassSet::Item(ascii_class);",
                "    let class_frame = ClassFrame::Union {",
                "        head: &class_set,",
                "        tail: &[],",
                "    };",
                "    class_frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let class_set = ClassSet::Item(ascii_class);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let class_set = ClassSet::Item(ascii_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let class_set = ClassSet::Item(ascii_class);",
                  "    let class_frame = ClassFrame::Union { head: &class_set, tail: &[] };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                           ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(ascii_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let ascii_class = ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                           ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(ascii_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n578 |     assert_eq!(result, ClassInduct::Item(&class_set));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                "    let class_set = ClassSet::Item(unicode_class);",
                "    let class_frame = ClassFrame::Union {",
                "        head: &class_set,",
                "        tail: &[],",
                "    };",
                "    class_frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let class_set = ClassSet::Item(unicode_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let class_set = ClassSet::Item(unicode_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let class_set = ClassSet::Item(unicode_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:25\n    |\n566 |     let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:566:47\n    |\n566 |     let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(unicode_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:574:47\n    |\n574 |     let unicode_class = ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(unicode_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, ClassInduct::Item(&class_set));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let perl_class = ClassSetItem::Perl(ClassPerl::Digit);",
                "    let class_set = ClassSet::Item(perl_class);",
                "    let class_frame = ClassFrame::Union {",
                "        head: &class_set,",
                "        tail: &[],",
                "    };",
                "    class_frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let perl_class = ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let class_set = ClassSet::Item(perl_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let perl_class = ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let class_set = ClassSet::Item(perl_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let perl_class = ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let class_set = ClassSet::Item(perl_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:22\n    |\n566 |     let perl_class = ClassSetItem::Perl(ClassPerl::Digit);\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:566:41\n    |\n566 |     let perl_class = ClassSetItem::Perl(ClassPerl::Digit);\n    |                                         ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(perl_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:22\n    |\n574 |     let perl_class = ClassSetItem::Perl(ClassPerl::Digit);\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:574:41\n    |\n574 |     let perl_class = ClassSetItem::Perl(ClassPerl::Digit);\n    |                                         ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(perl_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, ClassInduct::Item(&class_set));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                "    let class_set = ClassSet::Item(bracketed_class);",
                "    let class_frame = ClassFrame::Union {",
                "        head: &class_set,",
                "        tail: &[],",
                "    };",
                "    class_frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let class_set = ClassSet::Item(bracketed_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let class_set = ClassSet::Item(bracketed_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let class_set = ClassSet::Item(bracketed_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:27\n    |\n566 |     let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:566:60\n    |\n566 |     let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                            ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(bracketed_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:27\n    |\n574 |     let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                           ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:574:60\n    |\n574 |     let bracketed_class = ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                            ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(bracketed_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, ClassInduct::Item(&class_set));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5);",
                "    let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                "    let class_set = ClassSet::Item(union_class);",
                "    let class_frame = ClassFrame::Union {",
                "        head: &class_set,",
                "        tail: &[],",
                "    };",
                "    class_frame.child();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 5);",
                  "    let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let class_set = ClassSet::Item(union_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 5);",
                  "    let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let class_set = ClassSet::Item(union_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "        head: &class_set,",
                  "        tail: &[],",
                  "    };",
                  "    class_frame.child();",
                  "    let span = Span::new(0, 5);",
                  "    let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let class_set = ClassSet::Item(union_class);",
                  "    let class_frame = ClassFrame::Union {",
                  "    head: &class_set,",
                  "    tail: &[],",
                  "    };",
                  "    let result = class_frame.child();",
                  "    assert_eq!(result, ClassInduct::Item(&class_set));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:567:21\n    |\n567 |     let class_set = ClassSet::Item(union_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:16\n    |\n573 |     let span = Span::new(0, 5);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                       ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let union_class = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                           ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:575:21\n    |\n575 |     let class_set = ClassSet::Item(union_class);\n    |                     ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, ClassInduct::Item(&class_set));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     ast::visitor::ClassInduct<'_>\n    |     ast::visitor::ClassInduct<'_>\n    |\nnote: an implementation of `PartialEq<ast::visitor::ClassInduct<'_>>` might be missing for `ast::visitor::ClassInduct<'_>`\n   --> regex-syntax/src/ast/visitor.rs:211:1\n    |\n211 | enum ClassInduct<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<ast::visitor::ClassInduct<'_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::ClassInduct<'_>` with `#[derive(PartialEq)]`\n    |\n211 + #[derive(PartialEq)]\n212 | enum ClassInduct<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}