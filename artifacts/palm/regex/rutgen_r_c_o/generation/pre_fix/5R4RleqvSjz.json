{
  "name": "regex::compile::compile::ByteClassSet::set_word_boundary",
  "name_with_impl": "regex::compile::{impl#5}::set_word_boundary",
  "mod_info": {
    "name": "compile",
    "loc": "src/lib.rs:649:1:649:13"
  },
  "visible": false,
  "loc": "src/compile.rs:1060:5:1074:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: b1 <= 255 is true, with bound b1 == 255\n",
        "// constraint: b2 <= 255 is true, with bound b2 == 255\n",
        "// constraint: iswb(b1 as u8) == iswb(b2 as u8) is true\n",
        "// constraint: b2 <= 255 is false\n",
        "// constraint: b1 <= 255 is false\n"
      ],
      "input_infer": "b1: 0 to 255, b2: 0 to 255\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[0], false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[1], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[2], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[3], false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[255], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[254], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.byte_classes().is_empty(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[0], false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[1], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[2], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[3], false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[255], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[254], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.byte_classes().is_empty(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.0[255] = true; // Setting a specific boundary before invoking.",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    let expected_value_at_255 = true;",
                  "    assert_eq!(byte_class_set.0[255], expected_value_at_255);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    let expected_value_at_255 = true;",
                  "    let expected_value_at_254 = false;",
                  "    assert_eq!(byte_class_set.0[254], expected_value_at_254);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    let expected_value_at_255 = true;",
                  "    let expected_value_at_254 = false;",
                  "    let expected_value_at_0 = false;",
                  "    assert_eq!(byte_class_set.0[0], expected_value_at_0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true; // Setting a specific boundary before invoking.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    let expected_value_at_255 = true;",
                  "    assert_eq!(byte_class_set.0[255], expected_value_at_255);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true; // Setting a specific boundary before invoking.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    let expected_value_at_255 = true;",
                  "    let expected_value_at_254 = false;",
                  "    assert_eq!(byte_class_set.0[254], expected_value_at_254);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true; // Setting a specific boundary before invoking.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    let expected_value_at_255 = true;",
                  "    let expected_value_at_254 = false;",
                  "    let expected_value_at_0 = false;",
                  "    assert_eq!(byte_class_set.0[0], expected_value_at_0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.0[256] = true; // This should cause a panic as it exceeds valid index.",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[256] = true;",
                  "    assert!(std::panic::catch_unwind(|| { byte_class_set.set_word_boundary(); }).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[256] = true; // This should cause a panic as it exceeds valid index.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[256] = true;",
                  "    assert!(std::panic::catch_unwind(|| { byte_class_set.set_word_boundary(); }).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/compile.rs:1155:8\n     |\n1155 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0277]: the type `&mut compile::ByteClassSet` may not be safely transferred across an unwind boundary\n    --> src/compile.rs:1165:38\n     |\n1165 |     assert!(std::panic::catch_unwind(|| { byte_class_set.set_word_boundary(); }).is_err());\n     |             ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |             |                        |\n     |             |                        `&mut compile::ByteClassSet` may not be safely transferred across an unwind boundary\n     |             |                        within this `{closure@src/compile.rs:1165:38: 1165:40}`\n     |             required by a bound introduced by this call\n     |\n     = help: within `{closure@src/compile.rs:1165:38: 1165:40}`, the trait `UnwindSafe` is not implemented for `&mut compile::ByteClassSet`, which is required by `{closure@src/compile.rs:1165:38: 1165:40}: UnwindSafe`\n     = note: `UnwindSafe` is implemented for `&compile::ByteClassSet`, but not for `&mut compile::ByteClassSet`\nnote: required because it's used within this closure\n    --> src/compile.rs:1165:38\n     |\n1165 |     assert!(std::panic::catch_unwind(|| { byte_class_set.set_word_boundary(); }).is_err());\n     |                                      ^^\nnote: required by a bound in `std::panic::catch_unwind`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n     |\n349  | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 1 previous error; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.0[255] = true; // Valid index setup",
                "    let _ = byte_class_set.set_range(0, 256); // This should cause a panic.",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    assert!(std::panic::catch_unwind(|| byte_class_set.set_range(0, 256)).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true; // Valid index setup",
                  "    let _ = byte_class_set.set_range(0, 256); // This should cause a panic.",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.0[255] = true;",
                  "    assert!(std::panic::catch_unwind(|| byte_class_set.set_range(0, 256)).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/compile.rs:1155:8\n     |\n1155 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0277]: the type `&mut compile::ByteClassSet` may not be safely transferred across an unwind boundary\n    --> src/compile.rs:1165:38\n     |\n1165 |     assert!(std::panic::catch_unwind(|| byte_class_set.set_range(0, 256)).is_err());\n     |             ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |             |                        |\n     |             |                        `&mut compile::ByteClassSet` may not be safely transferred across an unwind boundary\n     |             |                        within this `{closure@src/compile.rs:1165:38: 1165:40}`\n     |             required by a bound introduced by this call\n     |\n     = help: within `{closure@src/compile.rs:1165:38: 1165:40}`, the trait `UnwindSafe` is not implemented for `&mut compile::ByteClassSet`, which is required by `{closure@src/compile.rs:1165:38: 1165:40}: UnwindSafe`\n     = note: `UnwindSafe` is implemented for `&compile::ByteClassSet`, but not for `&mut compile::ByteClassSet`\nnote: required because it's used within this closure\n    --> src/compile.rs:1165:38\n     |\n1165 |     assert!(std::panic::catch_unwind(|| byte_class_set.set_range(0, 256)).is_err());\n     |                                      ^^\nnote: required by a bound in `std::panic::catch_unwind`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n     |\n349  | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 1 previous error; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: b1 <= 255 is true, with bound b1 == 255\n",
        "// constraint: b2 <= 255 is true, with bound b2 == 255\n",
        "// constraint: iswb(b1 as u8) == iswb(b2 as u8) is false\n",
        "// constraint: b1 <= 255 is false\n"
      ],
      "input_infer": "b1 = 255, b2 = 256\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.set_range(254, 255);",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[254] == true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[255] == true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[253] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[0] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[1] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[2] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[3] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[4] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[5] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[6] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[7] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[8] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[9] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[10] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[11] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[12] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[13] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[14] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[15] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[16] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[17] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[18] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[19] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[20] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[21] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[22] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[23] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[24] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[25] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[26] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[27] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[28] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[29] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[30] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[31] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[32] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[33] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[34] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[35] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[36] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[37] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[38] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[39] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[40] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[41] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[42] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[43] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[44] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[45] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[46] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[47] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[48] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[49] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[50] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[51] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[52] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[53] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[54] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[55] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[56] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[57] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[58] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[59] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[60] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[61] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[62] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[63] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[64] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[65] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[66] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[67] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[68] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[69] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[70] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[71] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[72] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[73] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[74] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[75] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[76] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[77] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[78] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[79] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[80] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[81] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[82] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[83] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[84] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[85] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[86] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[87] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[88] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[89] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[90] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[91] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[92] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[93] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[94] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[95] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[96] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[97] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[98] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[99] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[100] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[101] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[102] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[103] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[104] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[105] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[106] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[107] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[108] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[109] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[110] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[111] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[112] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[113] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[114] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[115] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[116] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[117] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[118] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[119] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[120] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[121] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[122] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[123] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[124] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[125] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[126] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[127] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[128] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[129] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[130] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[131] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[132] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[133] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[134] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[135] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[136] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[137] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[138] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[139] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[140] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[141] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[142] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[143] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[144] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[145] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[146] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[147] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[148] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[149] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[150] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[151] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[152] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[153] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[154] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[155] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[156] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[157] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[158] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[159] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[160] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[161] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[162] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[163] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[164] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[165] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[166] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[167] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[168] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[169] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[170] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[171] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[172] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[173] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[174] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[175] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[176] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[177] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[178] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[179] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[180] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[181] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[182] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[183] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[184] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[185] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[186] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[187] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[188] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[189] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[190] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[191] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[192] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[193] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[194] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[195] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[196] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[197] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[198] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[199] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[200] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[201] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[202] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[203] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[204] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[205] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[206] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[207] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[208] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[209] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[210] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[211] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[212] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[213] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[214] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[215] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[216] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[217] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[218] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[219] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[220] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[221] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[222] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[223] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[224] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[225] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[226] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[227] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[228] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[229] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[230] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[231] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[232] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[233] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[234] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[235] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[236] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[237] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[238] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[239] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[240] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[241] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[242] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[243] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[244] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[245] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[246] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[247] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[248] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[249] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[250] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[251] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[252] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[253] == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[254] == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[255] == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[253] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[0] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[1] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[2] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[3] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[4] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[5] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[6] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[7] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[8] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[9] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[10] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[11] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[12] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[13] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[14] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[15] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[16] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[17] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[18] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[19] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[20] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[21] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[22] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[23] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[24] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[25] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[26] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[27] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[28] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[29] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[30] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[31] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[32] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[33] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[34] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[35] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[36] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[37] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[38] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[39] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[40] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[41] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[42] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[43] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[44] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[45] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[46] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[47] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[48] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[49] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[50] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[51] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[52] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[53] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[54] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[55] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[56] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[57] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[58] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[59] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[60] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[61] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[62] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[63] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[64] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[65] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[66] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[67] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[68] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[69] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[70] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[71] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[72] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[73] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[74] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[75] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[76] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[77] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[78] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[79] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[80] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[81] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[82] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[83] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[84] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[85] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[86] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[87] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[88] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[89] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[90] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[91] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[92] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[93] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[94] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[95] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[96] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[97] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[98] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[99] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[100] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[101] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[102] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[103] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[104] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[105] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[106] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[107] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[108] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[109] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[110] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[111] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[112] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[113] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[114] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[115] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[116] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[117] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[118] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[119] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[120] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[121] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[122] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[123] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[124] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[125] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[126] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[127] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[128] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[129] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[130] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[131] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[132] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[133] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[134] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[135] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[136] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[137] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[138] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[139] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[140] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[141] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[142] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[143] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[144] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[145] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[146] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[147] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[148] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[149] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[150] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[151] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[152] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[153] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[154] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[155] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[156] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[157] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[158] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[159] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[160] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[161] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[162] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[163] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[164] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[165] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[166] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[167] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[168] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[169] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[170] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[171] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[172] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[173] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[174] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[175] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[176] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[177] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[178] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[179] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[180] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[181] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[182] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[183] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[184] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[185] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[186] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[187] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[188] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[189] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[190] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[191] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[192] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[193] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[194] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[195] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[196] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[197] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[198] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[199] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[200] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[201] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[202] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[203] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[204] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[205] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[206] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[207] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[208] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[209] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[210] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[211] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[212] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[213] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[214] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[215] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[216] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[217] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[218] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[219] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[220] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[221] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[222] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[223] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[224] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[225] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[226] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[227] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[228] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[229] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[230] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[231] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[232] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[233] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[234] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[235] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[236] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[237] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[238] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[239] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[240] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[241] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[242] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[243] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[244] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[245] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[246] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[247] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[248] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[249] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[250] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[251] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[252] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(254, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[253] == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.set_range(255, 256); // This should lead to a panic",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256);",
                  "    assert!(std::panic::catch_unwind(|| {"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256);",
                  "    byte_class_set.set_word_boundary();",
                  "    }).is_err());",
                  "    assert_eq!(byte_class_set.0[255], false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256); // This should lead to a panic",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256);",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256); // This should lead to a panic",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256);",
                  "    byte_class_set.set_word_boundary();",
                  "    }).is_err());",
                  "    assert_eq!(byte_class_set.0[255], false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: mismatched closing delimiter: `}`\n    --> src/compile.rs:1165:37\n     |\n1159 | {\n     | - closing delimiter possibly meant for this\n...\n1165 |     assert!(std::panic::catch_unwind(|| {\n     |                                     ^ unclosed delimiter\n1166 | }\n1167 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> src/compile.rs:1167:3\n     |\n1153 | mod llmtests {\n     |              - unclosed delimiter\n...\n1167 | }\n     |   ^\n\nerror: could not compile `regex` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror: mismatched closing delimiter: `)`\n    --> src/compile.rs:1153:14\n     |\n1153 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n1166 |     }).is_err());\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/compile.rs:1166:16\n     |\n1166 |     }).is_err());\n     |      -         ^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `regex` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.set_range(252, 253);",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[252] == true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[253] == true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[251] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[254] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[255] == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[252] == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[253] == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[251] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[254] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(252, 253);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[255] == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.set_range(255, 256); // This should lead to a panic",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256);",
                  "    assert!(std::panic::catch_unwind(|| byte_class_set.set_word_boundary()).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256); // This should lead to a panic",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 256);",
                  "    assert!(std::panic::catch_unwind(|| byte_class_set.set_word_boundary()).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/compile.rs:1155:8\n     |\n1155 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0277]: the type `&mut compile::ByteClassSet` may not be safely transferred across an unwind boundary\n    --> src/compile.rs:1165:38\n     |\n1165 |     assert!(std::panic::catch_unwind(|| byte_class_set.set_word_boundary()).is_err());\n     |             ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |             |                        |\n     |             |                        `&mut compile::ByteClassSet` may not be safely transferred across an unwind boundary\n     |             |                        within this `{closure@src/compile.rs:1165:38: 1165:40}`\n     |             required by a bound introduced by this call\n     |\n     = help: within `{closure@src/compile.rs:1165:38: 1165:40}`, the trait `UnwindSafe` is not implemented for `&mut compile::ByteClassSet`, which is required by `{closure@src/compile.rs:1165:38: 1165:40}: UnwindSafe`\n     = note: `UnwindSafe` is implemented for `&compile::ByteClassSet`, but not for `&mut compile::ByteClassSet`\nnote: required because it's used within this closure\n    --> src/compile.rs:1165:38\n     |\n1165 |     assert!(std::panic::catch_unwind(|| byte_class_set.set_word_boundary()).is_err());\n     |                                      ^^\nnote: required by a bound in `std::panic::catch_unwind`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n     |\n349  | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 1 previous error; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: b1 <= 255 is false\n"
      ],
      "input_infer": "b1 = 256\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.set_range(0, 0); // Initial call to set_range",
                "    let b1 = 256; // Setting b1 greater than 255",
                "    // Directly invoking set_word_boundary will not cause panic due to precondition, but we'll invoke it with the given constraint.",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[0] == true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[255] == false);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[1] == true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[254] == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0); // Initial call to set_range",
                  "    let b1 = 256; // Setting b1 greater than 255",
                  "    // Directly invoking set_word_boundary will not cause panic due to precondition, but we'll invoke it with the given constraint.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[0] == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0); // Initial call to set_range",
                  "    let b1 = 256; // Setting b1 greater than 255",
                  "    // Directly invoking set_word_boundary will not cause panic due to precondition, but we'll invoke it with the given constraint.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[255] == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0); // Initial call to set_range",
                  "    let b1 = 256; // Setting b1 greater than 255",
                  "    // Directly invoking set_word_boundary will not cause panic due to precondition, but we'll invoke it with the given constraint.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[1] == true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0); // Initial call to set_range",
                  "    let b1 = 256; // Setting b1 greater than 255",
                  "    // Directly invoking set_word_boundary will not cause panic due to precondition, but we'll invoke it with the given constraint.",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(0, 0);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0[254] == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    // Call set_word_boundary to check behavior with an empty ByteClassSet",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[0], false);"
                ],
                [
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[255], false);"
                ],
                [
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.byte_classes().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    // Call set_word_boundary to check behavior with an empty ByteClassSet",
                  "    byte_class_set.set_word_boundary();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[0], false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    // Call set_word_boundary to check behavior with an empty ByteClassSet",
                  "    byte_class_set.set_word_boundary();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[255], false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    // Call set_word_boundary to check behavior with an empty ByteClassSet",
                  "    byte_class_set.set_word_boundary();",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.byte_classes().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut byte_class_set = ByteClassSet::new();",
                "    byte_class_set.set_range(255, 255); // Testing upper boundary value",
                "    byte_class_set.set_word_boundary();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    assert_eq!(byte_class_set.0[255], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[0], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[1], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[255], true);"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0.iter().any(|&x| x));"
                ],
                [
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0.iter().all(|&x| x == false || x == true));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255); // Testing upper boundary value",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    assert_eq!(byte_class_set.0[255], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255); // Testing upper boundary value",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[0], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255); // Testing upper boundary value",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[1], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255); // Testing upper boundary value",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert_eq!(byte_class_set.0[255], true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255); // Testing upper boundary value",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0.iter().any(|&x| x));",
                  "}"
                ],
                [
                  "{",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255); // Testing upper boundary value",
                  "    byte_class_set.set_word_boundary();",
                  "    let mut byte_class_set = ByteClassSet::new();",
                  "    byte_class_set.set_range(255, 255);",
                  "    byte_class_set.set_word_boundary();",
                  "    assert!(byte_class_set.0.iter().all(|&x| x == false || x == true));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}