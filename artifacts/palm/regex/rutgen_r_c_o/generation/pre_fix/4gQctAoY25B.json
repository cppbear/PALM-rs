{
  "name": "regex_syntax::hir::translate::hir::translate::TranslatorI<'t, 'p>::hir_literal",
  "name_with_impl": "regex_syntax::hir::translate::{impl#5}::hir_literal",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:29:1:29:19"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/translate.rs:606:5:616:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.literal_to_char(lit)? is Err/None\n"
      ],
      "input_infer": "lit: &ast::Literal with c = '\\u{0000}' (null character), lit.byte() = None; lit: &ast::Literal with c = '\\u{10FFFF}' (maximum Unicode character), lit.byte() = Some(0xFF) (valid byte); lit: &ast::Literal with c = 'A' (ASCII character), lit.byte() = Some(0x7F) (valid byte); lit: &ast::Literal with c = 'รง' (Unicode character), lit.byte() = Some(0x80) (non-ASCII byte, invalid for non-unicode flag); lit: &ast::Literal with c = '๐' (valid surrogate pair), lit.byte() = Some(0xFE) (invalid byte for UTF-8).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"\\u{0000}\";",
                "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let _ = translator_instance.hir_literal(&literal);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\\u{0000}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_instance.hir_literal(&literal).is_err());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\\u{0000}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_instance.hir_literal(&literal).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\u{0000}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let _ = translator_instance.hir_literal(&literal);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\\u{0000}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_instance.hir_literal(&literal).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\u{0000}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let _ = translator_instance.hir_literal(&literal);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\\u{0000}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_instance.hir_literal(&literal).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:80\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:54\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:80\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:19\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:19\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:80\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:54\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:80\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:19\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:19\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{0000}' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"\\u{10FFFF}\";",
                "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let _ = translator_instance.hir_literal(&literal);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\\u{10FFFF}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert_eq!(translator_instance.hir_literal(&literal).is_err(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\u{10FFFF}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let _ = translator_instance.hir_literal(&literal);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"\\u{10FFFF}\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert_eq!(translator_instance.hir_literal(&literal).is_err(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:80\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:54\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:80\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:19\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:19\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '\\u{10FFFF}' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"A\";",
                "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let _ = translator_instance.hir_literal(&literal);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"A\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let result = translator_instance.hir_literal(&literal);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"A\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let _ = translator_instance.hir_literal(&literal);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"A\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let result = translator_instance.hir_literal(&literal);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:80\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:54\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:80\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:19\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:19\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'A' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"รง\";",
                "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let _ = translator_instance.hir_literal(&literal);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"รง\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let result = translator_instance.hir_literal(&literal);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"รง\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let result = translator_instance.hir_literal(&literal);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"รง\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let _ = translator_instance.hir_literal(&literal);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"รง\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let result = translator_instance.hir_literal(&literal);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"รง\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let _ = translator_instance.hir_literal(&literal);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"รง\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let result = translator_instance.hir_literal(&literal);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:80\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:54\n     |\n2555 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:80\n     |\n2555 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:19\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:19\n     |\n2555 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:80\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:54\n     |\n2555 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:80\n     |\n2555 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:19\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:19\n     |\n2555 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: 'รง' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"๐\";",
                "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let _ = translator_instance.hir_literal(&literal);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"๐\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_instance.hir_literal(&literal).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"๐\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let _ = translator_instance.hir_literal(&literal);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let pattern = \"๐\";",
                  "    let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    assert!(translator_instance.hir_literal(&literal).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:80\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:54\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };\n     |                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:80\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };\n     |                                                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2546:19\n     |\n2546 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2551:19\n     |\n2551 |     let literal = ast::Literal { span: Span { start: Position::default(), end: Position::default() }, c: '๐' };\n     |                   ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.literal_to_char(lit)? is Ok/Some\n",
        "// constraint: self.literal_to_char(lit)? is Err/None\n",
        "// constraint: self.literal_to_char(lit)? matches byte @ hir::Literal::Byte(_) is true\n",
        "// expected return value/type: Ok(Hir::literal(byte))\n"
      ],
      "input_infer": "test_input_ranges: (0x00 to 0x7F, 0x80 to 0xFF, '\\u{0000}' to '\\u{10FFFF}')\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"a\";",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                "    let lit = ast::Literal { span, c: 'a' };",
                "    translator_instance.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert_eq!(translator_instance.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(translator_instance.hir_literal(&lit).is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(matches!(translator_instance.literal_to_char(&lit), Ok(hir::Literal::Unicode('a'))));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(matches!(translator_instance.hir_literal(&lit), Ok(Hir::literal(hir::Literal::Unicode('a')))));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(translator_instance.hir_literal(&lit).unwrap().is_always_utf8());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(!translator_instance.hir_literal(&lit).unwrap().is_match_empty());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert_eq!(translator_instance.hir_literal(&lit).unwrap().info.is_all_assertions(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert_eq!(translator_instance.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(translator_instance.hir_literal(&lit).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(matches!(translator_instance.literal_to_char(&lit), Ok(hir::Literal::Unicode('a'))));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(matches!(translator_instance.hir_literal(&lit), Ok(Hir::literal(hir::Literal::Unicode('a')))));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(translator_instance.hir_literal(&lit).unwrap().is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert!(!translator_instance.hir_literal(&lit).unwrap().is_match_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"a\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'a' };",
                  "    assert_eq!(translator_instance.hir_literal(&lit).unwrap().info.is_all_assertions(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2555:72\n     |\n2555 |     assert_eq!(translator_instance.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));\n     |                                                                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0164]: expected tuple struct or tuple variant, found associated function `Hir::literal`\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     assert!(matches!(translator_instance.hir_literal(&lit), Ok(Hir::literal(hir::Literal::Unicode('a')))));\n     |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n     |\n     = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0164, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"invalid_utf8\";",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                "    let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8",
                "    let result = translator_instance.hir_literal(&lit);",
                "    // Assumed further code to verify `result` will be placed here in practical terms.",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    // Assumed further code to verify `result` will be placed here in practical terms.",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    // Assumed further code to verify `result` will be placed here in practical terms.",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    // Assumed further code to verify `result` will be placed here in practical terms.",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    // Assumed further code to verify `result` will be placed here in practical terms.",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    // Assumed further code to verify `result` will be placed here in practical terms.",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    // Assumed further code to verify `result` will be placed here in practical terms.",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"invalid_utf8\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: '\\u{FFFD}' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let lit_byte = ast::Literal { span, c: 'a' };",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });",
                  "    let result = translator_instance.hir_literal(&lit_byte);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:53\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lit = ast::Literal { span, c: '\\u{FFFD}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:53\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lit = ast::Literal { span, c: '\\u{FFFD}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:53\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0425]: cannot find value `trans_instance` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:5\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |     ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lit = ast::Literal { span, c: '\\u{FFFD}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2561:20\n     |\n2561 |     let lit_byte = ast::Literal { span, c: 'a' };\n     |                    ^^^^^^^^^^^^ missing `kind`\n\nerror[E0560]: struct `ast::Flags` has no field named `case_insensitive`\n    --> regex-syntax/src/hir/translate.rs:2562:44\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |                                            ^^^^^^^^^^^^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `span`, `items`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:53\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0425]: cannot find value `trans_instance` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:5\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:41\n     |\n2564 |     assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lit = ast::Literal { span, c: '\\u{FFFD}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2561:20\n     |\n2561 |     let lit_byte = ast::Literal { span, c: 'a' };\n     |                    ^^^^^^^^^^^^ missing `kind`\n\nerror[E0560]: struct `ast::Flags` has no field named `case_insensitive`\n    --> regex-syntax/src/hir/translate.rs:2562:44\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |                                            ^^^^^^^^^^^^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `span`, `items`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:53\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0425]: cannot find value `trans_instance` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:5\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `trans_instance` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:5\n     |\n2564 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });\n     |     ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lit = ast::Literal { span, c: '\\u{FFFD}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2561:20\n     |\n2561 |     let lit_byte = ast::Literal { span, c: 'a' };\n     |                    ^^^^^^^^^^^^ missing `kind`\n\nerror[E0560]: struct `ast::Flags` has no field named `case_insensitive`\n    --> regex-syntax/src/hir/translate.rs:2562:44\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |                                            ^^^^^^^^^^^^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `span`, `items`\n\nerror[E0560]: struct `ast::Flags` has no field named `case_insensitive`\n    --> regex-syntax/src/hir/translate.rs:2564:44\n     |\n2564 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });\n     |                                            ^^^^^^^^^^^^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `span`, `items`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2558:53\n     |\n2558 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0425]: cannot find value `trans_instance` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:5\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `trans_instance` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:5\n     |\n2564 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });\n     |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2566:41\n     |\n2566 |     assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: '\\u{FFFD}' }; // Unicode replacement character for invalid UTF-8\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lit = ast::Literal { span, c: '\\u{FFFD}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2561:20\n     |\n2561 |     let lit_byte = ast::Literal { span, c: 'a' };\n     |                    ^^^^^^^^^^^^ missing `kind`\n\nerror[E0560]: struct `ast::Flags` has no field named `case_insensitive`\n    --> regex-syntax/src/hir/translate.rs:2562:44\n     |\n2562 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(false), ..Default::default() });\n     |                                            ^^^^^^^^^^^^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `span`, `items`\n\nerror[E0560]: struct `ast::Flags` has no field named `case_insensitive`\n    --> regex-syntax/src/hir/translate.rs:2564:44\n     |\n2564 |     trans_instance.set_flags(&ast::Flags { case_insensitive: Some(true), ..Default::default() });\n     |                                            ^^^^^^^^^^^^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `span`, `items`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"case_sensitive\";",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                "    let lit = ast::Literal { span, c: 'A' };",
                "    translator_instance.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    assert!(translator_instance.hir_literal(&lit).is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    assert_eq!(translator_instance.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('A')));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let lit_byte = ast::Literal { span, c: 'B' }; // Assuming 'B' corresponds to a byte value.",
                  "    assert!(translator_instance.hir_literal(&lit_byte).is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let lit_byte = ast::Literal { span, c: 'B' }; // Assuming 'B' corresponds to a byte value.",
                  "    assert_eq!(translator_instance.hir_literal(&lit_byte).unwrap().kind(), &HirKind::Literal(hir::Literal::Byte('B' as u8)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    assert!(translator_instance.hir_literal(&lit).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    assert_eq!(translator_instance.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('A')));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let lit_byte = ast::Literal { span, c: 'B' }; // Assuming 'B' corresponds to a byte value.",
                  "    assert!(translator_instance.hir_literal(&lit_byte).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_sensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let lit_byte = ast::Literal { span, c: 'B' }; // Assuming 'B' corresponds to a byte value.",
                  "    assert_eq!(translator_instance.hir_literal(&lit_byte).unwrap().kind(), &HirKind::Literal(hir::Literal::Byte('B' as u8)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:53\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:53\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2559:72\n     |\n2559 |     assert_eq!(translator_instance.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('A')));\n     |                                                                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:53\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:20\n     |\n2559 |     let lit_byte = ast::Literal { span, c: 'B' }; // Assuming 'B' corresponds to a byte value.\n     |                    ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:53\n     |\n2557 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2560:77\n     |\n2560 |     assert_eq!(translator_instance.hir_literal(&lit_byte).unwrap().kind(), &HirKind::Literal(hir::Literal::Byte('B' as u8)));\n     |                                                                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2559:20\n     |\n2559 |     let lit_byte = ast::Literal { span, c: 'B' }; // Assuming 'B' corresponds to a byte value.\n     |                    ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { case_insensitive: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"case_insensitive\";",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                "    let lit = ast::Literal { span, c: 'A' };",
                "    translator_instance.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(true), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"case_insensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(true), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"case_insensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('A')));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_insensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(true), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"case_insensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"case_insensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(true), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"case_insensitive\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 'A' };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('A')));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |     assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('A')));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"byte_test\";",
                "    let translator_instance = TranslatorI::new(&translator, pattern);",
                "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                "    let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128",
                "    translator_instance.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Byte(0x80)));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Byte(0x80)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128",
                  "    translator_instance.hir_literal(&lit);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"byte_test\";",
                  "    let translator_instance = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: Position::new(0), end: Position::new(1) };",
                  "    let lit = ast::Literal { span, c: 0x80 as char };",
                  "    let result = translator_instance.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 0x80 as char };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |     assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Byte(0x80)));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 0x80 as char };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 0x80 as char };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:53\n     |\n2547 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let span = Span { start: Position::new(0), end: Position::new(1) };\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = ast::Literal { span, c: 0x80 as char }; // A byte >= 128\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |     let lit = ast::Literal { span, c: 0x80 as char };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.literal_to_char(lit)? is Ok/Some\n",
        "// constraint: self.literal_to_char(lit)? is Ok/Some\n",
        "// constraint: self.flags().case_insensitive() is true\n"
      ],
      "input_infer": "lit: {c: 'a', byte: None} or {c: 'รค', byte: None} or {c: '1', byte: Some(1)}, flags: {case_insensitive: true}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let lit = ast::Literal { span, c: 'a', byte: None };",
                "    let translator_i = TranslatorI::new(&translator, \"a\");",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut flags = Flags::default();",
                  "    flags.case_insensitive = Some(true);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'a', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"a\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.case_insensitive = Some(true);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'a', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"a\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Literal(hir::Literal::Unicode('a')));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'a', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"a\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let mut flags = Flags::default();",
                  "    flags.case_insensitive = Some(true);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'a', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"a\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'a', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"a\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let mut flags = Flags::default();",
                  "    flags.case_insensitive = Some(true);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'a', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"a\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Literal(hir::Literal::Unicode('a')));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:56\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: 'a', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2558:44\n     |\n2558 |     let lit = ast::Literal { span, c: 'a', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:56\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2562:36\n     |\n2562 |     assert_eq!(hir_result.kind(), &HirKind::Literal(hir::Literal::Unicode('a')));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: 'a', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2558:44\n     |\n2558 |     let lit = ast::Literal { span, c: 'a', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('รค')));"
                ],
                [
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());"
                ],
                [
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_all_assertions());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('รค')));",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: 'รค', byte: None };",
                  "    let translator_i = TranslatorI::new(&translator, \"รค\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_all_assertions());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:30\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:56\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2557:44\n     |\n2557 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:30\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:56\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2561:29\n     |\n2561 |     assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('รค')));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2557:44\n     |\n2557 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:30\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:56\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2557:44\n     |\n2557 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:30\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:56\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2557:44\n     |\n2557 |     let lit = ast::Literal { span, c: 'รค', byte: None };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let lit = ast::Literal { span, c: '1', byte: Some(1) };",
                "    let translator_i = TranslatorI::new(&translator, \"1\");",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: true };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: '1', byte: Some(1) };",
                  "    let translator_i = TranslatorI::new(&translator, \"1\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: true };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: '1', byte: Some(1) };",
                  "    let translator_i = TranslatorI::new(&translator, \"1\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Byte(1)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: '1', byte: Some(1) };",
                  "    let translator_i = TranslatorI::new(&translator, \"1\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: true };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: '1', byte: Some(1) };",
                  "    let translator_i = TranslatorI::new(&translator, \"1\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: '1', byte: Some(1) };",
                  "    let translator_i = TranslatorI::new(&translator, \"1\");",
                  "    translator_i.hir_literal(&lit);",
                  "    let flags = Flags { case_insensitive: Some(true), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: true };",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let lit = ast::Literal { span, c: '1', byte: Some(1) };",
                  "    let translator_i = TranslatorI::new(&translator, \"1\");",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Byte(1)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2552:56\n     |\n2552 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: '1', byte: Some(1) };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let lit = ast::Literal { span, c: '1', byte: Some(1) };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2552:56\n     |\n2552 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |     assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Byte(1)));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |     let lit = ast::Literal { span, c: '1', byte: Some(1) };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0560]: struct `ast::Literal` has no field named `byte`\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let lit = ast::Literal { span, c: '1', byte: Some(1) };\n     |                                            ^^^^ `ast::Literal` does not have this field\n     |\n     = note: available fields are: `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self.literal_to_char(lit)? is Ok/Some\n",
        "// constraint: self.literal_to_char(lit)? is Ok/Some\n",
        "// constraint: self.flags().case_insensitive() is false\n"
      ],
      "input_infer": "span.start: 0-100, span.end: 1-101, lit.c: U+0000-U+007F, flags.case_insensitive: false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(trans.flags.get().case_insensitive() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(trans.flags.get().case_insensitive() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2557:41\n     |\n2557 |     assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('a')));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: 'a' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('\\u{007F}')));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('\\u{007F}')));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2557:41\n     |\n2557 |     assert_eq!(result.unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('\\u{007F}')));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' }; // max char in ASCII\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 0, end: 1 }, c: '\\u{007F}' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert_eq!(translator_i.flags().case_insensitive(), false);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert!(translator_i.literal_to_char(&lit).is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert!(translator_i.hir_literal(&lit).is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert!(translator_i.hir_from_char(lit.span, 'ฮฒ').is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert_eq!(translator_i.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('ฮฒ')));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert_eq!(translator_i.flags().case_insensitive(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert!(translator_i.literal_to_char(&lit).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert!(translator_i.hir_literal(&lit).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert!(translator_i.hir_from_char(lit.span, 'ฮฒ').is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };",
                  "    assert_eq!(translator_i.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('ฮฒ')));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2556:65\n     |\n2556 |     assert_eq!(translator_i.hir_literal(&lit).unwrap().kind(), &HirKind::Literal(hir::Literal::Unicode('ฮฒ')));\n     |                                                                 ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' }; // non-ASCII character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:58\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |     let lit = ast::Literal { span: Span { start: 1, end: 2 }, c: 'ฮฒ' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Literal(hir::Literal::Unicode('1')));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_end());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Literal(hir::Literal::Unicode('1')));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2565:36\n     |\n2565 |     assert_eq!(hir_result.kind(), &HirKind::Literal(hir::Literal::Unicode('1')));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' }; // numeric character\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 2, end: 3 }, c: '1' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed",
                "    translator_i.hir_literal(&lit);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('A')));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_always_utf8());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('A')));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed",
                  "    translator_i.hir_literal(&lit);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };",
                  "    let result = translator_i.hir_literal(&lit);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n2565 |     assert_eq!(hir.kind(), &HirKind::Literal(hir::Literal::Unicode('A')));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:50\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:58\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' }; // span larger than needed\n     |               ^^^^^^^^^^^^ missing `kind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:50\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:58\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |                                                          ^^ expected `Position`, found integer\n\nerror[E0063]: missing field `kind` in initializer of `ast::Literal`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |     let lit = ast::Literal { span: Span { start: 0, end: 10 }, c: 'A' };\n     |               ^^^^^^^^^^^^ missing `kind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0308, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}